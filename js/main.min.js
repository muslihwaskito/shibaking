/*! For license information please see main.min.js.LICENSE */ ! function (modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: !1,
            exports: {}
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports
    }
    __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function (exports, name, getter) {
        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
            enumerable: !0,
            get: getter
        })
    }, __webpack_require__.r = function (exports) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(exports, "__esModule", {
            value: !0
        })
    }, __webpack_require__.t = function (value, mode) {
        if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
        if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
        var ns = Object.create(null);
        if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
            enumerable: !0,
            value: value
        }), 2 & mode && "string" != typeof value)
            for (var key in value) __webpack_require__.d(ns, key, function (key) {
                return value[key]
            }.bind(null, key));
        return ns
    }, __webpack_require__.n = function (module) {
        var getter = module && module.__esModule ? function () {
            return module.default
        } : function () {
            return module
        };
        return __webpack_require__.d(getter, "a", getter), getter
    }, __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property)
    }, __webpack_require__.p = "static/js/index.html", __webpack_require__(__webpack_require__.s = 6)
}([function (module, exports, __webpack_require__) {
    var factory;
    factory = function () {
        return function (modules) {
            var installedModules = {};

            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) return installedModules[moduleId].exports;
                var module = installedModules[moduleId] = {
                    i: moduleId,
                    l: !1,
                    exports: {}
                };
                return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports
            }
            return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function (exports, name, getter) {
                __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
                    enumerable: !0,
                    get: getter
                })
            }, __webpack_require__.r = function (exports) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(exports, "__esModule", {
                    value: !0
                })
            }, __webpack_require__.t = function (value, mode) {
                if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
                if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
                var ns = Object.create(null);
                if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
                    enumerable: !0,
                    value: value
                }), 2 & mode && "string" != typeof value)
                    for (var key in value) __webpack_require__.d(ns, key, function (key) {
                        return value[key]
                    }.bind(null, key));
                return ns
            }, __webpack_require__.n = function (module) {
                var getter = module && module.__esModule ? function () {
                    return module.default
                } : function () {
                    return module
                };
                return __webpack_require__.d(getter, "a", getter), getter
            }, __webpack_require__.o = function (object, property) {
                return Object.prototype.hasOwnProperty.call(object, property)
            }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 0)
        }([function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            var argumentAsArray = function (argument) {
                return Array.isArray(argument) ? argument : [argument]
            },
                isElement = function (target) {
                    return target instanceof Node
                },
                eachNode = function (nodeList, callback) {
                    if (nodeList && callback) {
                        nodeList = function (nodeList) {
                            return nodeList instanceof NodeList
                        }(nodeList) ? nodeList : [nodeList];
                        for (var i = 0; i < nodeList.length && !0 !== callback(nodeList[i], i, nodeList.length); i++);
                    }
                },
                arrayAsSelector = function (array) {
                    if (Array.isArray(array)) return array.join(", ")
                },
                nodeListAsArray = function (nodeList) {
                    var nodes = [];
                    return eachNode(nodeList, (function (node) {
                        return nodes.push(node)
                    })), nodes
                },
                findParentBySelector = function ($el, selector) {
                    var self = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                        $root = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : document;
                    if (self && -1 !== nodeListAsArray($root.querySelectorAll(selector)).indexOf($el)) return $el;
                    for (;
                        ($el = $el.parentElement) && -1 === nodeListAsArray($root.querySelectorAll(selector)).indexOf($el););
                    return $el
                },
                elementHasSelector = function ($el, selector) {
                    var $root = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : document,
                        has = -1 !== nodeListAsArray($root.querySelectorAll(selector)).indexOf($el);
                    return has
                },
                elementHasOverflowHidden = function ($el) {
                    if ($el) return "hidden" === getComputedStyle($el).overflow
                },
                elementScrollTopOnStart = function ($el) {
                    if ($el) return !!elementHasOverflowHidden($el) || $el.scrollTop <= 0
                },
                elementScrollTopOnEnd = function ($el) {
                    if ($el) {
                        if (elementHasOverflowHidden($el)) return !0;
                        var scrollTop = $el.scrollTop,
                            scrollHeight = $el.scrollHeight;
                        return scrollTop + $el.offsetHeight >= scrollHeight
                    }
                },
                elementScrollLeftOnStart = function ($el) {
                    if ($el) return !!elementHasOverflowHidden($el) || $el.scrollLeft <= 0
                },
                elementScrollLeftOnEnd = function ($el) {
                    if ($el) {
                        if (elementHasOverflowHidden($el)) return !0;
                        var scrollLeft = $el.scrollLeft,
                            scrollWidth = $el.scrollWidth;
                        return scrollLeft + $el.offsetWidth >= scrollWidth
                    }
                },
                elementIsScrollableField = function ($el) {
                    return elementHasSelector($el, 'textarea, [contenteditable="true"]')
                },
                elementIsInputRange = function ($el) {
                    return elementHasSelector($el, 'input[type="range"]')
                };

            function _defineProperty(obj, key, value) {
                return key in obj ? Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : obj[key] = value, obj
            }
            __webpack_require__.d(__webpack_exports__, "disablePageScroll", (function () {
                return disablePageScroll
            })), __webpack_require__.d(__webpack_exports__, "enablePageScroll", (function () {
                return enablePageScroll
            })), __webpack_require__.d(__webpack_exports__, "getScrollState", (function () {
                return getScrollState
            })), __webpack_require__.d(__webpack_exports__, "clearQueueScrollLocks", (function () {
                return clearQueueScrollLocks
            })), __webpack_require__.d(__webpack_exports__, "getTargetScrollBarWidth", (function () {
                return scroll_lock_getTargetScrollBarWidth
            })), __webpack_require__.d(__webpack_exports__, "getCurrentTargetScrollBarWidth", (function () {
                return scroll_lock_getCurrentTargetScrollBarWidth
            })), __webpack_require__.d(__webpack_exports__, "getPageScrollBarWidth", (function () {
                return getPageScrollBarWidth
            })), __webpack_require__.d(__webpack_exports__, "getCurrentPageScrollBarWidth", (function () {
                return getCurrentPageScrollBarWidth
            })), __webpack_require__.d(__webpack_exports__, "addScrollableTarget", (function () {
                return scroll_lock_addScrollableTarget
            })), __webpack_require__.d(__webpack_exports__, "removeScrollableTarget", (function () {
                return scroll_lock_removeScrollableTarget
            })), __webpack_require__.d(__webpack_exports__, "addScrollableSelector", (function () {
                return scroll_lock_addScrollableSelector
            })), __webpack_require__.d(__webpack_exports__, "removeScrollableSelector", (function () {
                return scroll_lock_removeScrollableSelector
            })), __webpack_require__.d(__webpack_exports__, "addLockableTarget", (function () {
                return scroll_lock_addLockableTarget
            })), __webpack_require__.d(__webpack_exports__, "addLockableSelector", (function () {
                return scroll_lock_addLockableSelector
            })), __webpack_require__.d(__webpack_exports__, "setFillGapMethod", (function () {
                return scroll_lock_setFillGapMethod
            })), __webpack_require__.d(__webpack_exports__, "addFillGapTarget", (function () {
                return scroll_lock_addFillGapTarget
            })), __webpack_require__.d(__webpack_exports__, "removeFillGapTarget", (function () {
                return scroll_lock_removeFillGapTarget
            })), __webpack_require__.d(__webpack_exports__, "addFillGapSelector", (function () {
                return scroll_lock_addFillGapSelector
            })), __webpack_require__.d(__webpack_exports__, "removeFillGapSelector", (function () {
                return scroll_lock_removeFillGapSelector
            })), __webpack_require__.d(__webpack_exports__, "refillGaps", (function () {
                return refillGaps
            }));
            var FILL_GAP_AVAILABLE_METHODS = ["padding", "margin", "width", "max-width", "none"],
                state = {
                    scroll: !0,
                    queue: 0,
                    scrollableSelectors: ["[data-scroll-lock-scrollable]"],
                    lockableSelectors: ["body", "[data-scroll-lock-lockable]"],
                    fillGapSelectors: ["body", "[data-scroll-lock-fill-gap]", "[data-scroll-lock-lockable]"],
                    fillGapMethod: FILL_GAP_AVAILABLE_METHODS[0],
                    startTouchY: 0,
                    startTouchX: 0
                },
                disablePageScroll = function (target) {
                    state.queue <= 0 && (state.scroll = !1, scroll_lock_hideLockableOverflow(), fillGaps()), scroll_lock_addScrollableTarget(target), state.queue++
                },
                enablePageScroll = function (target) {
                    state.queue > 0 && state.queue--, state.queue <= 0 && (state.scroll = !0, scroll_lock_showLockableOverflow(), unfillGaps()), scroll_lock_removeScrollableTarget(target)
                },
                getScrollState = function () {
                    return state.scroll
                },
                clearQueueScrollLocks = function () {
                    state.queue = 0
                },
                scroll_lock_getTargetScrollBarWidth = function ($target) {
                    var onlyExists = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (isElement($target)) {
                        var currentOverflowYProperty = $target.style.overflowY;
                        onlyExists ? getScrollState() || ($target.style.overflowY = $target.getAttribute("data-scroll-lock-saved-overflow-y-property")) : $target.style.overflowY = "scroll";
                        var width = scroll_lock_getCurrentTargetScrollBarWidth($target);
                        return $target.style.overflowY = currentOverflowYProperty, width
                    }
                    return 0
                },
                scroll_lock_getCurrentTargetScrollBarWidth = function ($target) {
                    if (isElement($target)) {
                        if ($target === document.body) {
                            var documentWidth = document.documentElement.clientWidth;
                            return window.innerWidth - documentWidth
                        }
                        var borderLeftWidthCurrentProperty = $target.style.borderLeftWidth,
                            borderRightWidthCurrentProperty = $target.style.borderRightWidth;
                        $target.style.borderLeftWidth = "0px", $target.style.borderRightWidth = "0px";
                        var _currentWidth = $target.offsetWidth - $target.clientWidth;
                        return $target.style.borderLeftWidth = borderLeftWidthCurrentProperty, $target.style.borderRightWidth = borderRightWidthCurrentProperty, _currentWidth
                    }
                    return 0
                },
                getPageScrollBarWidth = function () {
                    var onlyExists = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    return scroll_lock_getTargetScrollBarWidth(document.body, onlyExists)
                },
                getCurrentPageScrollBarWidth = function () {
                    return scroll_lock_getCurrentTargetScrollBarWidth(document.body)
                },
                scroll_lock_addScrollableTarget = function (target) {
                    target && argumentAsArray(target).map((function ($targets) {
                        eachNode($targets, (function ($target) {
                            isElement($target) ? $target.setAttribute("data-scroll-lock-scrollable", "") : '"'.concat($target, '" is not a Element.')
                        }))
                    }))
                },
                scroll_lock_removeScrollableTarget = function (target) {
                    target && argumentAsArray(target).map((function ($targets) {
                        eachNode($targets, (function ($target) {
                            isElement($target) ? $target.removeAttribute("data-scroll-lock-scrollable") : '"'.concat($target, '" is not a Element.')
                        }))
                    }))
                },
                scroll_lock_addScrollableSelector = function (selector) {
                    selector && argumentAsArray(selector).map((function (selector) {
                        state.scrollableSelectors.push(selector)
                    }))
                },
                scroll_lock_removeScrollableSelector = function (selector) {
                    selector && argumentAsArray(selector).map((function (selector) {
                        state.scrollableSelectors = state.scrollableSelectors.filter((function (sSelector) {
                            return sSelector !== selector
                        }))
                    }))
                },
                scroll_lock_addLockableTarget = function (target) {
                    target && (argumentAsArray(target).map((function ($targets) {
                        eachNode($targets, (function ($target) {
                            isElement($target) ? $target.setAttribute("data-scroll-lock-lockable", "") : '"'.concat($target, '" is not a Element.')
                        }))
                    })), getScrollState() || scroll_lock_hideLockableOverflow())
                },
                scroll_lock_addLockableSelector = function (selector) {
                    selector && (argumentAsArray(selector).map((function (selector) {
                        state.lockableSelectors.push(selector)
                    })), getScrollState() || scroll_lock_hideLockableOverflow(), scroll_lock_addFillGapSelector(selector))
                },
                scroll_lock_setFillGapMethod = function (method) {
                    if (method)
                        if (-1 !== FILL_GAP_AVAILABLE_METHODS.indexOf(method)) state.fillGapMethod = method, refillGaps();
                        else {
                            var methods = FILL_GAP_AVAILABLE_METHODS.join(", ");
                            '"'.concat(method, '" method is not available!\nAvailable fill gap methods: ').concat(methods, ".")
                        }
                },
                scroll_lock_addFillGapTarget = function (target) {
                    target && argumentAsArray(target).map((function ($targets) {
                        eachNode($targets, (function ($target) {
                            isElement($target) ? ($target.setAttribute("data-scroll-lock-fill-gap", ""), state.scroll || scroll_lock_fillGapTarget($target)) : '"'.concat($target, '" is not a Element.')
                        }))
                    }))
                },
                scroll_lock_removeFillGapTarget = function (target) {
                    target && argumentAsArray(target).map((function ($targets) {
                        eachNode($targets, (function ($target) {
                            isElement($target) ? ($target.removeAttribute("data-scroll-lock-fill-gap"), state.scroll || scroll_lock_unfillGapTarget($target)) : '"'.concat($target, '" is not a Element.')
                        }))
                    }))
                },
                scroll_lock_addFillGapSelector = function (selector) {
                    selector && argumentAsArray(selector).map((function (selector) {
                        -1 === state.fillGapSelectors.indexOf(selector) && (state.fillGapSelectors.push(selector), state.scroll || scroll_lock_fillGapSelector(selector))
                    }))
                },
                scroll_lock_removeFillGapSelector = function (selector) {
                    selector && argumentAsArray(selector).map((function (selector) {
                        state.fillGapSelectors = state.fillGapSelectors.filter((function (fSelector) {
                            return fSelector !== selector
                        })), state.scroll || scroll_lock_unfillGapSelector(selector)
                    }))
                },
                refillGaps = function () {
                    state.scroll || fillGaps()
                },
                scroll_lock_hideLockableOverflow = function () {
                    var selector = arrayAsSelector(state.lockableSelectors);
                    scroll_lock_hideLockableOverflowSelector(selector)
                },
                scroll_lock_showLockableOverflow = function () {
                    var selector = arrayAsSelector(state.lockableSelectors);
                    scroll_lock_showLockableOverflowSelector(selector)
                },
                scroll_lock_hideLockableOverflowSelector = function (selector) {
                    var $targets = document.querySelectorAll(selector);
                    eachNode($targets, (function ($target) {
                        scroll_lock_hideLockableOverflowTarget($target)
                    }))
                },
                scroll_lock_showLockableOverflowSelector = function (selector) {
                    var $targets = document.querySelectorAll(selector);
                    eachNode($targets, (function ($target) {
                        scroll_lock_showLockableOverflowTarget($target)
                    }))
                },
                scroll_lock_hideLockableOverflowTarget = function ($target) {
                    if (isElement($target) && "true" !== $target.getAttribute("data-scroll-lock-locked")) {
                        var computedStyle = window.getComputedStyle($target);
                        $target.setAttribute("data-scroll-lock-saved-overflow-y-property", computedStyle.overflowY), $target.setAttribute("data-scroll-lock-saved-inline-overflow-property", $target.style.overflow), $target.setAttribute("data-scroll-lock-saved-inline-overflow-y-property", $target.style.overflowY), $target.style.overflow = "hidden", $target.setAttribute("data-scroll-lock-locked", "true")
                    }
                },
                scroll_lock_showLockableOverflowTarget = function ($target) {
                    isElement($target) && "true" === $target.getAttribute("data-scroll-lock-locked") && ($target.style.overflow = $target.getAttribute("data-scroll-lock-saved-inline-overflow-property"), $target.style.overflowY = $target.getAttribute("data-scroll-lock-saved-inline-overflow-y-property"), $target.removeAttribute("data-scroll-lock-saved-overflow-property"), $target.removeAttribute("data-scroll-lock-saved-inline-overflow-property"), $target.removeAttribute("data-scroll-lock-saved-inline-overflow-y-property"), $target.removeAttribute("data-scroll-lock-locked"))
                },
                fillGaps = function () {
                    state.fillGapSelectors.map((function (selector) {
                        scroll_lock_fillGapSelector(selector)
                    }))
                },
                unfillGaps = function () {
                    state.fillGapSelectors.map((function (selector) {
                        scroll_lock_unfillGapSelector(selector)
                    }))
                },
                scroll_lock_fillGapSelector = function (selector) {
                    var $targets = document.querySelectorAll(selector),
                        isLockable = -1 !== state.lockableSelectors.indexOf(selector);
                    eachNode($targets, (function ($target) {
                        scroll_lock_fillGapTarget($target, isLockable)
                    }))
                },
                scroll_lock_fillGapTarget = function ($target) {
                    var isLockable = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (isElement($target)) {
                        var scrollBarWidth;
                        if ("" === $target.getAttribute("data-scroll-lock-lockable") || isLockable) scrollBarWidth = scroll_lock_getTargetScrollBarWidth($target, !0);
                        else {
                            var $lockableParent = findParentBySelector($target, arrayAsSelector(state.lockableSelectors));
                            scrollBarWidth = scroll_lock_getTargetScrollBarWidth($lockableParent, !0)
                        }
                        "true" === $target.getAttribute("data-scroll-lock-filled-gap") && scroll_lock_unfillGapTarget($target);
                        var computedStyle = window.getComputedStyle($target);
                        if ($target.setAttribute("data-scroll-lock-filled-gap", "true"), $target.setAttribute("data-scroll-lock-current-fill-gap-method", state.fillGapMethod), "margin" === state.fillGapMethod) {
                            var currentMargin = parseFloat(computedStyle.marginRight);
                            $target.style.marginRight = "".concat(currentMargin + scrollBarWidth, "px")
                        } else if ("width" === state.fillGapMethod) $target.style.width = "calc(100% - ".concat(scrollBarWidth, "px)");
                        else if ("max-width" === state.fillGapMethod) $target.style.maxWidth = "calc(100% - ".concat(scrollBarWidth, "px)");
                        else if ("padding" === state.fillGapMethod) {
                            var currentPadding = parseFloat(computedStyle.paddingRight);
                            $target.style.paddingRight = "".concat(currentPadding + scrollBarWidth, "px")
                        }
                    }
                },
                scroll_lock_unfillGapSelector = function (selector) {
                    var $targets = document.querySelectorAll(selector);
                    eachNode($targets, (function ($target) {
                        scroll_lock_unfillGapTarget($target)
                    }))
                },
                scroll_lock_unfillGapTarget = function ($target) {
                    if (isElement($target) && "true" === $target.getAttribute("data-scroll-lock-filled-gap")) {
                        var currentFillGapMethod = $target.getAttribute("data-scroll-lock-current-fill-gap-method");
                        $target.removeAttribute("data-scroll-lock-filled-gap"), $target.removeAttribute("data-scroll-lock-current-fill-gap-method"), "margin" === currentFillGapMethod ? $target.style.marginRight = "" : "width" === currentFillGapMethod ? $target.style.width = "" : "max-width" === currentFillGapMethod ? $target.style.maxWidth = "" : "padding" === currentFillGapMethod && ($target.style.paddingRight = "")
                    }
                };
            "undefined" != typeof window && window.addEventListener("resize", (function (e) {
                refillGaps()
            })), "undefined" != typeof document && (document.addEventListener("touchstart", (function (e) {
                state.scroll || (state.startTouchY = e.touches[0].clientY, state.startTouchX = e.touches[0].clientX)
            })), document.addEventListener("touchmove", (function (e) {
                if (!state.scroll) {
                    var startTouchY = state.startTouchY,
                        startTouchX = state.startTouchX,
                        currentClientY = e.touches[0].clientY,
                        currentClientX = e.touches[0].clientX;
                    if (e.touches.length < 2) {
                        var selector = arrayAsSelector(state.scrollableSelectors),
                            direction = {
                                up: startTouchY < currentClientY,
                                down: startTouchY > currentClientY,
                                left: startTouchX < currentClientX,
                                right: startTouchX > currentClientX
                            },
                            directionWithOffset = {
                                up: startTouchY + 3 < currentClientY,
                                down: startTouchY - 3 > currentClientY,
                                left: startTouchX + 3 < currentClientX,
                                right: startTouchX - 3 > currentClientX
                            };
                        ! function handle($el) {
                            var skip = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            if ($el) {
                                var parentScrollableEl = findParentBySelector($el, selector, !1);
                                if (elementIsInputRange($el)) return !1;
                                if (skip || elementIsScrollableField($el) && findParentBySelector($el, selector) || elementHasSelector($el, selector)) {
                                    var prevent = !1;
                                    elementScrollLeftOnStart($el) && elementScrollLeftOnEnd($el) ? (direction.up && elementScrollTopOnStart($el) || direction.down && elementScrollTopOnEnd($el)) && (prevent = !0) : elementScrollTopOnStart($el) && elementScrollTopOnEnd($el) ? (direction.left && elementScrollLeftOnStart($el) || direction.right && elementScrollLeftOnEnd($el)) && (prevent = !0) : (directionWithOffset.up && elementScrollTopOnStart($el) || directionWithOffset.down && elementScrollTopOnEnd($el) || directionWithOffset.left && elementScrollLeftOnStart($el) || directionWithOffset.right && elementScrollLeftOnEnd($el)) && (prevent = !0), prevent && (parentScrollableEl ? handle(parentScrollableEl, !0) : e.cancelable && e.preventDefault())
                                } else handle(parentScrollableEl)
                            } else e.cancelable && e.preventDefault()
                        }(e.target)
                    }
                }
            }), {
                passive: !1
            }), document.addEventListener("touchend", (function (e) {
                state.scroll || (state.startTouchY = 0, state.startTouchX = 0)
            })));
            var deprecatedMethods = {
                hide: function (target) {
                    disablePageScroll(target)
                },
                show: function (target) {
                    enablePageScroll(target)
                },
                toggle: function (target) {
                    getScrollState() ? disablePageScroll() : enablePageScroll(target)
                },
                getState: function () {
                    return getScrollState()
                },
                getWidth: function () {
                    return getPageScrollBarWidth()
                },
                getCurrentWidth: function () {
                    return getCurrentPageScrollBarWidth()
                },
                setScrollableTargets: function (target) {
                    scroll_lock_addScrollableTarget(target)
                },
                setFillGapSelectors: function (selector) {
                    scroll_lock_addFillGapSelector(selector)
                },
                setFillGapTargets: function (target) {
                    scroll_lock_addFillGapTarget(target)
                },
                clearQueue: function () {
                    clearQueueScrollLocks()
                }
            },
                scrollLock = function (target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = null != arguments[i] ? arguments[i] : {},
                            ownKeys = Object.keys(source);
                        "function" == typeof Object.getOwnPropertySymbols && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter((function (sym) {
                            return Object.getOwnPropertyDescriptor(source, sym).enumerable
                        })))), ownKeys.forEach((function (key) {
                            _defineProperty(target, key, source[key])
                        }))
                    }
                    return target
                }({
                    disablePageScroll: disablePageScroll,
                    enablePageScroll: enablePageScroll,
                    getScrollState: getScrollState,
                    clearQueueScrollLocks: clearQueueScrollLocks,
                    getTargetScrollBarWidth: scroll_lock_getTargetScrollBarWidth,
                    getCurrentTargetScrollBarWidth: scroll_lock_getCurrentTargetScrollBarWidth,
                    getPageScrollBarWidth: getPageScrollBarWidth,
                    getCurrentPageScrollBarWidth: getCurrentPageScrollBarWidth,
                    addScrollableSelector: scroll_lock_addScrollableSelector,
                    removeScrollableSelector: scroll_lock_removeScrollableSelector,
                    addScrollableTarget: scroll_lock_addScrollableTarget,
                    removeScrollableTarget: scroll_lock_removeScrollableTarget,
                    addLockableSelector: scroll_lock_addLockableSelector,
                    addLockableTarget: scroll_lock_addLockableTarget,
                    addFillGapSelector: scroll_lock_addFillGapSelector,
                    removeFillGapSelector: scroll_lock_removeFillGapSelector,
                    addFillGapTarget: scroll_lock_addFillGapTarget,
                    removeFillGapTarget: scroll_lock_removeFillGapTarget,
                    setFillGapMethod: scroll_lock_setFillGapMethod,
                    refillGaps: refillGaps,
                    _state: state
                }, deprecatedMethods);
            __webpack_exports__.default = scrollLock
        }]).default
    }, module.exports = factory()
}, function (module, exports, __webpack_require__) {
    module.exports = function (e) {
        function t(o) {
            if (n[o]) return n[o].exports;
            var i = n[o] = {
                exports: {},
                id: o,
                loaded: !1
            };
            return e[o].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports
        }
        var n = {};
        return t.m = e, t.c = n, t.p = "dist/index.html", t(0)
    }([function (e, t, n) {
        "use strict";

        function o(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }
        var i = Object.assign || function (e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
            }
            return e
        },
            a = (o(n(1)), n(6)),
            u = o(a),
            s = o(n(7)),
            d = o(n(8)),
            p = o(n(9)),
            b = o(n(10)),
            y = o(n(11)),
            h = o(n(14)),
            w = [],
            k = !1,
            x = {
                offset: 120,
                delay: 0,
                easing: "ease",
                duration: 400,
                disable: !1,
                once: !1,
                startEvent: "DOMContentLoaded",
                throttleDelay: 99,
                debounceDelay: 50,
                disableMutationObserver: !1
            },
            j = function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                if (e && (k = !0), k) return w = (0, y.default)(w, x), (0, b.default)(w, x.once), w
            },
            O = function () {
                w = (0, h.default)(), j()
            };
        e.exports = {
            init: function (e) {
                x = i(x, e), w = (0, h.default)();
                var t = document.all && !window.atob;
                return function (e) {
                    return !0 === e || "mobile" === e && p.default.mobile() || "phone" === e && p.default.phone() || "tablet" === e && p.default.tablet() || "function" == typeof e && !0 === e()
                }(x.disable) || t ? void w.forEach((function (e, t) {
                    e.node.removeAttribute("data-aos"), e.node.removeAttribute("data-aos-easing"), e.node.removeAttribute("data-aos-duration"), e.node.removeAttribute("data-aos-delay")
                })) : (x.disableMutationObserver || d.default.isSupported() || (x.disableMutationObserver = !0), document.querySelector("body").setAttribute("data-aos-easing", x.easing), document.querySelector("body").setAttribute("data-aos-duration", x.duration), document.querySelector("body").setAttribute("data-aos-delay", x.delay), "DOMContentLoaded" === x.startEvent && ["complete", "interactive"].indexOf(document.readyState) > -1 ? j(!0) : "load" === x.startEvent ? window.addEventListener(x.startEvent, (function () {
                    j(!0)
                })) : document.addEventListener(x.startEvent, (function () {
                    j(!0)
                })), window.addEventListener("resize", (0, s.default)(j, x.debounceDelay, !0)), window.addEventListener("orientationchange", (0, s.default)(j, x.debounceDelay, !0)), window.addEventListener("scroll", (0, u.default)((function () {
                    (0, b.default)(w, x.once)
                }), x.throttleDelay)), x.disableMutationObserver || d.default.ready("[data-aos]", O), w)
            },
            refresh: j,
            refreshHard: O
        }
    }, function (e, t) { }, , , , , function (e, t) {
        (function (t) {
            "use strict";

            function n(e, t, n) {
                function o(t) {
                    var n = b,
                        o = v;
                    return b = v = void 0, k = t, g = e.apply(o, n)
                }

                function r(e) {
                    return k = e, h = setTimeout(f, t), M ? o(e) : g
                }

                function c(e) {
                    var n = e - w;
                    return void 0 === w || n >= t || n < 0 || S && e - k >= y
                }

                function f() {
                    var e = O();
                    return c(e) ? d(e) : void (h = setTimeout(f, function (e) {
                        var i = t - (e - w);
                        return S ? j(i, y - (e - k)) : i
                    }(e)))
                }

                function d(e) {
                    return h = void 0, _ && b ? o(e) : (b = v = void 0, g)
                }

                function m() {
                    var e = O(),
                        n = c(e);
                    if (b = arguments, v = this, w = e, n) {
                        if (void 0 === h) return r(w);
                        if (S) return h = setTimeout(f, t), o(w)
                    }
                    return void 0 === h && (h = setTimeout(f, t)), g
                }
                var b, v, y, g, h, w, k = 0,
                    M = !1,
                    S = !1,
                    _ = !0;
                if ("function" != typeof e) throw new TypeError(s);
                return t = u(t) || 0, i(n) && (M = !!n.leading, y = (S = "maxWait" in n) ? x(u(n.maxWait) || 0, t) : y, _ = "trailing" in n ? !!n.trailing : _), m.cancel = function () {
                    void 0 !== h && clearTimeout(h), k = 0, b = w = v = h = void 0
                }, m.flush = function () {
                    return void 0 === h ? g : d(O())
                }, m
            }

            function i(e) {
                var t = void 0 === e ? "undefined" : c(e);
                return !!e && ("object" == t || "function" == t)
            }

            function a(e) {
                return "symbol" == (void 0 === e ? "undefined" : c(e)) || function (e) {
                    return !!e && "object" == (void 0 === e ? "undefined" : c(e))
                }(e) && k.call(e) == d
            }

            function u(e) {
                if ("number" == typeof e) return e;
                if (a(e)) return f;
                if (i(e)) {
                    var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                    e = i(t) ? t + "" : t
                }
                if ("string" != typeof e) return 0 === e ? e : +e;
                e = e.replace(l, "");
                var n = m.test(e);
                return n || b.test(e) ? v(e.slice(2), n ? 2 : 8) : p.test(e) ? f : +e
            }
            var c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                return typeof e
            } : function (e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            },
                s = "Expected a function",
                f = NaN,
                d = "[object Symbol]",
                l = /^\s+|\s+$/g,
                p = /^[-+]0x[0-9a-f]+$/i,
                m = /^0b[01]+$/i,
                b = /^0o[0-7]+$/i,
                v = parseInt,
                y = "object" == (void 0 === t ? "undefined" : c(t)) && t && t.Object === Object && t,
                g = "object" == ("undefined" == typeof self ? "undefined" : c(self)) && self && self.Object === Object && self,
                h = y || g || Function("return this")(),
                k = Object.prototype.toString,
                x = Math.max,
                j = Math.min,
                O = function () {
                    return h.Date.now()
                };
            e.exports = function (e, t, o) {
                var r = !0,
                    a = !0;
                if ("function" != typeof e) throw new TypeError(s);
                return i(o) && (r = "leading" in o ? !!o.leading : r, a = "trailing" in o ? !!o.trailing : a), n(e, t, {
                    leading: r,
                    maxWait: t,
                    trailing: a
                })
            }
        }).call(t, function () {
            return this
        }())
    }, function (e, t) {
        (function (t) {
            "use strict";

            function o(e) {
                var t = void 0 === e ? "undefined" : u(e);
                return !!e && ("object" == t || "function" == t)
            }

            function r(e) {
                return "symbol" == (void 0 === e ? "undefined" : u(e)) || function (e) {
                    return !!e && "object" == (void 0 === e ? "undefined" : u(e))
                }(e) && w.call(e) == f
            }

            function a(e) {
                if ("number" == typeof e) return e;
                if (r(e)) return s;
                if (o(e)) {
                    var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                    e = o(t) ? t + "" : t
                }
                if ("string" != typeof e) return 0 === e ? e : +e;
                e = e.replace(d, "");
                var n = p.test(e);
                return n || m.test(e) ? b(e.slice(2), n ? 2 : 8) : l.test(e) ? s : +e
            }
            var u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                return typeof e
            } : function (e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            },
                c = "Expected a function",
                s = NaN,
                f = "[object Symbol]",
                d = /^\s+|\s+$/g,
                l = /^[-+]0x[0-9a-f]+$/i,
                p = /^0b[01]+$/i,
                m = /^0o[0-7]+$/i,
                b = parseInt,
                v = "object" == (void 0 === t ? "undefined" : u(t)) && t && t.Object === Object && t,
                y = "object" == ("undefined" == typeof self ? "undefined" : u(self)) && self && self.Object === Object && self,
                g = v || y || Function("return this")(),
                w = Object.prototype.toString,
                k = Math.max,
                x = Math.min,
                j = function () {
                    return g.Date.now()
                };
            e.exports = function (e, t, n) {
                function i(t) {
                    var n = b,
                        o = v;
                    return b = v = void 0, O = t, g = e.apply(o, n)
                }

                function r(e) {
                    return O = e, h = setTimeout(f, t), M ? i(e) : g
                }

                function s(e) {
                    var n = e - w;
                    return void 0 === w || n >= t || n < 0 || S && e - O >= y
                }

                function f() {
                    var e = j();
                    return s(e) ? d(e) : void (h = setTimeout(f, function (e) {
                        var i = t - (e - w);
                        return S ? x(i, y - (e - O)) : i
                    }(e)))
                }

                function d(e) {
                    return h = void 0, _ && b ? i(e) : (b = v = void 0, g)
                }

                function m() {
                    var e = j(),
                        n = s(e);
                    if (b = arguments, v = this, w = e, n) {
                        if (void 0 === h) return r(w);
                        if (S) return h = setTimeout(f, t), i(w)
                    }
                    return void 0 === h && (h = setTimeout(f, t)), g
                }
                var b, v, y, g, h, w, O = 0,
                    M = !1,
                    S = !1,
                    _ = !0;
                if ("function" != typeof e) throw new TypeError(c);
                return t = a(t) || 0, o(n) && (M = !!n.leading, y = (S = "maxWait" in n) ? k(a(n.maxWait) || 0, t) : y, _ = "trailing" in n ? !!n.trailing : _), m.cancel = function () {
                    void 0 !== h && clearTimeout(h), O = 0, b = w = v = h = void 0
                }, m.flush = function () {
                    return void 0 === h ? g : d(j())
                }, m
            }
        }).call(t, function () {
            return this
        }())
    }, function (e, t) {
        "use strict";

        function o() {
            return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver
        }

        function a(e) {
            e && e.forEach((function (e) {
                var t = Array.prototype.slice.call(e.addedNodes),
                    o = Array.prototype.slice.call(e.removedNodes);
                if (function n(e) {
                    var t = void 0,
                        o = void 0;
                    for (t = 0; t < e.length; t += 1) {
                        if ((o = e[t]).dataset && o.dataset.aos) return !0;
                        if (o.children && n(o.children)) return !0
                    }
                    return !1
                }(t.concat(o))) return u()
            }))
        }
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        var u = function () { };
        t.default = {
            isSupported: function () {
                return !!o()
            },
            ready: function (e, t) {
                var n = window.document,
                    r = new (o())(a);
                u = t, r.observe(n.documentElement, {
                    childList: !0,
                    subtree: !0,
                    removedNodes: !0
                })
            }
        }
    }, function (e, t) {
        "use strict";

        function o() {
            return navigator.userAgent || navigator.vendor || window.opera || ""
        }
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        var i = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var o = t[n];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                }
            }
            return function (t, n, o) {
                return n && e(t.prototype, n), o && e(t, o), t
            }
        }(),
            r = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
            a = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
            u = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i,
            c = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
            s = function () {
                function e() {
                    ! function (e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e)
                }
                return i(e, [{
                    key: "phone",
                    value: function () {
                        var e = o();
                        return !(!r.test(e) && !a.test(e.substr(0, 4)))
                    }
                }, {
                    key: "mobile",
                    value: function () {
                        var e = o();
                        return !(!u.test(e) && !c.test(e.substr(0, 4)))
                    }
                }, {
                    key: "tablet",
                    value: function () {
                        return this.mobile() && !this.phone()
                    }
                }]), e
            }();
        t.default = new s
    }, function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.default = function (e, t) {
            var o = window.pageYOffset,
                i = window.innerHeight;
            e.forEach((function (e, r) {
                ! function (e, t, n) {
                    var o = e.node.getAttribute("data-aos-once");
                    t > e.position ? e.node.classList.add("aos-animate") : void 0 !== o && ("false" === o || !n && "true" !== o) && e.node.classList.remove("aos-animate")
                }(e, i + o, t)
            }))
        }
    }, function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        var r = function (e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }(n(12));
        t.default = function (e, t) {
            return e.forEach((function (e, n) {
                e.node.classList.add("aos-init"), e.position = (0, r.default)(e.node, t.offset)
            })), e
        }
    }, function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        var r = function (e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }(n(13));
        t.default = function (e, t) {
            var n = 0,
                o = 0,
                i = window.innerHeight,
                a = {
                    offset: e.getAttribute("data-aos-offset"),
                    anchor: e.getAttribute("data-aos-anchor"),
                    anchorPlacement: e.getAttribute("data-aos-anchor-placement")
                };
            switch (a.offset && !isNaN(a.offset) && (o = parseInt(a.offset)), a.anchor && document.querySelectorAll(a.anchor) && (e = document.querySelectorAll(a.anchor)[0]), n = (0, r.default)(e).top, a.anchorPlacement) {
                case "top-bottom":
                    break;
                case "center-bottom":
                    n += e.offsetHeight / 2;
                    break;
                case "bottom-bottom":
                    n += e.offsetHeight;
                    break;
                case "top-center":
                    n += i / 2;
                    break;
                case "bottom-center":
                    n += i / 2 + e.offsetHeight;
                    break;
                case "center-center":
                    n += i / 2 + e.offsetHeight / 2;
                    break;
                case "top-top":
                    n += i;
                    break;
                case "bottom-top":
                    n += e.offsetHeight + i;
                    break;
                case "center-top":
                    n += e.offsetHeight / 2 + i
            }
            return a.anchorPlacement || a.offset || isNaN(t) || (o = t), n + o
        }
    }, function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.default = function (e) {
            for (var t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);) t += e.offsetLeft - ("BODY" != e.tagName ? e.scrollLeft : 0), n += e.offsetTop - ("BODY" != e.tagName ? e.scrollTop : 0), e = e.offsetParent;
            return {
                top: n,
                left: t
            }
        }
    }, function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.default = function (e) {
            return e = e || document.querySelectorAll("[data-aos]"), Array.prototype.map.call(e, (function (e) {
                return {
                    node: e
                }
            }))
        }
    }])
}, function (module, exports, __webpack_require__) {
    var factory;
    factory = function () {
        return function () {
            var __webpack_modules__ = {
                134: function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                    "use strict";
                    __webpack_require__.d(__webpack_exports__, {
                        default: function () {
                            return clipboard
                        }
                    });
                    var tiny_emitter = __webpack_require__(279),
                        tiny_emitter_default = __webpack_require__.n(tiny_emitter),
                        listen = __webpack_require__(370),
                        listen_default = __webpack_require__.n(listen),
                        src_select = __webpack_require__(817),
                        select_default = __webpack_require__.n(src_select);

                    function _typeof(obj) {
                        return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
                            return typeof obj
                        } : function (obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                        })(obj)
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                        }
                    }
                    var clipboard_action = function () {
                        function ClipboardAction(options) {
                            ! function (instance, Constructor) {
                                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                            }(this, ClipboardAction), this.resolveOptions(options), this.initSelection()
                        }
                        var Constructor, protoProps, staticProps;
                        return Constructor = ClipboardAction, (protoProps = [{
                            key: "resolveOptions",
                            value: function () {
                                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                this.action = options.action, this.container = options.container, this.emitter = options.emitter, this.target = options.target, this.text = options.text, this.trigger = options.trigger, this.selectedText = ""
                            }
                        }, {
                            key: "initSelection",
                            value: function () {
                                this.text ? this.selectFake() : this.target && this.selectTarget()
                            }
                        }, {
                            key: "createFakeElement",
                            value: function () {
                                var isRTL = "rtl" === document.documentElement.getAttribute("dir");
                                this.fakeElem = document.createElement("textarea"), this.fakeElem.style.fontSize = "12pt", this.fakeElem.style.border = "0", this.fakeElem.style.padding = "0", this.fakeElem.style.margin = "0", this.fakeElem.style.position = "absolute", this.fakeElem.style[isRTL ? "right" : "left"] = "-9999px";
                                var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                                return this.fakeElem.style.top = "".concat(yPosition, "px"), this.fakeElem.setAttribute("readonly", ""), this.fakeElem.value = this.text, this.fakeElem
                            }
                        }, {
                            key: "selectFake",
                            value: function () {
                                var _this = this,
                                    fakeElem = this.createFakeElement();
                                this.fakeHandlerCallback = function () {
                                    return _this.removeFake()
                                }, this.fakeHandler = this.container.addEventListener("click", this.fakeHandlerCallback) || !0, this.container.appendChild(fakeElem), this.selectedText = select_default()(fakeElem), this.copyText(), this.removeFake()
                            }
                        }, {
                            key: "removeFake",
                            value: function () {
                                this.fakeHandler && (this.container.removeEventListener("click", this.fakeHandlerCallback), this.fakeHandler = null, this.fakeHandlerCallback = null), this.fakeElem && (this.container.removeChild(this.fakeElem), this.fakeElem = null)
                            }
                        }, {
                            key: "selectTarget",
                            value: function () {
                                this.selectedText = select_default()(this.target), this.copyText()
                            }
                        }, {
                            key: "copyText",
                            value: function () {
                                var succeeded;
                                try {
                                    succeeded = document.execCommand(this.action)
                                } catch (err) {
                                    succeeded = !1
                                }
                                this.handleResult(succeeded)
                            }
                        }, {
                            key: "handleResult",
                            value: function (succeeded) {
                                this.emitter.emit(succeeded ? "success" : "error", {
                                    action: this.action,
                                    text: this.selectedText,
                                    trigger: this.trigger,
                                    clearSelection: this.clearSelection.bind(this)
                                })
                            }
                        }, {
                            key: "clearSelection",
                            value: function () {
                                this.trigger && this.trigger.focus(), document.activeElement.blur(), window.getSelection().removeAllRanges()
                            }
                        }, {
                            key: "destroy",
                            value: function () {
                                this.removeFake()
                            }
                        }, {
                            key: "action",
                            set: function () {
                                var action = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "copy";
                                if (this._action = action, "copy" !== this._action && "cut" !== this._action) throw new Error('Invalid "action" value, use either "copy" or "cut"')
                            },
                            get: function () {
                                return this._action
                            }
                        }, {
                            key: "target",
                            set: function (target) {
                                if (void 0 !== target) {
                                    if (!target || "object" !== _typeof(target) || 1 !== target.nodeType) throw new Error('Invalid "target" value, use a valid Element');
                                    if ("copy" === this.action && target.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                                    if ("cut" === this.action && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                                    this._target = target
                                }
                            },
                            get: function () {
                                return this._target
                            }
                        }]) && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), ClipboardAction
                    }();

                    function clipboard_typeof(obj) {
                        return (clipboard_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
                            return typeof obj
                        } : function (obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                        })(obj)
                    }

                    function clipboard_defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                        }
                    }

                    function _setPrototypeOf(o, p) {
                        return (_setPrototypeOf = Object.setPrototypeOf || function (o, p) {
                            return o.__proto__ = p, o
                        })(o, p)
                    }

                    function _createSuper(Derived) {
                        var hasNativeReflectConstruct = function () {
                            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                            if (Reflect.construct.sham) return !1;
                            if ("function" == typeof Proxy) return !0;
                            try {
                                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0
                            } catch (e) {
                                return !1
                            }
                        }();
                        return function () {
                            var result, Super = _getPrototypeOf(Derived);
                            if (hasNativeReflectConstruct) {
                                var NewTarget = _getPrototypeOf(this).constructor;
                                result = Reflect.construct(Super, arguments, NewTarget)
                            } else result = Super.apply(this, arguments);
                            return _possibleConstructorReturn(this, result)
                        }
                    }

                    function _possibleConstructorReturn(self, call) {
                        return !call || "object" !== clipboard_typeof(call) && "function" != typeof call ? function (self) {
                            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return self
                        }(self) : call
                    }

                    function _getPrototypeOf(o) {
                        return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) {
                            return o.__proto__ || Object.getPrototypeOf(o)
                        })(o)
                    }

                    function getAttributeValue(suffix, element) {
                        var attribute = "data-clipboard-".concat(suffix);
                        if (element.hasAttribute(attribute)) return element.getAttribute(attribute)
                    }
                    var clipboard = function (_Emitter) {
                        ! function (subClass, superClass) {
                            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
                            subClass.prototype = Object.create(superClass && superClass.prototype, {
                                constructor: {
                                    value: subClass,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), superClass && _setPrototypeOf(subClass, superClass)
                        }(Clipboard, _Emitter);
                        var Constructor, protoProps, staticProps, _super = _createSuper(Clipboard);

                        function Clipboard(trigger, options) {
                            var _this;
                            return function (instance, Constructor) {
                                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                            }(this, Clipboard), (_this = _super.call(this)).resolveOptions(options), _this.listenClick(trigger), _this
                        }
                        return Constructor = Clipboard, staticProps = [{
                            key: "isSupported",
                            value: function () {
                                var action = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ["copy", "cut"],
                                    actions = "string" == typeof action ? [action] : action,
                                    support = !!document.queryCommandSupported;
                                return actions.forEach((function (action) {
                                    support = support && !!document.queryCommandSupported(action)
                                })), support
                            }
                        }], (protoProps = [{
                            key: "resolveOptions",
                            value: function () {
                                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                this.action = "function" == typeof options.action ? options.action : this.defaultAction, this.target = "function" == typeof options.target ? options.target : this.defaultTarget, this.text = "function" == typeof options.text ? options.text : this.defaultText, this.container = "object" === clipboard_typeof(options.container) ? options.container : document.body
                            }
                        }, {
                            key: "listenClick",
                            value: function (trigger) {
                                var _this2 = this;
                                this.listener = listen_default()(trigger, "click", (function (e) {
                                    return _this2.onClick(e)
                                }))
                            }
                        }, {
                            key: "onClick",
                            value: function (e) {
                                var trigger = e.delegateTarget || e.currentTarget;
                                this.clipboardAction && (this.clipboardAction = null), this.clipboardAction = new clipboard_action({
                                    action: this.action(trigger),
                                    target: this.target(trigger),
                                    text: this.text(trigger),
                                    container: this.container,
                                    trigger: trigger,
                                    emitter: this
                                })
                            }
                        }, {
                            key: "defaultAction",
                            value: function (trigger) {
                                return getAttributeValue("action", trigger)
                            }
                        }, {
                            key: "defaultTarget",
                            value: function (trigger) {
                                var selector = getAttributeValue("target", trigger);
                                if (selector) return document.querySelector(selector)
                            }
                        }, {
                            key: "defaultText",
                            value: function (trigger) {
                                return getAttributeValue("text", trigger)
                            }
                        }, {
                            key: "destroy",
                            value: function () {
                                this.listener.destroy(), this.clipboardAction && (this.clipboardAction.destroy(), this.clipboardAction = null)
                            }
                        }]) && clipboard_defineProperties(Constructor.prototype, protoProps), staticProps && clipboard_defineProperties(Constructor, staticProps), Clipboard
                    }(tiny_emitter_default())
                },
                828: function (module) {
                    if ("undefined" != typeof Element && !Element.prototype.matches) {
                        var proto = Element.prototype;
                        proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector
                    }
                    module.exports = function (element, selector) {
                        for (; element && 9 !== element.nodeType;) {
                            if ("function" == typeof element.matches && element.matches(selector)) return element;
                            element = element.parentNode
                        }
                    }
                },
                438: function (module, __unused_webpack_exports, __webpack_require__) {
                    var closest = __webpack_require__(828);

                    function _delegate(element, selector, type, callback, useCapture) {
                        var listenerFn = listener.apply(this, arguments);
                        return element.addEventListener(type, listenerFn, useCapture), {
                            destroy: function () {
                                element.removeEventListener(type, listenerFn, useCapture)
                            }
                        }
                    }

                    function listener(element, selector, type, callback) {
                        return function (e) {
                            e.delegateTarget = closest(e.target, selector), e.delegateTarget && callback.call(element, e)
                        }
                    }
                    module.exports = function (elements, selector, type, callback, useCapture) {
                        return "function" == typeof elements.addEventListener ? _delegate.apply(null, arguments) : "function" == typeof type ? _delegate.bind(null, document).apply(null, arguments) : ("string" == typeof elements && (elements = document.querySelectorAll(elements)), Array.prototype.map.call(elements, (function (element) {
                            return _delegate(element, selector, type, callback, useCapture)
                        })))
                    }
                },
                879: function (__unused_webpack_module, exports) {
                    exports.node = function (value) {
                        return void 0 !== value && value instanceof HTMLElement && 1 === value.nodeType
                    }, exports.nodeList = function (value) {
                        var type = Object.prototype.toString.call(value);
                        return void 0 !== value && ("[object NodeList]" === type || "[object HTMLCollection]" === type) && "length" in value && (0 === value.length || exports.node(value[0]))
                    }, exports.string = function (value) {
                        return "string" == typeof value || value instanceof String
                    }, exports.fn = function (value) {
                        return "[object Function]" === Object.prototype.toString.call(value)
                    }
                },
                370: function (module, __unused_webpack_exports, __webpack_require__) {
                    var is = __webpack_require__(879),
                        delegate = __webpack_require__(438);
                    module.exports = function (target, type, callback) {
                        if (!target && !type && !callback) throw new Error("Missing required arguments");
                        if (!is.string(type)) throw new TypeError("Second argument must be a String");
                        if (!is.fn(callback)) throw new TypeError("Third argument must be a Function");
                        if (is.node(target)) return function (node, type, callback) {
                            return node.addEventListener(type, callback), {
                                destroy: function () {
                                    node.removeEventListener(type, callback)
                                }
                            }
                        }(target, type, callback);
                        if (is.nodeList(target)) return function (nodeList, type, callback) {
                            return Array.prototype.forEach.call(nodeList, (function (node) {
                                node.addEventListener(type, callback)
                            })), {
                                destroy: function () {
                                    Array.prototype.forEach.call(nodeList, (function (node) {
                                        node.removeEventListener(type, callback)
                                    }))
                                }
                            }
                        }(target, type, callback);
                        if (is.string(target)) return function (selector, type, callback) {
                            return delegate(document.body, selector, type, callback)
                        }(target, type, callback);
                        throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList")
                    }
                },
                817: function (module) {
                    module.exports = function (element) {
                        var selectedText;
                        if ("SELECT" === element.nodeName) element.focus(), selectedText = element.value;
                        else if ("INPUT" === element.nodeName || "TEXTAREA" === element.nodeName) {
                            var isReadOnly = element.hasAttribute("readonly");
                            isReadOnly || element.setAttribute("readonly", ""), element.select(), element.setSelectionRange(0, element.value.length), isReadOnly || element.removeAttribute("readonly"), selectedText = element.value
                        } else {
                            element.hasAttribute("contenteditable") && element.focus();
                            var selection = window.getSelection(),
                                range = document.createRange();
                            range.selectNodeContents(element), selection.removeAllRanges(), selection.addRange(range), selectedText = selection.toString()
                        }
                        return selectedText
                    }
                },
                279: function (module) {
                    function E() { }
                    E.prototype = {
                        on: function (name, callback, ctx) {
                            var e = this.e || (this.e = {});
                            return (e[name] || (e[name] = [])).push({
                                fn: callback,
                                ctx: ctx
                            }), this
                        },
                        once: function (name, callback, ctx) {
                            var self = this;

                            function listener() {
                                self.off(name, listener), callback.apply(ctx, arguments)
                            }
                            return listener._ = callback, this.on(name, listener, ctx)
                        },
                        emit: function (name) {
                            for (var data = [].slice.call(arguments, 1), evtArr = ((this.e || (this.e = {}))[name] || []).slice(), i = 0, len = evtArr.length; i < len; i++) evtArr[i].fn.apply(evtArr[i].ctx, data);
                            return this
                        },
                        off: function (name, callback) {
                            var e = this.e || (this.e = {}),
                                evts = e[name],
                                liveEvents = [];
                            if (evts && callback)
                                for (var i = 0, len = evts.length; i < len; i++) evts[i].fn !== callback && evts[i].fn._ !== callback && liveEvents.push(evts[i]);
                            return liveEvents.length ? e[name] = liveEvents : delete e[name], this
                        }
                    }, module.exports = E, module.exports.TinyEmitter = E
                }
            },
                __webpack_module_cache__ = {};

            function __webpack_require__(moduleId) {
                if (__webpack_module_cache__[moduleId]) return __webpack_module_cache__[moduleId].exports;
                var module = __webpack_module_cache__[moduleId] = {
                    exports: {}
                };
                return __webpack_modules__[moduleId](module, module.exports, __webpack_require__), module.exports
            }
            return __webpack_require__.n = function (module) {
                var getter = module && module.__esModule ? function () {
                    return module.default
                } : function () {
                    return module
                };
                return __webpack_require__.d(getter, {
                    a: getter
                }), getter
            }, __webpack_require__.d = function (exports, definition) {
                for (var key in definition) __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: definition[key]
                })
            }, __webpack_require__.o = function (obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop)
            }, __webpack_require__(134)
        }().default
    }, module.exports = factory()
}, , , function (module, exports) {
    class LiteYTEmbed extends HTMLElement {
        connectedCallback() {
            this.videoId = this.getAttribute("videoid");
            let playBtnEl = this.querySelector(".lty-playbtn");
            if (this.playLabel = playBtnEl && playBtnEl.textContent.trim() || this.getAttribute("playlabel") || "Play", this.style.backgroundImage || (this.posterUrl = `https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg`, LiteYTEmbed.addPrefetch("preload", this.posterUrl, "image"), this.style.backgroundImage = `url("${this.posterUrl}")`), playBtnEl || (playBtnEl = document.createElement("button"), playBtnEl.type = "button", playBtnEl.classList.add("lty-playbtn"), this.append(playBtnEl)), !playBtnEl.textContent) {
                const playBtnLabelEl = document.createElement("span");
                playBtnLabelEl.className = "lyt-visually-hidden", playBtnLabelEl.textContent = this.playLabel, playBtnEl.append(playBtnLabelEl)
            }
            this.addEventListener("pointerover", LiteYTEmbed.warmConnections, {
                once: !0
            }), this.addEventListener("click", e => this.addIframe())
        }
        static addPrefetch(kind, url, as) {
            const linkEl = document.createElement("link");
            linkEl.rel = kind, linkEl.href = url, as && (linkEl.as = as), document.head.append(linkEl)
        }
        static warmConnections() {
            LiteYTEmbed.preconnected || (LiteYTEmbed.addPrefetch("preconnect", "https://www.youtube-nocookie.com"), LiteYTEmbed.addPrefetch("preconnect", "https://www.google.com"), LiteYTEmbed.addPrefetch("preconnect", "https://googleads.g.doubleclick.net"), LiteYTEmbed.addPrefetch("preconnect", "https://static.doubleclick.net"), LiteYTEmbed.preconnected = !0)
        }
        addIframe() {
            const params = new URLSearchParams(this.getAttribute("params") || []);
            params.append("autoplay", "1");
            const iframeEl = document.createElement("iframe");
            iframeEl.width = 560, iframeEl.height = 315, iframeEl.title = this.playLabel, iframeEl.allow = "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture", iframeEl.allowFullscreen = !0, iframeEl.src = `https://www.youtube-nocookie.com/embed/${encodeURIComponent(this.videoId)}?${params.toString()}`, this.append(iframeEl), this.classList.add("lyt-activated"), this.querySelector("iframe").focus()
        }
    }
    customElements.define("lite-youtube", LiteYTEmbed)
}, function (module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    var aos = __webpack_require__(1),
        aos_default = __webpack_require__.n(aos),
        scroll_lock = __webpack_require__(0);
    document.querySelector(".header__hamburger").addEventListener("click", (function () {
        document.querySelector(".header__nav").classList.toggle("header__nav--open"), document.querySelector(".header__nav").classList.contains("header__nav--open") ? Object(scroll_lock.disablePageScroll)() : Object(scroll_lock.enablePageScroll)()
    })), document.querySelector(".header__nav-close").addEventListener("click", (function () {
        document.querySelector(".header__nav").classList.remove("header__nav--open"), document.querySelector(".header__nav").classList.contains("header__nav--open") ? Object(scroll_lock.disablePageScroll)() : Object(scroll_lock.enablePageScroll)()
    }));
    // document.querySelector("#tokenomicsmenu").addEventListener("click", (function () {

    //     //document.getElementById('token').scrollIntoView(true);

    //     document.querySelector(".header__nav").classList.remove("header__nav--open"), document.querySelector(".header__nav").classList.contains("header__nav--open") ? Object(scroll_lock.disablePageScroll)() : Object(scroll_lock.enablePageScroll)()
    // })), document.querySelector("roadmapmenu").addEventListener("click", (function () {

    //     //document.getElementById('roadmap').scrollIntoView(true);

    //     document.querySelector(".header__nav").classList.remove("header__nav--open"), document.querySelector(".header__nav").classList.contains("header__nav--open") ? Object(scroll_lock.disablePageScroll)() : Object(scroll_lock.enablePageScroll)()
    // })), document.querySelector("#buymenu").addEventListener("click", (function () {

    //     //document.getElementById('buy').scrollIntoView(true);

    //     document.querySelector(".header__nav").classList.remove("header__nav--open"), document.querySelector(".header__nav").classList.contains("header__nav--open") ? Object(scroll_lock.disablePageScroll)() : Object(scroll_lock.enablePageScroll)()
    // }));
    
    __webpack_require__(5);
    const requestAnimFrame = "undefined" == typeof window ? function (callback) {
        return callback()
    } : window.requestAnimationFrame;

    function throttled(fn, thisArg, updateFn) {
        const updateArgs = updateFn || (args => Array.prototype.slice.call(args));
        let ticking = !1,
            args = [];
        return function (...rest) {
            args = updateArgs(rest), ticking || (ticking = !0, requestAnimFrame.call(window, () => {
                ticking = !1, fn.apply(thisArg, args)
            }))
        }
    }
    const _toLeftRightCenter = align => "start" === align ? "left" : "end" === align ? "right" : "center",
        _alignStartEnd = (align, start, end) => "start" === align ? start : "end" === align ? end : (start + end) / 2;

    function noop() { }
    const uid = function () {
        let id = 0;
        return function () {
            return id++
        }
    }();

    function isNullOrUndef(value) {
        return null == value
    }

    function isArray(value) {
        if (Array.isArray && Array.isArray(value)) return !0;
        const type = Object.prototype.toString.call(value);
        return "[object" === type.substr(0, 7) && "Array]" === type.substr(-6)
    }

    function isObject(value) {
        return null !== value && "[object Object]" === Object.prototype.toString.call(value)
    }
    const isNumberFinite = value => ("number" == typeof value || value instanceof Number) && isFinite(+value);

    function finiteOrDefault(value, defaultValue) {
        return isNumberFinite(value) ? value : defaultValue
    }

    function valueOrDefault(value, defaultValue) {
        return void 0 === value ? defaultValue : value
    }
    const toDimension = (value, dimension) => "string" == typeof value && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;

    function helpers_segment_callback(fn, args, thisArg) {
        if (fn && "function" == typeof fn.call) return fn.apply(thisArg, args)
    }

    function each(loopable, fn, thisArg, reverse) {
        let i, len, keys;
        if (isArray(loopable))
            if (len = loopable.length, reverse)
                for (i = len - 1; i >= 0; i--) fn.call(thisArg, loopable[i], i);
            else
                for (i = 0; i < len; i++) fn.call(thisArg, loopable[i], i);
        else if (isObject(loopable))
            for (keys = Object.keys(loopable), len = keys.length, i = 0; i < len; i++) fn.call(thisArg, loopable[keys[i]], keys[i])
    }

    function _elementsEqual(a0, a1) {
        let i, ilen, v0, v1;
        if (!a0 || !a1 || a0.length !== a1.length) return !1;
        for (i = 0, ilen = a0.length; i < ilen; ++i)
            if (v0 = a0[i], v1 = a1[i], v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) return !1;
        return !0
    }

    function clone$1(source) {
        if (isArray(source)) return source.map(clone$1);
        if (isObject(source)) {
            const target = Object.create(null),
                keys = Object.keys(source),
                klen = keys.length;
            let k = 0;
            for (; k < klen; ++k) target[keys[k]] = clone$1(source[keys[k]]);
            return target
        }
        return source
    }

    function isValidKey(key) {
        return -1 === ["__proto__", "prototype", "constructor"].indexOf(key)
    }

    function _merger(key, target, source, options) {
        if (!isValidKey(key)) return;
        const tval = target[key],
            sval = source[key];
        isObject(tval) && isObject(sval) ? merge(tval, sval, options) : target[key] = clone$1(sval)
    }

    function merge(target, source, options) {
        const sources = isArray(source) ? source : [source],
            ilen = sources.length;
        if (!isObject(target)) return target;
        const merger = (options = options || {}).merger || _merger;
        for (let i = 0; i < ilen; ++i) {
            if (!isObject(source = sources[i])) continue;
            const keys = Object.keys(source);
            for (let k = 0, klen = keys.length; k < klen; ++k) merger(keys[k], target, source, options)
        }
        return target
    }

    function mergeIf(target, source) {
        return merge(target, source, {
            merger: _mergerIf
        })
    }

    function _mergerIf(key, target, source) {
        if (!isValidKey(key)) return;
        const tval = target[key],
            sval = source[key];
        isObject(tval) && isObject(sval) ? mergeIf(tval, sval) : Object.prototype.hasOwnProperty.call(target, key) || (target[key] = clone$1(sval))
    }

    function indexOfDotOrLength(key, start) {
        const idx = key.indexOf(".", start);
        return -1 === idx ? key.length : idx
    }

    function resolveObjectKey(obj, key) {
        if ("" === key) return obj;
        let pos = 0,
            idx = indexOfDotOrLength(key, pos);
        for (; obj && idx > pos;) obj = obj[key.substr(pos, idx - pos)], pos = idx + 1, idx = indexOfDotOrLength(key, pos);
        return obj
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1)
    }
    const defined = value => void 0 !== value,
        isFunction = value => "function" == typeof value,
        PI = Math.PI,
        TAU = 2 * PI,
        PITAU = TAU + PI,
        INFINITY = Number.POSITIVE_INFINITY,
        RAD_PER_DEG = PI / 180,
        HALF_PI = PI / 2,
        QUARTER_PI = PI / 4,
        TWO_THIRDS_PI = 2 * PI / 3,
        log10 = Math.log10,
        sign = Math.sign;

    function niceNum(range) {
        const roundedRange = Math.round(range);
        range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
        const niceRange = Math.pow(10, Math.floor(log10(range))),
            fraction = range / niceRange;
        return (fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10) * niceRange
    }

    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n)
    }

    function almostEquals(x, y, epsilon) {
        return Math.abs(x - y) < epsilon
    }

    function _setMinAndMaxByKey(array, target, property) {
        let i, ilen, value;
        for (i = 0, ilen = array.length; i < ilen; i++) value = array[i][property], isNaN(value) || (target.min = Math.min(target.min, value), target.max = Math.max(target.max, value))
    }

    function toRadians(degrees) {
        return degrees * (PI / 180)
    }

    function toDegrees(radians) {
        return radians * (180 / PI)
    }

    function _decimalPlaces(x) {
        if (!isNumberFinite(x)) return;
        let e = 1,
            p = 0;
        for (; Math.round(x * e) / e !== x;) e *= 10, p++;
        return p
    }

    function distanceBetweenPoints(pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2))
    }

    function _angleDiff(a, b) {
        return (a - b + PITAU) % TAU - PI
    }

    function _normalizeAngle(a) {
        return (a % TAU + TAU) % TAU
    }

    function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
        const a = _normalizeAngle(angle),
            s = _normalizeAngle(start),
            e = _normalizeAngle(end),
            angleToStart = _normalizeAngle(s - a),
            angleToEnd = _normalizeAngle(e - a),
            startToAngle = _normalizeAngle(a - s),
            endToAngle = _normalizeAngle(a - e);
        return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle
    }

    function _limitValue(value, min, max) {
        return Math.max(min, Math.min(max, value))
    }
    const atEdge = t => 0 === t || 1 === t,
        elasticIn = (t, s, p) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p),
        elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1,
        effects = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => -t * (t - 2),
            easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (t -= 1) * t * t + 1,
            easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
            easeInQuart: t => t * t * t * t,
            easeOutQuart: t => -((t -= 1) * t * t * t - 1),
            easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
            easeInQuint: t => t * t * t * t * t,
            easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
            easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
            easeInSine: t => 1 - Math.cos(t * HALF_PI),
            easeOutSine: t => Math.sin(t * HALF_PI),
            easeInOutSine: t => -.5 * (Math.cos(PI * t) - 1),
            easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),
            easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t),
            easeInOutExpo: t => atEdge(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
            easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
            easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
            easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
            easeInElastic: t => atEdge(t) ? t : elasticIn(t, .075, .3),
            easeOutElastic: t => atEdge(t) ? t : elasticOut(t, .075, .3),
            easeInOutElastic(t) {
                const s = .1125;
                return atEdge(t) ? t : t < .5 ? .5 * elasticIn(2 * t, s, .45) : .5 + .5 * elasticOut(2 * t - 1, s, .45)
            },
            easeInBack(t) {
                const s = 1.70158;
                return t * t * ((s + 1) * t - s)
            },
            easeOutBack(t) {
                const s = 1.70158;
                return (t -= 1) * t * ((s + 1) * t + s) + 1
            },
            easeInOutBack(t) {
                let s = 1.70158;
                return (t /= .5) < 1 ? t * t * ((1 + (s *= 1.525)) * t - s) * .5 : .5 * ((t -= 2) * t * ((1 + (s *= 1.525)) * t + s) + 2)
            },
            easeInBounce: t => 1 - effects.easeOutBounce(1 - t),
            easeOutBounce(t) {
                const m = 7.5625,
                    d = 2.75;
                return t < 1 / d ? m * t * t : t < 2 / d ? m * (t -= 1.5 / d) * t + .75 : t < 2.5 / d ? m * (t -= 2.25 / d) * t + .9375 : m * (t -= 2.625 / d) * t + .984375
            },
            easeInOutBounce: t => t < .5 ? .5 * effects.easeInBounce(2 * t) : .5 * effects.easeOutBounce(2 * t - 1) + .5
        },
        map = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            A: 10,
            B: 11,
            C: 12,
            D: 13,
            E: 14,
            F: 15,
            a: 10,
            b: 11,
            c: 12,
            d: 13,
            e: 14,
            f: 15
        },
        hex = "0123456789ABCDEF",
        h1 = b => hex[15 & b],
        h2 = b => hex[(240 & b) >> 4] + hex[15 & b],
        eq = b => (240 & b) >> 4 == (15 & b);

    function hexString(v) {
        var f = function (v) {
            return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a)
        }(v) ? h1 : h2;
        return v ? "#" + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : "") : v
    }

    function helpers_segment_round(v) {
        return v + .5 | 0
    }
    const lim = (v, l, h) => Math.max(Math.min(v, h), l);

    function p2b(v) {
        return lim(helpers_segment_round(2.55 * v), 0, 255)
    }

    function n2b(v) {
        return lim(helpers_segment_round(255 * v), 0, 255)
    }

    function b2n(v) {
        return lim(helpers_segment_round(v / 2.55) / 100, 0, 1)
    }

    function n2p(v) {
        return lim(helpers_segment_round(100 * v), 0, 100)
    }
    const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

    function hsl2rgbn(h, s, l) {
        const a = s * Math.min(l, 1 - l),
            f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return [f(0), f(8), f(4)]
    }

    function hsv2rgbn(h, s, v) {
        const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5), f(3), f(1)]
    }

    function hwb2rgbn(h, w, b) {
        const rgb = hsl2rgbn(h, 1, .5);
        let i;
        for (w + b > 1 && (i = 1 / (w + b), w *= i, b *= i), i = 0; i < 3; i++) rgb[i] *= 1 - w - b, rgb[i] += w;
        return rgb
    }

    function rgb2hsl(v) {
        const r = v.r / 255,
            g = v.g / 255,
            b = v.b / 255,
            max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            l = (max + min) / 2;
        let h, s, d;
        return max !== min && (d = max - min, s = l > .5 ? d / (2 - max - min) : d / (max + min), h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4, h = 60 * h + .5), [0 | h, s || 0, l]
    }

    function calln(f, a, b, c) {
        return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b)
    }

    function hsl2rgb(h, s, l) {
        return calln(hsl2rgbn, h, s, l)
    }

    function hue(h) {
        return (h % 360 + 360) % 360
    }

    function hueParse(str) {
        const m = HUE_RE.exec(str);
        let v, a = 255;
        if (!m) return;
        m[5] !== v && (a = m[6] ? p2b(+m[5]) : n2b(+m[5]));
        const h = hue(+m[2]),
            p1 = +m[3] / 100,
            p2 = +m[4] / 100;
        return v = "hwb" === m[1] ? function (h, w, b) {
            return calln(hwb2rgbn, h, w, b)
        }(h, p1, p2) : "hsv" === m[1] ? function (h, s, v) {
            return calln(hsv2rgbn, h, s, v)
        }(h, p1, p2) : hsl2rgb(h, p1, p2), {
            r: v[0],
            g: v[1],
            b: v[2],
            a: a
        }
    }
    const map$1 = {
        x: "dark",
        Z: "light",
        Y: "re",
        X: "blu",
        W: "gr",
        V: "medium",
        U: "slate",
        A: "ee",
        T: "ol",
        S: "or",
        B: "ra",
        C: "lateg",
        D: "ights",
        R: "in",
        Q: "turquois",
        E: "hi",
        P: "ro",
        O: "al",
        N: "le",
        M: "de",
        L: "yello",
        F: "en",
        K: "ch",
        G: "arks",
        H: "ea",
        I: "ightg",
        J: "wh"
    },
        helpers_segment_names = {
            OiceXe: "f0f8ff",
            antiquewEte: "faebd7",
            aqua: "ffff",
            aquamarRe: "7fffd4",
            azuY: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "0",
            blanKedOmond: "ffebcd",
            Xe: "ff",
            XeviTet: "8a2be2",
            bPwn: "a52a2a",
            burlywood: "deb887",
            caMtXe: "5f9ea0",
            KartYuse: "7fff00",
            KocTate: "d2691e",
            cSO: "ff7f50",
            cSnflowerXe: "6495ed",
            cSnsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "ffff",
            xXe: "8b",
            xcyan: "8b8b",
            xgTMnPd: "b8860b",
            xWay: "a9a9a9",
            xgYF: "6400",
            xgYy: "a9a9a9",
            xkhaki: "bdb76b",
            xmagFta: "8b008b",
            xTivegYF: "556b2f",
            xSange: "ff8c00",
            xScEd: "9932cc",
            xYd: "8b0000",
            xsOmon: "e9967a",
            xsHgYF: "8fbc8f",
            xUXe: "483d8b",
            xUWay: "2f4f4f",
            xUgYy: "2f4f4f",
            xQe: "ced1",
            xviTet: "9400d3",
            dAppRk: "ff1493",
            dApskyXe: "bfff",
            dimWay: "696969",
            dimgYy: "696969",
            dodgerXe: "1e90ff",
            fiYbrick: "b22222",
            flSOwEte: "fffaf0",
            foYstWAn: "228b22",
            fuKsia: "ff00ff",
            gaRsbSo: "dcdcdc",
            ghostwEte: "f8f8ff",
            gTd: "ffd700",
            gTMnPd: "daa520",
            Way: "808080",
            gYF: "8000",
            gYFLw: "adff2f",
            gYy: "808080",
            honeyMw: "f0fff0",
            hotpRk: "ff69b4",
            RdianYd: "cd5c5c",
            Rdigo: "4b0082",
            ivSy: "fffff0",
            khaki: "f0e68c",
            lavFMr: "e6e6fa",
            lavFMrXsh: "fff0f5",
            lawngYF: "7cfc00",
            NmoncEffon: "fffacd",
            ZXe: "add8e6",
            ZcSO: "f08080",
            Zcyan: "e0ffff",
            ZgTMnPdLw: "fafad2",
            ZWay: "d3d3d3",
            ZgYF: "90ee90",
            ZgYy: "d3d3d3",
            ZpRk: "ffb6c1",
            ZsOmon: "ffa07a",
            ZsHgYF: "20b2aa",
            ZskyXe: "87cefa",
            ZUWay: "778899",
            ZUgYy: "778899",
            ZstAlXe: "b0c4de",
            ZLw: "ffffe0",
            lime: "ff00",
            limegYF: "32cd32",
            lRF: "faf0e6",
            magFta: "ff00ff",
            maPon: "800000",
            VaquamarRe: "66cdaa",
            VXe: "cd",
            VScEd: "ba55d3",
            VpurpN: "9370db",
            VsHgYF: "3cb371",
            VUXe: "7b68ee",
            VsprRggYF: "fa9a",
            VQe: "48d1cc",
            VviTetYd: "c71585",
            midnightXe: "191970",
            mRtcYam: "f5fffa",
            mistyPse: "ffe4e1",
            moccasR: "ffe4b5",
            navajowEte: "ffdead",
            navy: "80",
            Tdlace: "fdf5e6",
            Tive: "808000",
            TivedBb: "6b8e23",
            Sange: "ffa500",
            SangeYd: "ff4500",
            ScEd: "da70d6",
            pOegTMnPd: "eee8aa",
            pOegYF: "98fb98",
            pOeQe: "afeeee",
            pOeviTetYd: "db7093",
            papayawEp: "ffefd5",
            pHKpuff: "ffdab9",
            peru: "cd853f",
            pRk: "ffc0cb",
            plum: "dda0dd",
            powMrXe: "b0e0e6",
            purpN: "800080",
            YbeccapurpN: "663399",
            Yd: "ff0000",
            Psybrown: "bc8f8f",
            PyOXe: "4169e1",
            saddNbPwn: "8b4513",
            sOmon: "fa8072",
            sandybPwn: "f4a460",
            sHgYF: "2e8b57",
            sHshell: "fff5ee",
            siFna: "a0522d",
            silver: "c0c0c0",
            skyXe: "87ceeb",
            UXe: "6a5acd",
            UWay: "708090",
            UgYy: "708090",
            snow: "fffafa",
            sprRggYF: "ff7f",
            stAlXe: "4682b4",
            tan: "d2b48c",
            teO: "8080",
            tEstN: "d8bfd8",
            tomato: "ff6347",
            Qe: "40e0d0",
            viTet: "ee82ee",
            JHt: "f5deb3",
            wEte: "ffffff",
            wEtesmoke: "f5f5f5",
            Lw: "ffff00",
            LwgYF: "9acd32"
        };
    let names$1;

    function nameParse(str) {
        names$1 || (names$1 = function () {
            const unpacked = {},
                keys = Object.keys(helpers_segment_names),
                tkeys = Object.keys(map$1);
            let i, j, k, ok, nk;
            for (i = 0; i < keys.length; i++) {
                for (ok = nk = keys[i], j = 0; j < tkeys.length; j++) k = tkeys[j], nk = nk.replace(k, map$1[k]);
                k = parseInt(helpers_segment_names[ok], 16), unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, 255 & k]
            }
            return unpacked
        }(), names$1.transparent = [0, 0, 0, 0]);
        const a = names$1[str.toLowerCase()];
        return a && {
            r: a[0],
            g: a[1],
            b: a[2],
            a: 4 === a.length ? a[3] : 255
        }
    }

    function modHSL(v, i, ratio) {
        if (v) {
            let tmp = rgb2hsl(v);
            tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, 0 === i ? 360 : 1)), tmp = hsl2rgb(tmp), v.r = tmp[0], v.g = tmp[1], v.b = tmp[2]
        }
    }

    function clone(v, proto) {
        return v ? Object.assign(proto || {}, v) : v
    }

    function fromObject(input) {
        var v = {
            r: 0,
            g: 0,
            b: 0,
            a: 255
        };
        return Array.isArray(input) ? input.length >= 3 && (v = {
            r: input[0],
            g: input[1],
            b: input[2],
            a: 255
        }, input.length > 3 && (v.a = n2b(input[3]))) : (v = clone(input, {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        })).a = n2b(v.a), v
    }

    function functionParse(str) {
        return "r" === str.charAt(0) ? function (str) {
            const m = RGB_RE.exec(str);
            let r, g, b, a = 255;
            if (m) {
                if (m[7] !== r) {
                    const v = +m[7];
                    a = 255 & (m[8] ? p2b(v) : 255 * v)
                }
                return r = +m[1], g = +m[3], b = +m[5], r = 255 & (m[2] ? p2b(r) : r), g = 255 & (m[4] ? p2b(g) : g), b = 255 & (m[6] ? p2b(b) : b), {
                    r: r,
                    g: g,
                    b: b,
                    a: a
                }
            }
        }(str) : hueParse(str)
    }
    class Color {
        constructor(input) {
            if (input instanceof Color) return input;
            const type = typeof input;
            let v;
            var str, ret, len;
            "object" === type ? v = fromObject(input) : "string" === type && (len = (str = input).length, "#" === str[0] && (4 === len || 5 === len ? ret = {
                r: 255 & 17 * map[str[1]],
                g: 255 & 17 * map[str[2]],
                b: 255 & 17 * map[str[3]],
                a: 5 === len ? 17 * map[str[4]] : 255
            } : 7 !== len && 9 !== len || (ret = {
                r: map[str[1]] << 4 | map[str[2]],
                g: map[str[3]] << 4 | map[str[4]],
                b: map[str[5]] << 4 | map[str[6]],
                a: 9 === len ? map[str[7]] << 4 | map[str[8]] : 255
            })), v = ret || nameParse(input) || functionParse(input)), this._rgb = v, this._valid = !!v
        }
        get valid() {
            return this._valid
        }
        get rgb() {
            var v = clone(this._rgb);
            return v && (v.a = b2n(v.a)), v
        }
        set rgb(obj) {
            this._rgb = fromObject(obj)
        }
        rgbString() {
            return this._valid ? (v = this._rgb) && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`) : this._rgb;
            var v
        }
        hexString() {
            return this._valid ? hexString(this._rgb) : this._rgb
        }
        hslString() {
            return this._valid ? function (v) {
                if (!v) return;
                const a = rgb2hsl(v),
                    h = a[0],
                    s = n2p(a[1]),
                    l = n2p(a[2]);
                return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`
            }(this._rgb) : this._rgb
        }
        mix(color, weight) {
            const me = this;
            if (color) {
                const c1 = me.rgb,
                    c2 = color.rgb;
                let w2;
                const p = weight === w2 ? .5 : weight,
                    w = 2 * p - 1,
                    a = c1.a - c2.a,
                    w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
                w2 = 1 - w1, c1.r = 255 & w1 * c1.r + w2 * c2.r + .5, c1.g = 255 & w1 * c1.g + w2 * c2.g + .5, c1.b = 255 & w1 * c1.b + w2 * c2.b + .5, c1.a = p * c1.a + (1 - p) * c2.a, me.rgb = c1
            }
            return me
        }
        clone() {
            return new Color(this.rgb)
        }
        alpha(a) {
            return this._rgb.a = n2b(a), this
        }
        clearer(ratio) {
            return this._rgb.a *= 1 - ratio, this
        }
        greyscale() {
            const rgb = this._rgb,
                val = helpers_segment_round(.3 * rgb.r + .59 * rgb.g + .11 * rgb.b);
            return rgb.r = rgb.g = rgb.b = val, this
        }
        opaquer(ratio) {
            return this._rgb.a *= 1 + ratio, this
        }
        negate() {
            const v = this._rgb;
            return v.r = 255 - v.r, v.g = 255 - v.g, v.b = 255 - v.b, this
        }
        lighten(ratio) {
            return modHSL(this._rgb, 2, ratio), this
        }
        darken(ratio) {
            return modHSL(this._rgb, 2, -ratio), this
        }
        saturate(ratio) {
            return modHSL(this._rgb, 1, ratio), this
        }
        desaturate(ratio) {
            return modHSL(this._rgb, 1, -ratio), this
        }
        rotate(deg) {
            return function (v, deg) {
                var h = rgb2hsl(v);
                h[0] = hue(h[0] + deg), h = hsl2rgb(h), v.r = h[0], v.g = h[1], v.b = h[2]
            }(this._rgb, deg), this
        }
    }

    function index_esm(input) {
        return new Color(input)
    }
    const isPatternOrGradient = value => value instanceof CanvasGradient || value instanceof CanvasPattern;

    function helpers_segment_color(value) {
        return isPatternOrGradient(value) ? value : index_esm(value)
    }

    function getHoverColor(value) {
        return isPatternOrGradient(value) ? value : index_esm(value).saturate(.5).darken(.1).hexString()
    }
    const overrides = Object.create(null),
        helpers_segment_descriptors = Object.create(null);

    function getScope$1(node, key) {
        if (!key) return node;
        const keys = key.split(".");
        for (let i = 0, n = keys.length; i < n; ++i) {
            const k = keys[i];
            node = node[k] || (node[k] = Object.create(null))
        }
        return node
    }

    function helpers_segment_set(root, scope, values) {
        return "string" == typeof scope ? merge(getScope$1(root, scope), values) : merge(getScope$1(root, ""), scope)
    }
    var defaults = new class {
        constructor(_descriptors) {
            this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = context => context.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
                family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                size: 12,
                style: "normal",
                lineHeight: 1.2,
                weight: null
            }, this.hover = {}, this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor), this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor), this.hoverColor = (ctx, options) => getHoverColor(options.color), this.indexAxis = "x", this.interaction = {
                mode: "nearest",
                intersect: !0
            }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.describe(_descriptors)
        }
        set(scope, values) {
            return helpers_segment_set(this, scope, values)
        }
        get(scope) {
            return getScope$1(this, scope)
        }
        describe(scope, values) {
            return helpers_segment_set(helpers_segment_descriptors, scope, values)
        }
        override(scope, values) {
            return helpers_segment_set(overrides, scope, values)
        }
        route(scope, name, targetScope, targetName) {
            const scopeObject = getScope$1(this, scope),
                targetScopeObject = getScope$1(this, targetScope),
                privateName = "_" + name;
            Object.defineProperties(scopeObject, {
                [privateName]: {
                    value: scopeObject[name],
                    writable: !0
                },
                [name]: {
                    enumerable: !0,
                    get() {
                        const local = this[privateName],
                            target = targetScopeObject[targetName];
                        return isObject(local) ? Object.assign({}, target, local) : valueOrDefault(local, target)
                    },
                    set(value) {
                        this[privateName] = value
                    }
                }
            })
        }
    }({
        _scriptable: name => !name.startsWith("on"),
        _indexable: name => "events" !== name,
        hover: {
            _fallback: "interaction"
        },
        interaction: {
            _scriptable: !1,
            _indexable: !1
        }
    });

    function _measureText(ctx, data, gc, longest, string) {
        let textWidth = data[string];
        return textWidth || (textWidth = data[string] = ctx.measureText(string).width, gc.push(string)), textWidth > longest && (longest = textWidth), longest
    }

    function _longestText(ctx, font, arrayOfThings, cache) {
        let data = (cache = cache || {}).data = cache.data || {},
            gc = cache.garbageCollect = cache.garbageCollect || [];
        cache.font !== font && (data = cache.data = {}, gc = cache.garbageCollect = [], cache.font = font), ctx.save(), ctx.font = font;
        let longest = 0;
        const ilen = arrayOfThings.length;
        let i, j, jlen, thing, nestedThing;
        for (i = 0; i < ilen; i++)
            if (thing = arrayOfThings[i], null != thing && !0 !== isArray(thing)) longest = _measureText(ctx, data, gc, longest, thing);
            else if (isArray(thing))
                for (j = 0, jlen = thing.length; j < jlen; j++) nestedThing = thing[j], null == nestedThing || isArray(nestedThing) || (longest = _measureText(ctx, data, gc, longest, nestedThing));
        ctx.restore();
        const gcLen = gc.length / 2;
        if (gcLen > arrayOfThings.length) {
            for (i = 0; i < gcLen; i++) delete data[gc[i]];
            gc.splice(0, gcLen)
        }
        return longest
    }

    function _alignPixel(chart, pixel, width) {
        const devicePixelRatio = chart.currentDevicePixelRatio,
            halfWidth = 0 !== width ? Math.max(width / 2, .5) : 0;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth
    }

    function clearCanvas(canvas, ctx) {
        (ctx = ctx || canvas.getContext("2d")).save(), ctx.resetTransform(), ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.restore()
    }

    function drawPoint(ctx, options, x, y) {
        let type, xOffset, yOffset, size, cornerRadius;
        const style = options.pointStyle,
            rotation = options.rotation,
            radius = options.radius;
        let rad = (rotation || 0) * RAD_PER_DEG;
        if (style && "object" == typeof style && (type = style.toString(), "[object HTMLImageElement]" === type || "[object HTMLCanvasElement]" === type)) return ctx.save(), ctx.translate(x, y), ctx.rotate(rad), ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height), void ctx.restore();
        if (!(isNaN(radius) || radius <= 0)) {
            switch (ctx.beginPath(), style) {
                default:
                    ctx.arc(x, y, radius, 0, TAU), ctx.closePath();
                    break;
                case "triangle":
                    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius), rad += TWO_THIRDS_PI, ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius), rad += TWO_THIRDS_PI, ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius), ctx.closePath();
                    break;
                case "rectRounded":
                    cornerRadius = .516 * radius, size = radius - cornerRadius, xOffset = Math.cos(rad + QUARTER_PI) * size, yOffset = Math.sin(rad + QUARTER_PI) * size, ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI), ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad), ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI), ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI), ctx.closePath();
                    break;
                case "rect":
                    if (!rotation) {
                        size = Math.SQRT1_2 * radius, ctx.rect(x - size, y - size, 2 * size, 2 * size);
                        break
                    }
                    rad += QUARTER_PI;
                case "rectRot":
                    xOffset = Math.cos(rad) * radius, yOffset = Math.sin(rad) * radius, ctx.moveTo(x - xOffset, y - yOffset), ctx.lineTo(x + yOffset, y - xOffset), ctx.lineTo(x + xOffset, y + yOffset), ctx.lineTo(x - yOffset, y + xOffset), ctx.closePath();
                    break;
                case "crossRot":
                    rad += QUARTER_PI;
                case "cross":
                    xOffset = Math.cos(rad) * radius, yOffset = Math.sin(rad) * radius, ctx.moveTo(x - xOffset, y - yOffset), ctx.lineTo(x + xOffset, y + yOffset), ctx.moveTo(x + yOffset, y - xOffset), ctx.lineTo(x - yOffset, y + xOffset);
                    break;
                case "star":
                    xOffset = Math.cos(rad) * radius, yOffset = Math.sin(rad) * radius, ctx.moveTo(x - xOffset, y - yOffset), ctx.lineTo(x + xOffset, y + yOffset), ctx.moveTo(x + yOffset, y - xOffset), ctx.lineTo(x - yOffset, y + xOffset), rad += QUARTER_PI, xOffset = Math.cos(rad) * radius, yOffset = Math.sin(rad) * radius, ctx.moveTo(x - xOffset, y - yOffset), ctx.lineTo(x + xOffset, y + yOffset), ctx.moveTo(x + yOffset, y - xOffset), ctx.lineTo(x - yOffset, y + xOffset);
                    break;
                case "line":
                    xOffset = Math.cos(rad) * radius, yOffset = Math.sin(rad) * radius, ctx.moveTo(x - xOffset, y - yOffset), ctx.lineTo(x + xOffset, y + yOffset);
                    break;
                case "dash":
                    ctx.moveTo(x, y), ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius)
            }
            ctx.fill(), options.borderWidth > 0 && ctx.stroke()
        }
    }

    function _isPointInArea(point, area, margin) {
        return margin = margin || .5, !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin
    }

    function clipArea(ctx, area) {
        ctx.save(), ctx.beginPath(), ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top), ctx.clip()
    }

    function unclipArea(ctx) {
        ctx.restore()
    }

    function _steppedLineTo(ctx, previous, target, flip, mode) {
        if (!previous) return ctx.lineTo(target.x, target.y);
        if ("middle" === mode) {
            const midpoint = (previous.x + target.x) / 2;
            ctx.lineTo(midpoint, previous.y), ctx.lineTo(midpoint, target.y)
        } else "after" === mode != !!flip ? ctx.lineTo(previous.x, target.y) : ctx.lineTo(target.x, previous.y);
        ctx.lineTo(target.x, target.y)
    }

    function _bezierCurveTo(ctx, previous, target, flip) {
        if (!previous) return ctx.lineTo(target.x, target.y);
        ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y)
    }

    function renderText(ctx, text, x, y, font, opts = {}) {
        const lines = isArray(text) ? text : [text],
            stroke = opts.strokeWidth > 0 && "" !== opts.strokeColor;
        let i, line;
        for (ctx.save(), ctx.font = font.string, function (ctx, opts) {
            opts.translation && ctx.translate(opts.translation[0], opts.translation[1]);
            isNullOrUndef(opts.rotation) || ctx.rotate(opts.rotation);
            opts.color && (ctx.fillStyle = opts.color);
            opts.textAlign && (ctx.textAlign = opts.textAlign);
            opts.textBaseline && (ctx.textBaseline = opts.textBaseline)
        }(ctx, opts), i = 0; i < lines.length; ++i) line = lines[i], stroke && (opts.strokeColor && (ctx.strokeStyle = opts.strokeColor), isNullOrUndef(opts.strokeWidth) || (ctx.lineWidth = opts.strokeWidth), ctx.strokeText(line, x, y, opts.maxWidth)), ctx.fillText(line, x, y, opts.maxWidth), decorateText(ctx, x, y, line, opts), y += font.lineHeight;
        ctx.restore()
    }

    function decorateText(ctx, x, y, line, opts) {
        if (opts.strikethrough || opts.underline) {
            const metrics = ctx.measureText(line),
                left = x - metrics.actualBoundingBoxLeft,
                right = x + metrics.actualBoundingBoxRight,
                top = y - metrics.actualBoundingBoxAscent,
                bottom = y + metrics.actualBoundingBoxDescent,
                yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
            ctx.strokeStyle = ctx.fillStyle, ctx.beginPath(), ctx.lineWidth = opts.decorationWidth || 2, ctx.moveTo(left, yDecoration), ctx.lineTo(right, yDecoration), ctx.stroke()
        }
    }

    function addRoundedRectPath(ctx, rect) {
        const {
            x: x,
            y: y,
            w: w,
            h: h,
            radius: radius
        } = rect;
        ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, !0), ctx.lineTo(x, y + h - radius.bottomLeft), ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, !0), ctx.lineTo(x + w - radius.bottomRight, y + h), ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, !0), ctx.lineTo(x + w, y + radius.topRight), ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, !0), ctx.lineTo(x + radius.topLeft, y)
    }
    const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/),
        FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);

    function toLineHeight(value, size) {
        const matches = ("" + value).match(LINE_HEIGHT);
        if (!matches || "normal" === matches[1]) return 1.2 * size;
        switch (value = +matches[2], matches[3]) {
            case "px":
                return value;
            case "%":
                value /= 100
        }
        return size * value
    }

    function _readValueToProps(value, props) {
        const ret = {},
            objProps = isObject(props),
            keys = objProps ? Object.keys(props) : props,
            read = isObject(value) ? objProps ? prop => valueOrDefault(value[prop], value[props[prop]]) : prop => value[prop] : () => value;
        for (const prop of keys) ret[prop] = +read(prop) || 0;
        return ret
    }

    function toTRBL(value) {
        return _readValueToProps(value, {
            top: "y",
            right: "x",
            bottom: "y",
            left: "x"
        })
    }

    function toTRBLCorners(value) {
        return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
    }

    function toPadding(value) {
        const obj = toTRBL(value);
        return obj.width = obj.left + obj.right, obj.height = obj.top + obj.bottom, obj
    }

    function toFont(options, fallback) {
        options = options || {}, fallback = fallback || defaults.font;
        let size = valueOrDefault(options.size, fallback.size);
        "string" == typeof size && (size = parseInt(size, 10));
        let style = valueOrDefault(options.style, fallback.style);
        style && !("" + style).match(FONT_STYLE) && (style = "");
        const font = {
            family: valueOrDefault(options.family, fallback.family),
            lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
            size: size,
            style: style,
            weight: valueOrDefault(options.weight, fallback.weight),
            string: ""
        };
        return font.string = function (font) {
            return !font || isNullOrUndef(font.size) || isNullOrUndef(font.family) ? null : (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family
        }(font), font
    }

    function resolve(inputs, context, index, info) {
        let i, ilen, value, cacheable = !0;
        for (i = 0, ilen = inputs.length; i < ilen; ++i)
            if (value = inputs[i], void 0 !== value && (void 0 !== context && "function" == typeof value && (value = value(context), cacheable = !1), void 0 !== index && isArray(value) && (value = value[index % value.length], cacheable = !1), void 0 !== value)) return info && !cacheable && (info.cacheable = !1), value
    }

    function createContext(parentContext, context) {
        return Object.assign(Object.create(parentContext), context)
    }

    function _lookup(table, value, cmp) {
        cmp = cmp || (index => table[index] < value);
        let mid, hi = table.length - 1,
            lo = 0;
        for (; hi - lo > 1;) mid = lo + hi >> 1, cmp(mid) ? lo = mid : hi = mid;
        return {
            lo: lo,
            hi: hi
        }
    }
    const _lookupByKey = (table, key, value) => _lookup(table, value, index => table[index][key] < value),
        _rlookupByKey = (table, key, value) => _lookup(table, value, index => table[index][key] >= value);
    const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];

    function unlistenArrayEvents(array, listener) {
        const stub = array._chartjs;
        if (!stub) return;
        const listeners = stub.listeners,
            index = listeners.indexOf(listener); - 1 !== index && listeners.splice(index, 1), listeners.length > 0 || (arrayEvents.forEach(key => {
                delete array[key]
            }), delete array._chartjs)
    }

    function _arrayUnique(items) {
        const set = new Set;
        let i, ilen;
        for (i = 0, ilen = items.length; i < ilen; ++i) set.add(items[i]);
        return set.size === ilen ? items : Array.from(set)
    }

    function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = (() => scopes[0])) {
        defined(fallback) || (fallback = _resolve("_fallback", scopes));
        const cache = {
            [Symbol.toStringTag]: "Object",
            _cacheable: !0,
            _scopes: scopes,
            _rootScopes: rootScopes,
            _fallback: fallback,
            _getTarget: getTarget,
            override: scope => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
        };
        return new Proxy(cache, {
            deleteProperty: (target, prop) => (delete target[prop], delete target._keys, delete scopes[0][prop], !0),
            get: (target, prop) => _cached(target, prop, () => function (prop, prefixes, scopes, proxy) {
                let value;
                for (const prefix of prefixes)
                    if (value = _resolve(readKey(prefix, prop), scopes), defined(value)) return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value
            }(prop, prefixes, scopes, target)),
            getOwnPropertyDescriptor: (target, prop) => Reflect.getOwnPropertyDescriptor(target._scopes[0], prop),
            getPrototypeOf: () => Reflect.getPrototypeOf(scopes[0]),
            has: (target, prop) => getKeysFromAllScopes(target).includes(prop),
            ownKeys: target => getKeysFromAllScopes(target),
            set: (target, prop, value) => ((target._storage || (target._storage = getTarget()))[prop] = value, delete target[prop], delete target._keys, !0)
        })
    }

    function _attachContext(proxy, context, subProxy, descriptorDefaults) {
        const cache = {
            _cacheable: !1,
            _proxy: proxy,
            _context: context,
            _subProxy: subProxy,
            _stack: new Set,
            _descriptors: _descriptors(proxy, descriptorDefaults),
            setContext: ctx => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
            override: scope => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
        };
        return new Proxy(cache, {
            deleteProperty: (target, prop) => (delete target[prop], delete proxy[prop], !0),
            get: (target, prop, receiver) => _cached(target, prop, () => function (target, prop, receiver) {
                const {
                    _proxy: _proxy,
                    _context: _context,
                    _subProxy: _subProxy,
                    _descriptors: descriptors
                } = target;
                let value = _proxy[prop];
                isFunction(value) && descriptors.isScriptable(prop) && (value = function (prop, value, target, receiver) {
                    const {
                        _proxy: _proxy,
                        _context: _context,
                        _subProxy: _subProxy,
                        _stack: _stack
                    } = target;
                    if (_stack.has(prop)) throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
                    _stack.add(prop), value = value(_context, _subProxy || receiver), _stack.delete(prop), isObject(value) && (value = createSubResolver(_proxy._scopes, _proxy, prop, value));
                    return value
                }(prop, value, target, receiver));
                isArray(value) && value.length && (value = function (prop, value, target, isIndexable) {
                    const {
                        _proxy: _proxy,
                        _context: _context,
                        _subProxy: _subProxy,
                        _descriptors: descriptors
                    } = target;
                    if (defined(_context.index) && isIndexable(prop)) value = value[_context.index % value.length];
                    else if (isObject(value[0])) {
                        const arr = value,
                            scopes = _proxy._scopes.filter(s => s !== arr);
                        value = [];
                        for (const item of arr) {
                            const resolver = createSubResolver(scopes, _proxy, prop, item);
                            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors))
                        }
                    }
                    return value
                }(prop, value, target, descriptors.isIndexable));
                needsSubResolver(prop, value) && (value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors));
                return value
            }(target, prop, receiver)),
            getOwnPropertyDescriptor: (target, prop) => target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                enumerable: !0,
                configurable: !0
            } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop),
            getPrototypeOf: () => Reflect.getPrototypeOf(proxy),
            has: (target, prop) => Reflect.has(proxy, prop),
            ownKeys: () => Reflect.ownKeys(proxy),
            set: (target, prop, value) => (proxy[prop] = value, delete target[prop], !0)
        })
    }

    function _descriptors(proxy, defaults = {
        scriptable: !0,
        indexable: !0
    }) {
        const {
            _scriptable: _scriptable = defaults.scriptable,
            _indexable: _indexable = defaults.indexable,
            _allKeys: _allKeys = defaults.allKeys
        } = proxy;
        return {
            allKeys: _allKeys,
            scriptable: _scriptable,
            indexable: _indexable,
            isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
            isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
        }
    }
    const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name,
        needsSubResolver = (prop, value) => isObject(value) && "adapters" !== prop;

    function _cached(target, prop, resolve) {
        if (Object.prototype.hasOwnProperty.call(target, prop)) return target[prop];
        const value = resolve();
        return target[prop] = value, value
    }

    function resolveFallback(fallback, prop, value) {
        return isFunction(fallback) ? fallback(prop, value) : fallback
    }
    const getScope = (key, parent) => !0 === key ? parent : "string" == typeof key ? resolveObjectKey(parent, key) : void 0;

    function addScopes(set, parentScopes, key, parentFallback) {
        for (const parent of parentScopes) {
            const scope = getScope(key, parent);
            if (scope) {
                set.add(scope);
                const fallback = resolveFallback(scope._fallback, key, scope);
                if (defined(fallback) && fallback !== key && fallback !== parentFallback) return fallback
            } else if (!1 === scope && defined(parentFallback) && key !== parentFallback) return null
        }
        return !1
    }

    function createSubResolver(parentScopes, resolver, prop, value) {
        const rootScopes = resolver._rootScopes,
            fallback = resolveFallback(resolver._fallback, prop, value),
            allScopes = [...parentScopes, ...rootScopes],
            set = new Set;
        set.add(value);
        let key = addScopesFromKey(set, allScopes, prop, fallback || prop);
        return null !== key && ((!defined(fallback) || fallback === prop || (key = addScopesFromKey(set, allScopes, fallback, key), null !== key)) && _createResolver(Array.from(set), [""], rootScopes, fallback, () => function (resolver, prop, value) {
            const parent = resolver._getTarget();
            prop in parent || (parent[prop] = {});
            const target = parent[prop];
            if (isArray(target) && isObject(value)) return value;
            return target
        }(resolver, prop, value)))
    }

    function addScopesFromKey(set, allScopes, key, fallback) {
        for (; key;) key = addScopes(set, allScopes, key, fallback);
        return key
    }

    function _resolve(key, scopes) {
        for (const scope of scopes) {
            if (!scope) continue;
            const value = scope[key];
            if (defined(value)) return value
        }
    }

    function getKeysFromAllScopes(target) {
        let keys = target._keys;
        return keys || (keys = target._keys = function (scopes) {
            const set = new Set;
            for (const scope of scopes)
                for (const key of Object.keys(scope).filter(k => !k.startsWith("_"))) set.add(key);
            return Array.from(set)
        }(target._scopes)), keys
    }
    const EPSILON = Number.EPSILON || 1e-14,
        getPoint = (points, i) => i < points.length && !points[i].skip && points[i],
        getValueAxis = indexAxis => "x" === indexAxis ? "y" : "x";

    function splineCurve(firstPoint, middlePoint, afterPoint, t) {
        const previous = firstPoint.skip ? middlePoint : firstPoint,
            current = middlePoint,
            next = afterPoint.skip ? middlePoint : afterPoint,
            d01 = distanceBetweenPoints(current, previous),
            d12 = distanceBetweenPoints(next, current);
        let s01 = d01 / (d01 + d12),
            s12 = d12 / (d01 + d12);
        s01 = isNaN(s01) ? 0 : s01, s12 = isNaN(s12) ? 0 : s12;
        const fa = t * s01,
            fb = t * s12;
        return {
            previous: {
                x: current.x - fa * (next.x - previous.x),
                y: current.y - fa * (next.y - previous.y)
            },
            next: {
                x: current.x + fb * (next.x - previous.x),
                y: current.y + fb * (next.y - previous.y)
            }
        }
    }

    function splineCurveMonotone(points, indexAxis = "x") {
        const valueAxis = getValueAxis(indexAxis),
            pointsLen = points.length,
            deltaK = Array(pointsLen).fill(0),
            mK = Array(pointsLen);
        let i, pointBefore, pointCurrent, pointAfter = getPoint(points, 0);
        for (i = 0; i < pointsLen; ++i)
            if (pointBefore = pointCurrent, pointCurrent = pointAfter, pointAfter = getPoint(points, i + 1), pointCurrent) {
                if (pointAfter) {
                    const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
                    deltaK[i] = 0 !== slopeDelta ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0
                }
                mK[i] = pointBefore ? pointAfter ? sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2 : deltaK[i - 1] : deltaK[i]
            } !
                function (points, deltaK, mK) {
                    const pointsLen = points.length;
                    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent, pointAfter = getPoint(points, 0);
                    for (let i = 0; i < pointsLen - 1; ++i) pointCurrent = pointAfter, pointAfter = getPoint(points, i + 1), pointCurrent && pointAfter && (almostEquals(deltaK[i], 0, EPSILON) ? mK[i] = mK[i + 1] = 0 : (alphaK = mK[i] / deltaK[i], betaK = mK[i + 1] / deltaK[i], squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2), squaredMagnitude <= 9 || (tauK = 3 / Math.sqrt(squaredMagnitude), mK[i] = alphaK * tauK * deltaK[i], mK[i + 1] = betaK * tauK * deltaK[i])))
                }(points, deltaK, mK),
                function (points, mK, indexAxis = "x") {
                    const valueAxis = getValueAxis(indexAxis),
                        pointsLen = points.length;
                    let delta, pointBefore, pointCurrent, pointAfter = getPoint(points, 0);
                    for (let i = 0; i < pointsLen; ++i) {
                        if (pointBefore = pointCurrent, pointCurrent = pointAfter, pointAfter = getPoint(points, i + 1), !pointCurrent) continue;
                        const iPixel = pointCurrent[indexAxis],
                            vPixel = pointCurrent[valueAxis];
                        pointBefore && (delta = (iPixel - pointBefore[indexAxis]) / 3, pointCurrent["cp1" + indexAxis] = iPixel - delta, pointCurrent["cp1" + valueAxis] = vPixel - delta * mK[i]), pointAfter && (delta = (pointAfter[indexAxis] - iPixel) / 3, pointCurrent["cp2" + indexAxis] = iPixel + delta, pointCurrent["cp2" + valueAxis] = vPixel + delta * mK[i])
                    }
                }(points, mK, indexAxis)
    }

    function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min)
    }

    function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
        let i, ilen, point, controlPoints;
        if (options.spanGaps && (points = points.filter(pt => !pt.skip)), "monotone" === options.cubicInterpolationMode) splineCurveMonotone(points, indexAxis);
        else {
            let prev = loop ? points[points.length - 1] : points[0];
            for (i = 0, ilen = points.length; i < ilen; ++i) point = points[i], controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension), point.cp1x = controlPoints.previous.x, point.cp1y = controlPoints.previous.y, point.cp2x = controlPoints.next.x, point.cp2y = controlPoints.next.y, prev = point
        }
        options.capBezierPoints && function (points, area) {
            let i, ilen, point, inArea, inAreaPrev, inAreaNext = _isPointInArea(points[0], area);
            for (i = 0, ilen = points.length; i < ilen; ++i) inAreaPrev = inArea, inArea = inAreaNext, inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area), inArea && (point = points[i], inAreaPrev && (point.cp1x = capControlPoint(point.cp1x, area.left, area.right), point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom)), inAreaNext && (point.cp2x = capControlPoint(point.cp2x, area.left, area.right), point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom)))
        }(points, area)
    }

    function _isDomSupported() {
        return "undefined" != typeof window && "undefined" != typeof document
    }

    function _getParentNode(domNode) {
        let parent = domNode.parentNode;
        return parent && "[object ShadowRoot]" === parent.toString() && (parent = parent.host), parent
    }

    function parseMaxStyle(styleValue, node, parentProperty) {
        let valueInPixels;
        return "string" == typeof styleValue ? (valueInPixels = parseInt(styleValue, 10), -1 !== styleValue.indexOf("%") && (valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty])) : valueInPixels = styleValue, valueInPixels
    }
    const helpers_segment_getComputedStyle = element => window.getComputedStyle(element, null);
    const helpers_segment_positions = ["top", "right", "bottom", "left"];

    function getPositionedStyle(styles, style, suffix) {
        const result = {};
        suffix = suffix ? "-" + suffix : "";
        for (let i = 0; i < 4; i++) {
            const pos = helpers_segment_positions[i];
            result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0
        }
        return result.width = result.left + result.right, result.height = result.top + result.bottom, result
    }

    function getRelativePosition(evt, chart) {
        const {
            canvas: canvas,
            currentDevicePixelRatio: currentDevicePixelRatio
        } = chart, style = helpers_segment_getComputedStyle(canvas), borderBox = "border-box" === style.boxSizing, paddings = getPositionedStyle(style, "padding"), borders = getPositionedStyle(style, "border", "width"), {
            x: x,
            y: y,
            box: box
        } = function (evt, canvas) {
            const e = evt.native || evt,
                touches = e.touches,
                source = touches && touches.length ? touches[0] : e,
                {
                    offsetX: offsetX,
                    offsetY: offsetY
                } = source;
            let x, y, box = !1;
            if (((x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot))(offsetX, offsetY, e.target)) x = offsetX, y = offsetY;
            else {
                const rect = canvas.getBoundingClientRect();
                x = source.clientX - rect.left, y = source.clientY - rect.top, box = !0
            }
            return {
                x: x,
                y: y,
                box: box
            }
        }(evt, canvas), xOffset = paddings.left + (box && borders.left), yOffset = paddings.top + (box && borders.top);
        let {
            width: width,
            height: height
        } = chart;
        return borderBox && (width -= paddings.width + borders.width, height -= paddings.height + borders.height), {
            x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
            y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
        }
    }
    const round1 = v => Math.round(10 * v) / 10;

    function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
        const style = helpers_segment_getComputedStyle(canvas),
            margins = getPositionedStyle(style, "margin"),
            maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY,
            maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY,
            containerSize = function (canvas, width, height) {
                let maxWidth, maxHeight;
                if (void 0 === width || void 0 === height) {
                    const container = _getParentNode(canvas);
                    if (container) {
                        const rect = container.getBoundingClientRect(),
                            containerStyle = helpers_segment_getComputedStyle(container),
                            containerBorder = getPositionedStyle(containerStyle, "border", "width"),
                            containerPadding = getPositionedStyle(containerStyle, "padding");
                        width = rect.width - containerPadding.width - containerBorder.width, height = rect.height - containerPadding.height - containerBorder.height, maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth"), maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight")
                    } else width = canvas.clientWidth, height = canvas.clientHeight
                }
                return {
                    width: width,
                    height: height,
                    maxWidth: maxWidth || INFINITY,
                    maxHeight: maxHeight || INFINITY
                }
            }(canvas, bbWidth, bbHeight);
        let {
            width: width,
            height: height
        } = containerSize;
        if ("content-box" === style.boxSizing) {
            const borders = getPositionedStyle(style, "border", "width"),
                paddings = getPositionedStyle(style, "padding");
            width -= paddings.width + borders.width, height -= paddings.height + borders.height
        }
        return width = Math.max(0, width - margins.width), height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height), width = round1(Math.min(width, maxWidth, containerSize.maxWidth)), height = round1(Math.min(height, maxHeight, containerSize.maxHeight)), width && !height && (height = round1(width / 2)), {
            width: width,
            height: height
        }
    }

    function retinaScale(chart, forceRatio, forceStyle) {
        const pixelRatio = forceRatio || 1,
            deviceHeight = Math.floor(chart.height * pixelRatio),
            deviceWidth = Math.floor(chart.width * pixelRatio);
        chart.height = deviceHeight / pixelRatio, chart.width = deviceWidth / pixelRatio;
        const canvas = chart.canvas;
        return canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width) && (canvas.style.height = chart.height + "px", canvas.style.width = chart.width + "px"), (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) && (chart.currentDevicePixelRatio = pixelRatio, canvas.height = deviceHeight, canvas.width = deviceWidth, chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0), !0)
    }
    const supportsEventListenerOptions = function () {
        let passiveSupported = !1;
        try {
            const options = {
                get passive() {
                    return passiveSupported = !0, !1
                }
            };
            window.addEventListener("test", null, options), window.removeEventListener("test", null, options)
        } catch (e) { }
        return passiveSupported
    }();

    function readUsedSize(element, property) {
        const value = function (el, property) {
            return helpers_segment_getComputedStyle(el).getPropertyValue(property)
        }(element, property),
            matches = value && value.match(/^(\d+)(\.\d+)?px$/);
        return matches ? +matches[1] : void 0
    }

    function _pointInLine(p1, p2, t, mode) {
        return {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y)
        }
    }

    function _steppedInterpolation(p1, p2, t, mode) {
        return {
            x: p1.x + t * (p2.x - p1.x),
            y: "middle" === mode ? t < .5 ? p1.y : p2.y : "after" === mode ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
        }
    }

    function _bezierInterpolation(p1, p2, t, mode) {
        const cp1 = {
            x: p1.cp2x,
            y: p1.cp2y
        },
            cp2 = {
                x: p2.cp1x,
                y: p2.cp1y
            },
            a = _pointInLine(p1, cp1, t),
            b = _pointInLine(cp1, cp2, t),
            c = _pointInLine(cp2, p2, t),
            d = _pointInLine(a, b, t),
            e = _pointInLine(b, c, t);
        return _pointInLine(d, e, t)
    }
    const intlCache = new Map;

    function formatNumber(num, locale, options) {
        return function (locale, options) {
            options = options || {};
            const cacheKey = locale + JSON.stringify(options);
            let formatter = intlCache.get(cacheKey);
            return formatter || (formatter = new Intl.NumberFormat(locale, options), intlCache.set(cacheKey, formatter)), formatter
        }(locale, options).format(num)
    }

    function getRtlAdapter(rtl, rectX, width) {
        return rtl ? function (rectX, width) {
            return {
                x: x => rectX + rectX + width - x,
                setWidth(w) {
                    width = w
                },
                textAlign: align => "center" === align ? align : "right" === align ? "left" : "right",
                xPlus: (x, value) => x - value,
                leftForLtr: (x, itemWidth) => x - itemWidth
            }
        }(rectX, width) : {
            x: x => x,
            setWidth(w) { },
            textAlign: align => align,
            xPlus: (x, value) => x + value,
            leftForLtr: (x, _itemWidth) => x
        }
    }

    function overrideTextDirection(ctx, direction) {
        let style, original;
        "ltr" !== direction && "rtl" !== direction || (style = ctx.canvas.style, original = [style.getPropertyValue("direction"), style.getPropertyPriority("direction")], style.setProperty("direction", direction, "important"), ctx.prevTextDirection = original)
    }

    function restoreTextDirection(ctx, original) {
        void 0 !== original && (delete ctx.prevTextDirection, ctx.canvas.style.setProperty("direction", original[0], original[1]))
    }

    function propertyFn(property) {
        return "angle" === property ? {
            between: _angleBetween,
            compare: _angleDiff,
            normalize: _normalizeAngle
        } : {
            between: (n, s, e) => n >= Math.min(s, e) && n <= Math.max(e, s),
            compare: (a, b) => a - b,
            normalize: x => x
        }
    }

    function normalizeSegment({
        start: start,
        end: end,
        count: count,
        loop: loop,
        style: style
    }) {
        return {
            start: start % count,
            end: end % count,
            loop: loop && (end - start + 1) % count == 0,
            style: style
        }
    }

    function _boundSegment(segment, points, bounds) {
        if (!bounds) return [segment];
        const {
            property: property,
            start: startBound,
            end: endBound
        } = bounds, count = points.length, {
            compare: compare,
            between: between,
            normalize: normalize
        } = propertyFn(property), {
            start: start,
            end: end,
            loop: loop,
            style: style
        } = function (segment, points, bounds) {
            const {
                property: property,
                start: startBound,
                end: endBound
            } = bounds, {
                between: between,
                normalize: normalize
            } = propertyFn(property), count = points.length;
            let i, ilen, {
                start: start,
                end: end,
                loop: loop
            } = segment;
            if (loop) {
                for (start += count, end += count, i = 0, ilen = count; i < ilen && between(normalize(points[start % count][property]), startBound, endBound); ++i) start--, end--;
                start %= count, end %= count
            }
            return end < start && (end += count), {
                start: start,
                end: end,
                loop: loop,
                style: segment.style
            }
        }(segment, points, bounds), result = [];
        let value, point, prevValue, inside = !1,
            subStart = null;
        const shouldStart = () => inside || between(startBound, prevValue, value) && 0 !== compare(startBound, prevValue),
            shouldStop = () => !inside || 0 === compare(endBound, value) || between(endBound, prevValue, value);
        for (let i = start, prev = start; i <= end; ++i) point = points[i % count], point.skip || (value = normalize(point[property]), value !== prevValue && (inside = between(value, startBound, endBound), null === subStart && shouldStart() && (subStart = 0 === compare(value, startBound) ? i : prev), null !== subStart && shouldStop() && (result.push(normalizeSegment({
            start: subStart,
            end: i,
            loop: loop,
            count: count,
            style: style
        })), subStart = null), prev = i, prevValue = value));
        return null !== subStart && result.push(normalizeSegment({
            start: subStart,
            end: end,
            loop: loop,
            count: count,
            style: style
        })), result
    }

    function _boundSegments(line, bounds) {
        const result = [],
            segments = line.segments;
        for (let i = 0; i < segments.length; i++) {
            const sub = _boundSegment(segments[i], line.points, bounds);
            sub.length && result.push(...sub)
        }
        return result
    }

    function splitByStyles(line, segments, points, segmentOptions) {
        return segmentOptions && segmentOptions.setContext && points ? function (line, segments, points, segmentOptions) {
            const chartContext = line._chart.getContext(),
                baseStyle = readStyle(line.options),
                {
                    _datasetIndex: datasetIndex,
                    options: {
                        spanGaps: spanGaps
                    }
                } = line,
                count = points.length,
                result = [];
            let prevStyle = baseStyle,
                start = segments[0].start,
                i = start;

            function addStyle(s, e, l, st) {
                const dir = spanGaps ? -1 : 1;
                if (s !== e) {
                    for (s += count; points[s % count].skip;) s -= dir;
                    for (; points[e % count].skip;) e += dir;
                    s % count != e % count && (result.push({
                        start: s % count,
                        end: e % count,
                        loop: l,
                        style: st
                    }), prevStyle = st, start = e % count)
                }
            }
            for (const segment of segments) {
                start = spanGaps ? start : segment.start;
                let style, prev = points[start % count];
                for (i = start + 1; i <= segment.end; i++) {
                    const pt = points[i % count];
                    style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                        type: "segment",
                        p0: prev,
                        p1: pt,
                        p0DataIndex: (i - 1) % count,
                        p1DataIndex: i % count,
                        datasetIndex: datasetIndex
                    }))), styleChanged(style, prevStyle) && addStyle(start, i - 1, segment.loop, prevStyle), prev = pt, prevStyle = style
                }
                start < i - 1 && addStyle(start, i - 1, segment.loop, prevStyle)
            }
            return result
        }(line, segments, points, segmentOptions) : segments
    }

    function readStyle(options) {
        return {
            backgroundColor: options.backgroundColor,
            borderCapStyle: options.borderCapStyle,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderJoinStyle: options.borderJoinStyle,
            borderWidth: options.borderWidth,
            borderColor: options.borderColor
        }
    }

    function styleChanged(style, prevStyle) {
        return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle)
    }
    var animator = new class {
        constructor() {
            this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0
        }
        _notify(chart, anims, date, type) {
            const callbacks = anims.listeners[type],
                numSteps = anims.duration;
            callbacks.forEach(fn => fn({
                chart: chart,
                initial: anims.initial,
                numSteps: numSteps,
                currentStep: Math.min(date - anims.start, numSteps)
            }))
        }
        _refresh() {
            this._request || (this._running = !0, this._request = requestAnimFrame.call(window, () => {
                this._update(), this._request = null, this._running && this._refresh()
            }))
        }
        _update(date = Date.now()) {
            let remaining = 0;
            this._charts.forEach((anims, chart) => {
                if (!anims.running || !anims.items.length) return;
                const items = anims.items;
                let item, i = items.length - 1,
                    draw = !1;
                for (; i >= 0; --i) item = items[i], item._active ? (item._total > anims.duration && (anims.duration = item._total), item.tick(date), draw = !0) : (items[i] = items[items.length - 1], items.pop());
                draw && (chart.draw(), this._notify(chart, anims, date, "progress")), items.length || (anims.running = !1, this._notify(chart, anims, date, "complete"), anims.initial = !1), remaining += items.length
            }), this._lastDate = date, 0 === remaining && (this._running = !1)
        }
        _getAnims(chart) {
            const charts = this._charts;
            let anims = charts.get(chart);
            return anims || (anims = {
                running: !1,
                initial: !0,
                items: [],
                listeners: {
                    complete: [],
                    progress: []
                }
            }, charts.set(chart, anims)), anims
        }
        listen(chart, event, cb) {
            this._getAnims(chart).listeners[event].push(cb)
        }
        add(chart, items) {
            items && items.length && this._getAnims(chart).items.push(...items)
        }
        has(chart) {
            return this._getAnims(chart).items.length > 0
        }
        start(chart) {
            const anims = this._charts.get(chart);
            anims && (anims.running = !0, anims.start = Date.now(), anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0), this._refresh())
        }
        running(chart) {
            if (!this._running) return !1;
            const anims = this._charts.get(chart);
            return !!(anims && anims.running && anims.items.length)
        }
        stop(chart) {
            const anims = this._charts.get(chart);
            if (!anims || !anims.items.length) return;
            const items = anims.items;
            let i = items.length - 1;
            for (; i >= 0; --i) items[i].cancel();
            anims.items = [], this._notify(chart, anims, Date.now(), "complete")
        }
        remove(chart) {
            return this._charts.delete(chart)
        }
    };
    const interpolators = {
        boolean: (from, to, factor) => factor > .5 ? to : from,
        color(from, to, factor) {
            const c0 = helpers_segment_color(from || "transparent"),
                c1 = c0.valid && helpers_segment_color(to || "transparent");
            return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to
        },
        number: (from, to, factor) => from + (to - from) * factor
    };
    class chart_esm_Animation {
        constructor(cfg, target, prop, to) {
            const currentValue = target[prop];
            to = resolve([cfg.to, to, currentValue, cfg.from]);
            const from = resolve([cfg.from, currentValue, to]);
            this._active = !0, this._fn = cfg.fn || interpolators[cfg.type || typeof from], this._easing = effects[cfg.easing] || effects.linear, this._start = Math.floor(Date.now() + (cfg.delay || 0)), this._duration = this._total = Math.floor(cfg.duration), this._loop = !!cfg.loop, this._target = target, this._prop = prop, this._from = from, this._to = to, this._promises = void 0
        }
        active() {
            return this._active
        }
        update(cfg, to, date) {
            if (this._active) {
                this._notify(!1);
                const currentValue = this._target[this._prop],
                    elapsed = date - this._start,
                    remain = this._duration - elapsed;
                this._start = date, this._duration = Math.floor(Math.max(remain, cfg.duration)), this._total += elapsed, this._loop = !!cfg.loop, this._to = resolve([cfg.to, to, currentValue, cfg.from]), this._from = resolve([cfg.from, currentValue, to])
            }
        }
        cancel() {
            this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1))
        }
        tick(date) {
            const elapsed = date - this._start,
                duration = this._duration,
                prop = this._prop,
                from = this._from,
                loop = this._loop,
                to = this._to;
            let factor;
            if (this._active = from !== to && (loop || elapsed < duration), !this._active) return this._target[prop] = to, void this._notify(!0);
            elapsed < 0 ? this._target[prop] = from : (factor = elapsed / duration % 2, factor = loop && factor > 1 ? 2 - factor : factor, factor = this._easing(Math.min(1, Math.max(0, factor))), this._target[prop] = this._fn(from, to, factor))
        }
        wait() {
            const promises = this._promises || (this._promises = []);
            return new Promise((res, rej) => {
                promises.push({
                    res: res,
                    rej: rej
                })
            })
        }
        _notify(resolved) {
            const method = resolved ? "res" : "rej",
                promises = this._promises || [];
            for (let i = 0; i < promises.length; i++) promises[i][method]()
        }
    }
    defaults.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
    });
    const chart_esm_animationOptions = Object.keys(defaults.animation);
    defaults.describe("animation", {
        _fallback: !1,
        _indexable: !1,
        _scriptable: name => "onProgress" !== name && "onComplete" !== name && "fn" !== name
    }), defaults.set("animations", {
        colors: {
            type: "color",
            properties: ["color", "borderColor", "backgroundColor"]
        },
        numbers: {
            type: "number",
            properties: ["x", "y", "borderWidth", "radius", "tension"]
        }
    }), defaults.describe("animations", {
        _fallback: "animation"
    }), defaults.set("transitions", {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: "transparent"
                },
                visible: {
                    type: "boolean",
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: "transparent"
                },
                visible: {
                    type: "boolean",
                    easing: "linear",
                    fn: v => 0 | v
                }
            }
        }
    });
    class chart_esm_Animations {
        constructor(chart, config) {
            this._chart = chart, this._properties = new Map, this.configure(config)
        }
        configure(config) {
            if (!isObject(config)) return;
            const animatedProps = this._properties;
            Object.getOwnPropertyNames(config).forEach(key => {
                const cfg = config[key];
                if (!isObject(cfg)) return;
                const resolved = {};
                for (const option of chart_esm_animationOptions) resolved[option] = cfg[option];
                (isArray(cfg.properties) && cfg.properties || [key]).forEach(prop => {
                    prop !== key && animatedProps.has(prop) || animatedProps.set(prop, resolved)
                })
            })
        }
        _animateOptions(target, values) {
            const newOptions = values.options,
                options = function (target, newOptions) {
                    if (!newOptions) return;
                    let options = target.options;
                    if (!options) return void (target.options = newOptions);
                    options.$shared && (target.options = options = Object.assign({}, options, {
                        $shared: !1,
                        $animations: {}
                    }));
                    return options
                }(target, newOptions);
            if (!options) return [];
            const animations = this._createAnimations(options, newOptions);
            return newOptions.$shared && function (animations, properties) {
                const running = [],
                    keys = Object.keys(properties);
                for (let i = 0; i < keys.length; i++) {
                    const anim = animations[keys[i]];
                    anim && anim.active() && running.push(anim.wait())
                }
                return Promise.all(running)
            }(target.options.$animations, newOptions).then(() => {
                target.options = newOptions
            }, () => { }), animations
        }
        _createAnimations(target, values) {
            const animatedProps = this._properties,
                animations = [],
                running = target.$animations || (target.$animations = {}),
                props = Object.keys(values),
                date = Date.now();
            let i;
            for (i = props.length - 1; i >= 0; --i) {
                const prop = props[i];
                if ("$" === prop.charAt(0)) continue;
                if ("options" === prop) {
                    animations.push(...this._animateOptions(target, values));
                    continue
                }
                const value = values[prop];
                let animation = running[prop];
                const cfg = animatedProps.get(prop);
                if (animation) {
                    if (cfg && animation.active()) {
                        animation.update(cfg, value, date);
                        continue
                    }
                    animation.cancel()
                }
                cfg && cfg.duration ? (running[prop] = animation = new chart_esm_Animation(cfg, target, prop, value), animations.push(animation)) : target[prop] = value
            }
            return animations
        }
        update(target, values) {
            if (0 === this._properties.size) return void Object.assign(target, values);
            const animations = this._createAnimations(target, values);
            return animations.length ? (animator.add(this._chart, animations), !0) : void 0
        }
    }

    function scaleClip(scale, allowedOverflow) {
        const opts = scale && scale.options || {},
            reverse = opts.reverse,
            min = void 0 === opts.min ? allowedOverflow : 0,
            max = void 0 === opts.max ? allowedOverflow : 0;
        return {
            start: reverse ? max : min,
            end: reverse ? min : max
        }
    }

    function getSortedDatasetIndices(chart, filterVisible) {
        const keys = [],
            metasets = chart._getSortedDatasetMetas(filterVisible);
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i) keys.push(metasets[i].index);
        return keys
    }

    function applyStack(stack, value, dsIndex, options = {}) {
        const keys = stack.keys,
            singleMode = "single" === options.mode;
        let i, ilen, datasetIndex, otherValue;
        if (null !== value) {
            for (i = 0, ilen = keys.length; i < ilen; ++i) {
                if (datasetIndex = +keys[i], datasetIndex === dsIndex) {
                    if (options.all) continue;
                    break
                }
                otherValue = stack.values[datasetIndex], isNumberFinite(otherValue) && (singleMode || 0 === value || sign(value) === sign(otherValue)) && (value += otherValue)
            }
            return value
        }
    }

    function isStacked(scale, meta) {
        const stacked = scale && scale.options.stacked;
        return stacked || void 0 === stacked && void 0 !== meta.stack
    }

    function getOrCreateStack(stacks, stackKey, indexValue) {
        const subStack = stacks[stackKey] || (stacks[stackKey] = {});
        return subStack[indexValue] || (subStack[indexValue] = {})
    }

    function getLastIndexInStack(stack, vScale, positive, type) {
        for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
            const value = stack[meta.index];
            if (positive && value > 0 || !positive && value < 0) return meta.index
        }
        return null
    }

    function updateStacks(controller, parsed) {
        const {
            chart: chart,
            _cachedMeta: meta
        } = controller, stacks = chart._stacks || (chart._stacks = {}), {
            iScale: iScale,
            vScale: vScale,
            index: datasetIndex
        } = meta, iAxis = iScale.axis, vAxis = vScale.axis, key = function (indexScale, valueScale, meta) {
            return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`
        }(iScale, vScale, meta), ilen = parsed.length;
        let stack;
        for (let i = 0; i < ilen; ++i) {
            const item = parsed[i],
                {
                    [iAxis]: index,
                    [vAxis]: value
                } = item;
            stack = (item._stacks || (item._stacks = {}))[vAxis] = getOrCreateStack(stacks, key, index), stack[datasetIndex] = value, stack._top = getLastIndexInStack(stack, vScale, !0, meta.type), stack._bottom = getLastIndexInStack(stack, vScale, !1, meta.type)
        }
    }

    function getFirstScaleId(chart, axis) {
        const scales = chart.scales;
        return Object.keys(scales).filter(key => scales[key].axis === axis).shift()
    }

    function clearStacks(meta, items) {
        const datasetIndex = meta.controller.index,
            axis = meta.vScale && meta.vScale.axis;
        if (axis) {
            items = items || meta._parsed;
            for (const parsed of items) {
                const stacks = parsed._stacks;
                if (!stacks || void 0 === stacks[axis] || void 0 === stacks[axis][datasetIndex]) return;
                delete stacks[axis][datasetIndex]
            }
        }
    }
    const isDirectUpdateMode = mode => "reset" === mode || "none" === mode,
        cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
    class chart_esm_DatasetController {
        constructor(chart, datasetIndex) {
            this.chart = chart, this._ctx = chart.ctx, this.index = datasetIndex, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.$context = void 0, this._syncList = [], this.initialize()
        }
        initialize() {
            const meta = this._cachedMeta;
            this.configure(), this.linkScales(), meta._stacked = isStacked(meta.vScale, meta), this.addElements()
        }
        updateIndex(datasetIndex) {
            this.index !== datasetIndex && clearStacks(this._cachedMeta), this.index = datasetIndex
        }
        linkScales() {
            const chart = this.chart,
                meta = this._cachedMeta,
                dataset = this.getDataset(),
                chooseId = (axis, x, y, r) => "x" === axis ? x : "r" === axis ? r : y,
                xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x")),
                yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y")),
                rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r")),
                indexAxis = meta.indexAxis,
                iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid),
                vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
            meta.xScale = this.getScaleForId(xid), meta.yScale = this.getScaleForId(yid), meta.rScale = this.getScaleForId(rid), meta.iScale = this.getScaleForId(iid), meta.vScale = this.getScaleForId(vid)
        }
        getDataset() {
            return this.chart.data.datasets[this.index]
        }
        getMeta() {
            return this.chart.getDatasetMeta(this.index)
        }
        getScaleForId(scaleID) {
            return this.chart.scales[scaleID]
        }
        _getOtherScale(scale) {
            const meta = this._cachedMeta;
            return scale === meta.iScale ? meta.vScale : meta.iScale
        }
        reset() {
            this._update("reset")
        }
        _destroy() {
            const meta = this._cachedMeta;
            this._data && unlistenArrayEvents(this._data, this), meta._stacked && clearStacks(meta)
        }
        _dataCheck() {
            const dataset = this.getDataset(),
                data = dataset.data || (dataset.data = []),
                _data = this._data;
            if (isObject(data)) this._data = function (data) {
                const keys = Object.keys(data),
                    adata = new Array(keys.length);
                let i, ilen, key;
                for (i = 0, ilen = keys.length; i < ilen; ++i) key = keys[i], adata[i] = {
                    x: key,
                    y: data[key]
                };
                return adata
            }(data);
            else if (_data !== data) {
                if (_data) {
                    unlistenArrayEvents(_data, this);
                    const meta = this._cachedMeta;
                    clearStacks(meta), meta._parsed = []
                }
                data && Object.isExtensible(data) && (listener = this, (array = data)._chartjs ? array._chartjs.listeners.push(listener) : (Object.defineProperty(array, "_chartjs", {
                    configurable: !0,
                    enumerable: !1,
                    value: {
                        listeners: [listener]
                    }
                }), arrayEvents.forEach(key => {
                    const method = "_onData" + _capitalize(key),
                        base = array[key];
                    Object.defineProperty(array, key, {
                        configurable: !0,
                        enumerable: !1,
                        value(...args) {
                            const res = base.apply(this, args);
                            return array._chartjs.listeners.forEach(object => {
                                "function" == typeof object[method] && object[method](...args)
                            }), res
                        }
                    })
                }))), this._syncList = [], this._data = data
            }
            var array, listener
        }
        addElements() {
            const meta = this._cachedMeta;
            this._dataCheck(), this.datasetElementType && (meta.dataset = new this.datasetElementType)
        }
        buildOrUpdateElements(resetNewElements) {
            const meta = this._cachedMeta,
                dataset = this.getDataset();
            let stackChanged = !1;
            this._dataCheck();
            const oldStacked = meta._stacked;
            meta._stacked = isStacked(meta.vScale, meta), meta.stack !== dataset.stack && (stackChanged = !0, clearStacks(meta), meta.stack = dataset.stack), this._resyncElements(resetNewElements), (stackChanged || oldStacked !== meta._stacked) && updateStacks(this, meta._parsed)
        }
        configure() {
            const config = this.chart.config,
                scopeKeys = config.datasetScopeKeys(this._type),
                scopes = config.getOptionScopes(this.getDataset(), scopeKeys, !0);
            this.options = config.createResolver(scopes, this.getContext()), this._parsing = this.options.parsing
        }
        parse(start, count) {
            const {
                _cachedMeta: meta,
                _data: data
            } = this, {
                iScale: iScale,
                _stacked: _stacked
            } = meta, iAxis = iScale.axis;
            let i, cur, parsed, sorted = 0 === start && count === data.length || meta._sorted,
                prev = start > 0 && meta._parsed[start - 1];
            if (!1 === this._parsing) meta._parsed = data, meta._sorted = !0, parsed = data;
            else {
                parsed = isArray(data[start]) ? this.parseArrayData(meta, data, start, count) : isObject(data[start]) ? this.parseObjectData(meta, data, start, count) : this.parsePrimitiveData(meta, data, start, count);
                const isNotInOrderComparedToPrev = () => null === cur[iAxis] || prev && cur[iAxis] < prev[iAxis];
                for (i = 0; i < count; ++i) meta._parsed[i + start] = cur = parsed[i], sorted && (isNotInOrderComparedToPrev() && (sorted = !1), prev = cur);
                meta._sorted = sorted
            }
            _stacked && updateStacks(this, parsed)
        }
        parsePrimitiveData(meta, data, start, count) {
            const {
                iScale: iScale,
                vScale: vScale
            } = meta, iAxis = iScale.axis, vAxis = vScale.axis, labels = iScale.getLabels(), singleScale = iScale === vScale, parsed = new Array(count);
            let i, ilen, index;
            for (i = 0, ilen = count; i < ilen; ++i) index = i + start, parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index], index),
                [vAxis]: vScale.parse(data[index], index)
            };
            return parsed
        }
        parseArrayData(meta, data, start, count) {
            const {
                xScale: xScale,
                yScale: yScale
            } = meta, parsed = new Array(count);
            let i, ilen, index, item;
            for (i = 0, ilen = count; i < ilen; ++i) index = i + start, item = data[index], parsed[i] = {
                x: xScale.parse(item[0], index),
                y: yScale.parse(item[1], index)
            };
            return parsed
        }
        parseObjectData(meta, data, start, count) {
            const {
                xScale: xScale,
                yScale: yScale
            } = meta, {
                xAxisKey: xAxisKey = "x",
                yAxisKey: yAxisKey = "y"
            } = this._parsing, parsed = new Array(count);
            let i, ilen, index, item;
            for (i = 0, ilen = count; i < ilen; ++i) index = i + start, item = data[index], parsed[i] = {
                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
                y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
            };
            return parsed
        }
        getParsed(index) {
            return this._cachedMeta._parsed[index]
        }
        getDataElement(index) {
            return this._cachedMeta.data[index]
        }
        applyStack(scale, parsed, mode) {
            const chart = this.chart,
                meta = this._cachedMeta,
                value = parsed[scale.axis];
            return applyStack({
                keys: getSortedDatasetIndices(chart, !0),
                values: parsed._stacks[scale.axis]
            }, value, meta.index, {
                mode: mode
            })
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
            const parsedValue = parsed[scale.axis];
            let value = null === parsedValue ? NaN : parsedValue;
            const values = stack && parsed._stacks[scale.axis];
            stack && values && (stack.values = values, value = applyStack(stack, parsedValue, this._cachedMeta.index)), range.min = Math.min(range.min, value), range.max = Math.max(range.max, value)
        }
        getMinMax(scale, canStack) {
            const meta = this._cachedMeta,
                _parsed = meta._parsed,
                sorted = meta._sorted && scale === meta.iScale,
                ilen = _parsed.length,
                otherScale = this._getOtherScale(scale),
                stack = ((canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
                    keys: getSortedDatasetIndices(chart, !0),
                    values: null
                })(canStack, meta, this.chart),
                range = {
                    min: Number.POSITIVE_INFINITY,
                    max: Number.NEGATIVE_INFINITY
                },
                {
                    min: otherMin,
                    max: otherMax
                } = function (scale) {
                    const {
                        min: min,
                        max: max,
                        minDefined: minDefined,
                        maxDefined: maxDefined
                    } = scale.getUserBounds();
                    return {
                        min: minDefined ? min : Number.NEGATIVE_INFINITY,
                        max: maxDefined ? max : Number.POSITIVE_INFINITY
                    }
                }(otherScale);
            let i, parsed;

            function _skip() {
                parsed = _parsed[i];
                const otherValue = parsed[otherScale.axis];
                return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue
            }
            for (i = 0; i < ilen && (_skip() || (this.updateRangeFromParsed(range, scale, parsed, stack), !sorted)); ++i);
            if (sorted)
                for (i = ilen - 1; i >= 0; --i)
                    if (!_skip()) {
                        this.updateRangeFromParsed(range, scale, parsed, stack);
                        break
                    } return range
        }
        getAllParsedValues(scale) {
            const parsed = this._cachedMeta._parsed,
                values = [];
            let i, ilen, value;
            for (i = 0, ilen = parsed.length; i < ilen; ++i) value = parsed[i][scale.axis], isNumberFinite(value) && values.push(value);
            return values
        }
        getMaxOverflow() {
            return !1
        }
        getLabelAndValue(index) {
            const meta = this._cachedMeta,
                iScale = meta.iScale,
                vScale = meta.vScale,
                parsed = this.getParsed(index);
            return {
                label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
                value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
            }
        }
        _update(mode) {
            const meta = this._cachedMeta;
            this.configure(), this._cachedDataOpts = {}, this.update(mode || "default"), meta._clip = function (value) {
                let t, r, b, l;
                return isObject(value) ? (t = value.top, r = value.right, b = value.bottom, l = value.left) : t = r = b = l = value, {
                    top: t,
                    right: r,
                    bottom: b,
                    left: l,
                    disabled: !1 === value
                }
            }(valueOrDefault(this.options.clip, function (xScale, yScale, allowedOverflow) {
                if (!1 === allowedOverflow) return !1;
                const x = scaleClip(xScale, allowedOverflow),
                    y = scaleClip(yScale, allowedOverflow);
                return {
                    top: y.end,
                    right: x.end,
                    bottom: y.start,
                    left: x.start
                }
            }(meta.xScale, meta.yScale, this.getMaxOverflow())))
        }
        update(mode) { }
        draw() {
            const ctx = this._ctx,
                chart = this.chart,
                meta = this._cachedMeta,
                elements = meta.data || [],
                area = chart.chartArea,
                active = [],
                start = this._drawStart || 0,
                count = this._drawCount || elements.length - start;
            let i;
            for (meta.dataset && meta.dataset.draw(ctx, area, start, count), i = start; i < start + count; ++i) {
                const element = elements[i];
                element.hidden || (element.active ? active.push(element) : element.draw(ctx, area))
            }
            for (i = 0; i < active.length; ++i) active[i].draw(ctx, area)
        }
        getStyle(index, active) {
            const mode = active ? "active" : "default";
            return void 0 === index && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode)
        }
        getContext(index, active, mode) {
            const dataset = this.getDataset();
            let context;
            if (index >= 0 && index < this._cachedMeta.data.length) {
                const element = this._cachedMeta.data[index];
                context = element.$context || (element.$context = function (parent, index, element) {
                    return createContext(parent, {
                        active: !1,
                        dataIndex: index,
                        parsed: void 0,
                        raw: void 0,
                        element: element,
                        index: index,
                        mode: "default",
                        type: "data"
                    })
                }(this.getContext(), index, element)), context.parsed = this.getParsed(index), context.raw = dataset.data[index], context.index = context.dataIndex = index
            } else context = this.$context || (this.$context = function (parent, index) {
                return createContext(parent, {
                    active: !1,
                    dataset: void 0,
                    datasetIndex: index,
                    index: index,
                    mode: "default",
                    type: "dataset"
                })
            }(this.chart.getContext(), this.index)), context.dataset = dataset, context.index = context.datasetIndex = this.index;
            return context.active = !!active, context.mode = mode, context
        }
        resolveDatasetElementOptions(mode) {
            return this._resolveElementOptions(this.datasetElementType.id, mode)
        }
        resolveDataElementOptions(index, mode) {
            return this._resolveElementOptions(this.dataElementType.id, mode, index)
        }
        _resolveElementOptions(elementType, mode = "default", index) {
            const active = "active" === mode,
                cache = this._cachedDataOpts,
                cacheKey = elementType + "-" + mode,
                cached = cache[cacheKey],
                sharing = this.enableOptionSharing && defined(index);
            if (cached) return cloneIfNotShared(cached, sharing);
            const config = this.chart.config,
                scopeKeys = config.datasetElementScopeKeys(this._type, elementType),
                prefixes = active ? [elementType + "Hover", "hover", elementType, ""] : [elementType, ""],
                scopes = config.getOptionScopes(this.getDataset(), scopeKeys),
                names = Object.keys(defaults.elements[elementType]),
                values = config.resolveNamedOptions(scopes, names, () => this.getContext(index, active), prefixes);
            return values.$shared && (values.$shared = sharing, cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing))), values
        }
        _resolveAnimations(index, transition, active) {
            const chart = this.chart,
                cache = this._cachedDataOpts,
                cacheKey = "animation-" + transition,
                cached = cache[cacheKey];
            if (cached) return cached;
            let options;
            if (!1 !== chart.options.animation) {
                const config = this.chart.config,
                    scopeKeys = config.datasetAnimationScopeKeys(this._type, transition),
                    scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
                options = config.createResolver(scopes, this.getContext(index, active, transition))
            }
            const animations = new chart_esm_Animations(chart, options && options.animations);
            return options && options._cacheable && (cache[cacheKey] = Object.freeze(animations)), animations
        }
        getSharedOptions(options) {
            if (options.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, options))
        }
        includeOptions(mode, sharedOptions) {
            return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled
        }
        updateElement(element, index, properties, mode) {
            isDirectUpdateMode(mode) ? Object.assign(element, properties) : this._resolveAnimations(index, mode).update(element, properties)
        }
        updateSharedOptions(sharedOptions, mode, newOptions) {
            sharedOptions && !isDirectUpdateMode(mode) && this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions)
        }
        _setStyle(element, index, mode, active) {
            element.active = active;
            const options = this.getStyle(index, active);
            this._resolveAnimations(index, mode, active).update(element, {
                options: !active && this.getSharedOptions(options) || options
            })
        }
        removeHoverStyle(element, datasetIndex, index) {
            this._setStyle(element, index, "active", !1)
        }
        setHoverStyle(element, datasetIndex, index) {
            this._setStyle(element, index, "active", !0)
        }
        _removeDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            element && this._setStyle(element, void 0, "active", !1)
        }
        _setDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            element && this._setStyle(element, void 0, "active", !0)
        }
        _resyncElements(resetNewElements) {
            const data = this._data,
                elements = this._cachedMeta.data;
            for (const [method, arg1, arg2] of this._syncList) this[method](arg1, arg2);
            this._syncList = [];
            const numMeta = elements.length,
                numData = data.length,
                count = Math.min(numData, numMeta);
            count && this.parse(0, count), numData > numMeta ? this._insertElements(numMeta, numData - numMeta, resetNewElements) : numData < numMeta && this._removeElements(numData, numMeta - numData)
        }
        _insertElements(start, count, resetNewElements = !0) {
            const meta = this._cachedMeta,
                data = meta.data,
                end = start + count;
            let i;
            const move = arr => {
                for (arr.length += count, i = arr.length - 1; i >= end; i--) arr[i] = arr[i - count]
            };
            for (move(data), i = start; i < end; ++i) data[i] = new this.dataElementType;
            this._parsing && move(meta._parsed), this.parse(start, count), resetNewElements && this.updateElements(data, start, count, "reset")
        }
        updateElements(element, start, count, mode) { }
        _removeElements(start, count) {
            const meta = this._cachedMeta;
            if (this._parsing) {
                const removed = meta._parsed.splice(start, count);
                meta._stacked && clearStacks(meta, removed)
            }
            meta.data.splice(start, count)
        }
        _sync(args) {
            if (this._parsing) this._syncList.push(args);
            else {
                const [method, arg1, arg2] = args;
                this[method](arg1, arg2)
            }
        }
        _onDataPush() {
            const count = arguments.length;
            this._sync(["_insertElements", this.getDataset().data.length - count, count])
        }
        _onDataPop() {
            this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
        }
        _onDataShift() {
            this._sync(["_removeElements", 0, 1])
        }
        _onDataSplice(start, count) {
            this._sync(["_removeElements", start, count]), this._sync(["_insertElements", start, arguments.length - 2])
        }
        _onDataUnshift() {
            this._sync(["_insertElements", 0, arguments.length])
        }
    }

    function computeMinSampleSize(meta) {
        const scale = meta.iScale,
            values = function (scale, type) {
                if (!scale._cache.$bar) {
                    const visibleMetas = scale.getMatchingVisibleMetas(type);
                    let values = [];
                    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
                    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b))
                }
                return scale._cache.$bar
            }(scale, meta.type);
        let i, ilen, curr, prev, min = scale._length;
        const updateMinAndPrev = () => {
            32767 !== curr && -32768 !== curr && (defined(prev) && (min = Math.min(min, Math.abs(curr - prev) || min)), prev = curr)
        };
        for (i = 0, ilen = values.length; i < ilen; ++i) curr = scale.getPixelForValue(values[i]), updateMinAndPrev();
        for (prev = void 0, i = 0, ilen = scale.ticks.length; i < ilen; ++i) curr = scale.getPixelForTick(i), updateMinAndPrev();
        return min
    }

    function parseValue(entry, item, vScale, i) {
        return isArray(entry) ? function (entry, item, vScale, i) {
            const startValue = vScale.parse(entry[0], i),
                endValue = vScale.parse(entry[1], i),
                min = Math.min(startValue, endValue),
                max = Math.max(startValue, endValue);
            let barStart = min,
                barEnd = max;
            Math.abs(min) > Math.abs(max) && (barStart = max, barEnd = min), item[vScale.axis] = barEnd, item._custom = {
                barStart: barStart,
                barEnd: barEnd,
                start: startValue,
                end: endValue,
                min: min,
                max: max
            }
        }(entry, item, vScale, i) : item[vScale.axis] = vScale.parse(entry, i), item
    }

    function parseArrayOrPrimitive(meta, data, start, count) {
        const iScale = meta.iScale,
            vScale = meta.vScale,
            labels = iScale.getLabels(),
            singleScale = iScale === vScale,
            parsed = [];
        let i, ilen, item, entry;
        for (i = start, ilen = start + count; i < ilen; ++i) entry = data[i], item = {}, item[iScale.axis] = singleScale || iScale.parse(labels[i], i), parsed.push(parseValue(entry, item, vScale, i));
        return parsed
    }

    function isFloatBar(custom) {
        return custom && void 0 !== custom.barStart && void 0 !== custom.barEnd
    }

    function setBorderSkipped(properties, options, stack, index) {
        let edge = options.borderSkipped;
        const res = {};
        if (!edge) return void (properties.borderSkipped = res);
        const {
            start: start,
            end: end,
            reverse: reverse,
            top: top,
            bottom: bottom
        } = function (properties) {
            let reverse, start, end, top, bottom;
            return properties.horizontal ? (reverse = properties.base > properties.x, start = "left", end = "right") : (reverse = properties.base < properties.y, start = "bottom", end = "top"), reverse ? (top = "end", bottom = "start") : (top = "start", bottom = "end"), {
                start: start,
                end: end,
                reverse: reverse,
                top: top,
                bottom: bottom
            }
        }(properties);
        "middle" === edge && stack && (properties.enableBorderRadius = !0, (stack._top || 0) === index ? edge = top : (stack._bottom || 0) === index ? edge = bottom : (res[parseEdge(bottom, start, end, reverse)] = !0, edge = top)), res[parseEdge(edge, start, end, reverse)] = !0, properties.borderSkipped = res
    }

    function parseEdge(edge, a, b, reverse) {
        var orig, v1, v2;
        return reverse ? (v2 = b, edge = startEnd(edge = (orig = edge) === (v1 = a) ? v2 : orig === v2 ? v1 : orig, b, a)) : edge = startEnd(edge, a, b), edge
    }

    function startEnd(v, start, end) {
        return "start" === v ? start : "end" === v ? end : v
    }

    function setInflateAmount(properties, {
        inflateAmount: inflateAmount
    }, ratio) {
        properties.inflateAmount = "auto" === inflateAmount ? 1 === ratio ? .33 : 0 : inflateAmount
    }
    chart_esm_DatasetController.defaults = {}, chart_esm_DatasetController.prototype.datasetElementType = null, chart_esm_DatasetController.prototype.dataElementType = null;
    class chart_esm_BarController extends chart_esm_DatasetController {
        parsePrimitiveData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count)
        }
        parseArrayData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count)
        }
        parseObjectData(meta, data, start, count) {
            const {
                iScale: iScale,
                vScale: vScale
            } = meta, {
                xAxisKey: xAxisKey = "x",
                yAxisKey: yAxisKey = "y"
            } = this._parsing, iAxisKey = "x" === iScale.axis ? xAxisKey : yAxisKey, vAxisKey = "x" === vScale.axis ? xAxisKey : yAxisKey, parsed = [];
            let i, ilen, item, obj;
            for (i = start, ilen = start + count; i < ilen; ++i) obj = data[i], item = {}, item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i), parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
            return parsed
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
            super.updateRangeFromParsed(range, scale, parsed, stack);
            const custom = parsed._custom;
            custom && scale === this._cachedMeta.vScale && (range.min = Math.min(range.min, custom.min), range.max = Math.max(range.max, custom.max))
        }
        getMaxOverflow() {
            return 0
        }
        getLabelAndValue(index) {
            const meta = this._cachedMeta,
                {
                    iScale: iScale,
                    vScale: vScale
                } = meta,
                parsed = this.getParsed(index),
                custom = parsed._custom,
                value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
            return {
                label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
                value: value
            }
        }
        initialize() {
            this.enableOptionSharing = !0, super.initialize();
            this._cachedMeta.stack = this.getDataset().stack
        }
        update(mode) {
            const meta = this._cachedMeta;
            this.updateElements(meta.data, 0, meta.data.length, mode)
        }
        updateElements(bars, start, count, mode) {
            const reset = "reset" === mode,
                {
                    index: index,
                    _cachedMeta: {
                        vScale: vScale
                    }
                } = this,
                base = vScale.getBasePixel(),
                horizontal = vScale.isHorizontal(),
                ruler = this._getRuler(),
                firstOpts = this.resolveDataElementOptions(start, mode),
                sharedOptions = this.getSharedOptions(firstOpts),
                includeOptions = this.includeOptions(mode, sharedOptions);
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
            for (let i = start; i < start + count; i++) {
                const parsed = this.getParsed(i),
                    vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
                        base: base,
                        head: base
                    } : this._calculateBarValuePixels(i),
                    ipixels = this._calculateBarIndexPixels(i, ruler),
                    stack = (parsed._stacks || {})[vScale.axis],
                    properties = {
                        horizontal: horizontal,
                        base: vpixels.base,
                        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                        x: horizontal ? vpixels.head : ipixels.center,
                        y: horizontal ? ipixels.center : vpixels.head,
                        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
                    };
                includeOptions && (properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode));
                const options = properties.options || bars[i].options;
                setBorderSkipped(properties, options, stack, index), setInflateAmount(properties, options, ruler.ratio), this.updateElement(bars[i], i, properties, mode)
            }
        }
        _getStacks(last, dataIndex) {
            const iScale = this._cachedMeta.iScale,
                metasets = iScale.getMatchingVisibleMetas(this._type),
                stacked = iScale.options.stacked,
                ilen = metasets.length,
                stacks = [];
            let i, item;
            for (i = 0; i < ilen; ++i)
                if (item = metasets[i], item.controller.options.grouped) {
                    if (void 0 !== dataIndex) {
                        const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
                        if (isNullOrUndef(val) || isNaN(val)) continue
                    }
                    if ((!1 === stacked || -1 === stacks.indexOf(item.stack) || void 0 === stacked && void 0 === item.stack) && stacks.push(item.stack), item.index === last) break
                } return stacks.length || stacks.push(void 0), stacks
        }
        _getStackCount(index) {
            return this._getStacks(void 0, index).length
        }
        _getStackIndex(datasetIndex, name, dataIndex) {
            const stacks = this._getStacks(datasetIndex, dataIndex),
                index = void 0 !== name ? stacks.indexOf(name) : -1;
            return -1 === index ? stacks.length - 1 : index
        }
        _getRuler() {
            const opts = this.options,
                meta = this._cachedMeta,
                iScale = meta.iScale,
                pixels = [];
            let i, ilen;
            for (i = 0, ilen = meta.data.length; i < ilen; ++i) pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
            const barThickness = opts.barThickness;
            return {
                min: barThickness || computeMinSampleSize(meta),
                pixels: pixels,
                start: iScale._startPixel,
                end: iScale._endPixel,
                stackCount: this._getStackCount(),
                scale: iScale,
                grouped: opts.grouped,
                ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
            }
        }
        _calculateBarValuePixels(index) {
            const {
                _cachedMeta: {
                    vScale: vScale,
                    _stacked: _stacked
                },
                options: {
                    base: baseValue,
                    minBarLength: minBarLength
                }
            } = this, actualBase = baseValue || 0, parsed = this.getParsed(index), custom = parsed._custom, floating = isFloatBar(custom);
            let head, size, value = parsed[vScale.axis],
                start = 0,
                length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
            length !== value && (start = length - value, length = value), floating && (value = custom.barStart, length = custom.barEnd - custom.barStart, 0 !== value && sign(value) !== sign(custom.barEnd) && (start = 0), start += value);
            const startValue = isNullOrUndef(baseValue) || floating ? start : baseValue;
            let base = vScale.getPixelForValue(startValue);
            if (head = this.chart.getDataVisibility(index) ? vScale.getPixelForValue(start + length) : base, size = head - base, Math.abs(size) < minBarLength && (size = function (size, vScale, actualBase) {
                return 0 !== size ? sign(size) : (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1)
            }(size, vScale, actualBase) * minBarLength, value === actualBase && (base -= size / 2), head = base + size), base === vScale.getPixelForValue(actualBase)) {
                const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
                base += halfGrid, size -= halfGrid
            }
            return {
                size: size,
                base: base,
                head: head,
                center: head + size / 2
            }
        }
        _calculateBarIndexPixels(index, ruler) {
            const scale = ruler.scale,
                options = this.options,
                skipNull = options.skipNull,
                maxBarThickness = valueOrDefault(options.maxBarThickness, 1 / 0);
            let center, size;
            if (ruler.grouped) {
                const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount,
                    range = "flex" === options.barThickness ? function (index, ruler, options, stackCount) {
                        const pixels = ruler.pixels,
                            curr = pixels[index];
                        let prev = index > 0 ? pixels[index - 1] : null,
                            next = index < pixels.length - 1 ? pixels[index + 1] : null;
                        const percent = options.categoryPercentage;
                        null === prev && (prev = curr - (null === next ? ruler.end - ruler.start : next - curr)), null === next && (next = curr + curr - prev);
                        const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
                        return {
                            chunk: Math.abs(next - prev) / 2 * percent / stackCount,
                            ratio: options.barPercentage,
                            start: start
                        }
                    }(index, ruler, options, stackCount) : function (index, ruler, options, stackCount) {
                        const thickness = options.barThickness;
                        let size, ratio;
                        return isNullOrUndef(thickness) ? (size = ruler.min * options.categoryPercentage, ratio = options.barPercentage) : (size = thickness * stackCount, ratio = 1), {
                            chunk: size / stackCount,
                            ratio: ratio,
                            start: ruler.pixels[index] - size / 2
                        }
                    }(index, ruler, options, stackCount),
                    stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
                center = range.start + range.chunk * stackIndex + range.chunk / 2, size = Math.min(maxBarThickness, range.chunk * range.ratio)
            } else center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index), size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
            return {
                base: center - size / 2,
                head: center + size / 2,
                center: center,
                size: size
            }
        }
        draw() {
            const meta = this._cachedMeta,
                vScale = meta.vScale,
                rects = meta.data,
                ilen = rects.length;
            let i = 0;
            for (; i < ilen; ++i) null !== this.getParsed(i)[vScale.axis] && rects[i].draw(this._ctx)
        }
    }
    chart_esm_BarController.id = "bar", chart_esm_BarController.defaults = {
        datasetElementType: !1,
        dataElementType: "bar",
        categoryPercentage: .8,
        barPercentage: .9,
        grouped: !0,
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "base", "width", "height"]
            }
        }
    }, chart_esm_BarController.overrides = {
        scales: {
            _index_: {
                type: "category",
                offset: !0,
                grid: {
                    offset: !0
                }
            },
            _value_: {
                type: "linear",
                beginAtZero: !0
            }
        }
    };
    class chart_esm_BubbleController extends chart_esm_DatasetController {
        initialize() {
            this.enableOptionSharing = !0, super.initialize()
        }
        parsePrimitiveData(meta, data, start, count) {
            const parsed = super.parsePrimitiveData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
            return parsed
        }
        parseArrayData(meta, data, start, count) {
            const parsed = super.parseArrayData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
                const item = data[start + i];
                parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius)
            }
            return parsed
        }
        parseObjectData(meta, data, start, count) {
            const parsed = super.parseObjectData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
                const item = data[start + i];
                parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius)
            }
            return parsed
        }
        getMaxOverflow() {
            const data = this._cachedMeta.data;
            let max = 0;
            for (let i = data.length - 1; i >= 0; --i) max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            return max > 0 && max
        }
        getLabelAndValue(index) {
            const meta = this._cachedMeta,
                {
                    xScale: xScale,
                    yScale: yScale
                } = meta,
                parsed = this.getParsed(index),
                x = xScale.getLabelForValue(parsed.x),
                y = yScale.getLabelForValue(parsed.y),
                r = parsed._custom;
            return {
                label: meta.label,
                value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
            }
        }
        update(mode) {
            const points = this._cachedMeta.data;
            this.updateElements(points, 0, points.length, mode)
        }
        updateElements(points, start, count, mode) {
            const reset = "reset" === mode,
                {
                    iScale: iScale,
                    vScale: vScale
                } = this._cachedMeta,
                firstOpts = this.resolveDataElementOptions(start, mode),
                sharedOptions = this.getSharedOptions(firstOpts),
                includeOptions = this.includeOptions(mode, sharedOptions),
                iAxis = iScale.axis,
                vAxis = vScale.axis;
            for (let i = start; i < start + count; i++) {
                const point = points[i],
                    parsed = !reset && this.getParsed(i),
                    properties = {},
                    iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(.5) : iScale.getPixelForValue(parsed[iAxis]),
                    vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
                properties.skip = isNaN(iPixel) || isNaN(vPixel), includeOptions && (properties.options = this.resolveDataElementOptions(i, point.active ? "active" : mode), reset && (properties.options.radius = 0)), this.updateElement(point, i, properties, mode)
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts)
        }
        resolveDataElementOptions(index, mode) {
            const parsed = this.getParsed(index);
            let values = super.resolveDataElementOptions(index, mode);
            values.$shared && (values = Object.assign({}, values, {
                $shared: !1
            }));
            const radius = values.radius;
            return "active" !== mode && (values.radius = 0), values.radius += valueOrDefault(parsed && parsed._custom, radius), values
        }
    }
    chart_esm_BubbleController.id = "bubble", chart_esm_BubbleController.defaults = {
        datasetElementType: !1,
        dataElementType: "point",
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "borderWidth", "radius"]
            }
        }
    }, chart_esm_BubbleController.overrides = {
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        },
        plugins: {
            tooltip: {
                callbacks: {
                    title: () => ""
                }
            }
        }
    };
    class chart_esm_DoughnutController extends chart_esm_DatasetController {
        constructor(chart, datasetIndex) {
            super(chart, datasetIndex), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0
        }
        linkScales() { }
        parse(start, count) {
            const data = this.getDataset().data,
                meta = this._cachedMeta;
            if (!1 === this._parsing) meta._parsed = data;
            else {
                let i, ilen, getter = i => +data[i];
                if (isObject(data[start])) {
                    const {
                        key: key = "value"
                    } = this._parsing;
                    getter = i => +resolveObjectKey(data[i], key)
                }
                for (i = start, ilen = start + count; i < ilen; ++i) meta._parsed[i] = getter(i)
            }
        }
        _getRotation() {
            return toRadians(this.options.rotation - 90)
        }
        _getCircumference() {
            return toRadians(this.options.circumference)
        }
        _getRotationExtents() {
            let min = TAU,
                max = -TAU;
            for (let i = 0; i < this.chart.data.datasets.length; ++i)
                if (this.chart.isDatasetVisible(i)) {
                    const controller = this.chart.getDatasetMeta(i).controller,
                        rotation = controller._getRotation(),
                        circumference = controller._getCircumference();
                    min = Math.min(min, rotation), max = Math.max(max, rotation + circumference)
                } return {
                    rotation: min,
                    circumference: max - min
                }
        }
        update(mode) {
            const chart = this.chart,
                {
                    chartArea: chartArea
                } = chart,
                meta = this._cachedMeta,
                arcs = meta.data,
                spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing,
                maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0),
                cutout = Math.min((value = this.options.cutout, dimension = maxSize, "string" == typeof value && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension), 1);
            var value, dimension;
            const chartWeight = this._getRingWeight(this.index),
                {
                    circumference: circumference,
                    rotation: rotation
                } = this._getRotationExtents(),
                {
                    ratioX: ratioX,
                    ratioY: ratioY,
                    offsetX: offsetX,
                    offsetY: offsetY
                } = function (rotation, circumference, cutout) {
                    let ratioX = 1,
                        ratioY = 1,
                        offsetX = 0,
                        offsetY = 0;
                    if (circumference < TAU) {
                        const startAngle = rotation,
                            endAngle = startAngle + circumference,
                            startX = Math.cos(startAngle),
                            startY = Math.sin(startAngle),
                            endX = Math.cos(endAngle),
                            endY = Math.sin(endAngle),
                            calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, !0) ? 1 : Math.max(a, a * cutout, b, b * cutout),
                            calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, !0) ? -1 : Math.min(a, a * cutout, b, b * cutout),
                            maxX = calcMax(0, startX, endX),
                            maxY = calcMax(HALF_PI, startY, endY),
                            minX = calcMin(PI, startX, endX),
                            minY = calcMin(PI + HALF_PI, startY, endY);
                        ratioX = (maxX - minX) / 2, ratioY = (maxY - minY) / 2, offsetX = -(maxX + minX) / 2, offsetY = -(maxY + minY) / 2
                    }
                    return {
                        ratioX: ratioX,
                        ratioY: ratioY,
                        offsetX: offsetX,
                        offsetY: offsetY
                    }
                }(rotation, circumference, cutout),
                maxWidth = (chartArea.width - spacing) / ratioX,
                maxHeight = (chartArea.height - spacing) / ratioY,
                maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0),
                outerRadius = toDimension(this.options.radius, maxRadius),
                radiusLength = (outerRadius - Math.max(outerRadius * cutout, 0)) / this._getVisibleDatasetWeightTotal();
            this.offsetX = offsetX * outerRadius, this.offsetY = offsetY * outerRadius, meta.total = this.calculateTotal(), this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0), this.updateElements(arcs, 0, arcs.length, mode)
        }
        _circumference(i, reset) {
            const opts = this.options,
                meta = this._cachedMeta,
                circumference = this._getCircumference();
            return reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || null === meta._parsed[i] || meta.data[i].hidden ? 0 : this.calculateCircumference(meta._parsed[i] * circumference / TAU)
        }
        updateElements(arcs, start, count, mode) {
            const reset = "reset" === mode,
                chart = this.chart,
                chartArea = chart.chartArea,
                animationOpts = chart.options.animation,
                centerX = (chartArea.left + chartArea.right) / 2,
                centerY = (chartArea.top + chartArea.bottom) / 2,
                animateScale = reset && animationOpts.animateScale,
                innerRadius = animateScale ? 0 : this.innerRadius,
                outerRadius = animateScale ? 0 : this.outerRadius,
                firstOpts = this.resolveDataElementOptions(start, mode),
                sharedOptions = this.getSharedOptions(firstOpts),
                includeOptions = this.includeOptions(mode, sharedOptions);
            let i, startAngle = this._getRotation();
            for (i = 0; i < start; ++i) startAngle += this._circumference(i, reset);
            for (i = start; i < start + count; ++i) {
                const circumference = this._circumference(i, reset),
                    arc = arcs[i],
                    properties = {
                        x: centerX + this.offsetX,
                        y: centerY + this.offsetY,
                        startAngle: startAngle,
                        endAngle: startAngle + circumference,
                        circumference: circumference,
                        outerRadius: outerRadius,
                        innerRadius: innerRadius
                    };
                includeOptions && (properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode)), startAngle += circumference, this.updateElement(arc, i, properties, mode)
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts)
        }
        calculateTotal() {
            const meta = this._cachedMeta,
                metaData = meta.data;
            let i, total = 0;
            for (i = 0; i < metaData.length; i++) {
                const value = meta._parsed[i];
                null === value || isNaN(value) || !this.chart.getDataVisibility(i) || metaData[i].hidden || (total += Math.abs(value))
            }
            return total
        }
        calculateCircumference(value) {
            const total = this._cachedMeta.total;
            return total > 0 && !isNaN(value) ? TAU * (Math.abs(value) / total) : 0
        }
        getLabelAndValue(index) {
            const meta = this._cachedMeta,
                chart = this.chart,
                labels = chart.data.labels || [],
                value = formatNumber(meta._parsed[index], chart.options.locale);
            return {
                label: labels[index] || "",
                value: value
            }
        }
        getMaxBorderWidth(arcs) {
            let max = 0;
            const chart = this.chart;
            let i, ilen, meta, controller, options;
            if (!arcs)
                for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i)
                    if (chart.isDatasetVisible(i)) {
                        meta = chart.getDatasetMeta(i), arcs = meta.data, controller = meta.controller, controller !== this && controller.configure();
                        break
                    } if (!arcs) return 0;
            for (i = 0, ilen = arcs.length; i < ilen; ++i) options = controller.resolveDataElementOptions(i), "inner" !== options.borderAlign && (max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0));
            return max
        }
        getMaxOffset(arcs) {
            let max = 0;
            for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
                const options = this.resolveDataElementOptions(i);
                max = Math.max(max, options.offset || 0, options.hoverOffset || 0)
            }
            return max
        }
        _getRingWeightOffset(datasetIndex) {
            let ringWeightOffset = 0;
            for (let i = 0; i < datasetIndex; ++i) this.chart.isDatasetVisible(i) && (ringWeightOffset += this._getRingWeight(i));
            return ringWeightOffset
        }
        _getRingWeight(datasetIndex) {
            return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0)
        }
        _getVisibleDatasetWeightTotal() {
            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
        }
    }
    chart_esm_DoughnutController.id = "doughnut", chart_esm_DoughnutController.defaults = {
        datasetElementType: !1,
        dataElementType: "arc",
        animation: {
            animateRotate: !0,
            animateScale: !1
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
            }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
    }, chart_esm_DoughnutController.descriptors = {
        _scriptable: name => "spacing" !== name,
        _indexable: name => "spacing" !== name
    }, chart_esm_DoughnutController.overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const {
                                labels: {
                                    pointStyle: pointStyle
                                }
                            } = chart.legend.options;
                            return data.labels.map((label, i) => {
                                const style = chart.getDatasetMeta(0).controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                }
                            })
                        }
                        return []
                    }
                },
                onClick(e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index), legend.chart.update()
                }
            },
            tooltip: {
                callbacks: {
                    title: () => "",
                    label(tooltipItem) {
                        let dataLabel = tooltipItem.label;
                        const value = ": " + tooltipItem.formattedValue;
                        return isArray(dataLabel) ? (dataLabel = dataLabel.slice(), dataLabel[0] += value) : dataLabel += value, dataLabel
                    }
                }
            }
        }
    };
    class chart_esm_LineController extends chart_esm_DatasetController {
        initialize() {
            this.enableOptionSharing = !0, super.initialize()
        }
        update(mode) {
            const meta = this._cachedMeta,
                {
                    dataset: line,
                    data: points = [],
                    _dataset: _dataset
                } = meta,
                animationsDisabled = this.chart._animationsDisabled;
            let {
                start: start,
                count: count
            } = function (meta, points, animationsDisabled) {
                const pointCount = points.length;
                let start = 0,
                    count = pointCount;
                if (meta._sorted) {
                    const {
                        iScale: iScale,
                        _parsed: _parsed
                    } = meta, axis = iScale.axis, {
                        min: min,
                        max: max,
                        minDefined: minDefined,
                        maxDefined: maxDefined
                    } = iScale.getUserBounds();
                    minDefined && (start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1)), count = maxDefined ? _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start : pointCount - start
                }
                return {
                    start: start,
                    count: count
                }
            }(meta, points, animationsDisabled);
            this._drawStart = start, this._drawCount = count,
                function (meta) {
                    const {
                        xScale: xScale,
                        yScale: yScale,
                        _scaleRanges: _scaleRanges
                    } = meta, newRanges = {
                        xmin: xScale.min,
                        xmax: xScale.max,
                        ymin: yScale.min,
                        ymax: yScale.max
                    };
                    if (!_scaleRanges) return meta._scaleRanges = newRanges, !0;
                    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
                    return Object.assign(_scaleRanges, newRanges), changed
                }(meta) && (start = 0, count = points.length), line._chart = this.chart, line._datasetIndex = this.index, line._decimated = !!_dataset._decimated, line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            this.options.showLine || (options.borderWidth = 0), options.segment = this.options.segment, this.updateElement(line, void 0, {
                animated: !animationsDisabled,
                options: options
            }, mode), this.updateElements(points, start, count, mode)
        }
        updateElements(points, start, count, mode) {
            const reset = "reset" === mode,
                {
                    iScale: iScale,
                    vScale: vScale,
                    _stacked: _stacked,
                    _dataset: _dataset
                } = this._cachedMeta,
                firstOpts = this.resolveDataElementOptions(start, mode),
                sharedOptions = this.getSharedOptions(firstOpts),
                includeOptions = this.includeOptions(mode, sharedOptions),
                iAxis = iScale.axis,
                vAxis = vScale.axis,
                {
                    spanGaps: spanGaps,
                    segment: segment
                } = this.options,
                maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY,
                directUpdate = this.chart._animationsDisabled || reset || "none" === mode;
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
                const point = points[i],
                    parsed = this.getParsed(i),
                    properties = directUpdate ? point : {},
                    nullData = isNullOrUndef(parsed[vAxis]),
                    iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i),
                    vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
                properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData, properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength, segment && (properties.parsed = parsed, properties.raw = _dataset.data[i]), includeOptions && (properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode)), directUpdate || this.updateElement(point, i, properties, mode), prevParsed = parsed
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts)
        }
        getMaxOverflow() {
            const meta = this._cachedMeta,
                dataset = meta.dataset,
                border = dataset.options && dataset.options.borderWidth || 0,
                data = meta.data || [];
            if (!data.length) return border;
            const firstPoint = data[0].size(this.resolveDataElementOptions(0)),
                lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2
        }
        draw() {
            const meta = this._cachedMeta;
            meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis), super.draw()
        }
    }
    chart_esm_LineController.id = "line", chart_esm_LineController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: !0,
        spanGaps: !1
    }, chart_esm_LineController.overrides = {
        scales: {
            _index_: {
                type: "category"
            },
            _value_: {
                type: "linear"
            }
        }
    };
    class chart_esm_PolarAreaController extends chart_esm_DatasetController {
        constructor(chart, datasetIndex) {
            super(chart, datasetIndex), this.innerRadius = void 0, this.outerRadius = void 0
        }
        getLabelAndValue(index) {
            const meta = this._cachedMeta,
                chart = this.chart,
                labels = chart.data.labels || [],
                value = formatNumber(meta._parsed[index].r, chart.options.locale);
            return {
                label: labels[index] || "",
                value: value
            }
        }
        update(mode) {
            const arcs = this._cachedMeta.data;
            this._updateRadius(), this.updateElements(arcs, 0, arcs.length, mode)
        }
        _updateRadius() {
            const chart = this.chart,
                chartArea = chart.chartArea,
                opts = chart.options,
                minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top),
                outerRadius = Math.max(minSize / 2, 0),
                radiusLength = (outerRadius - Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0)) / chart.getVisibleDatasetCount();
            this.outerRadius = outerRadius - radiusLength * this.index, this.innerRadius = this.outerRadius - radiusLength
        }
        updateElements(arcs, start, count, mode) {
            const reset = "reset" === mode,
                chart = this.chart,
                dataset = this.getDataset(),
                animationOpts = chart.options.animation,
                scale = this._cachedMeta.rScale,
                centerX = scale.xCenter,
                centerY = scale.yCenter,
                datasetStartAngle = scale.getIndexAngle(0) - .5 * PI;
            let i, angle = datasetStartAngle;
            const defaultAngle = 360 / this.countVisibleElements();
            for (i = 0; i < start; ++i) angle += this._computeAngle(i, mode, defaultAngle);
            for (i = start; i < start + count; i++) {
                const arc = arcs[i];
                let startAngle = angle,
                    endAngle = angle + this._computeAngle(i, mode, defaultAngle),
                    outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
                angle = endAngle, reset && (animationOpts.animateScale && (outerRadius = 0), animationOpts.animateRotate && (startAngle = endAngle = datasetStartAngle));
                const properties = {
                    x: centerX,
                    y: centerY,
                    innerRadius: 0,
                    outerRadius: outerRadius,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
                };
                this.updateElement(arc, i, properties, mode)
            }
        }
        countVisibleElements() {
            const dataset = this.getDataset(),
                meta = this._cachedMeta;
            let count = 0;
            return meta.data.forEach((element, index) => {
                !isNaN(dataset.data[index]) && this.chart.getDataVisibility(index) && count++
            }), count
        }
        _computeAngle(index, mode, defaultAngle) {
            return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0
        }
    }
    chart_esm_PolarAreaController.id = "polarArea", chart_esm_PolarAreaController.defaults = {
        dataElementType: "arc",
        animation: {
            animateRotate: !0,
            animateScale: !0
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
            }
        },
        indexAxis: "r",
        startAngle: 0
    }, chart_esm_PolarAreaController.overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const {
                                labels: {
                                    pointStyle: pointStyle
                                }
                            } = chart.legend.options;
                            return data.labels.map((label, i) => {
                                const style = chart.getDatasetMeta(0).controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                }
                            })
                        }
                        return []
                    }
                },
                onClick(e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index), legend.chart.update()
                }
            },
            tooltip: {
                callbacks: {
                    title: () => "",
                    label: context => context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue
                }
            }
        },
        scales: {
            r: {
                type: "radialLinear",
                angleLines: {
                    display: !1
                },
                beginAtZero: !0,
                grid: {
                    circular: !0
                },
                pointLabels: {
                    display: !1
                },
                startAngle: 0
            }
        }
    };
    class PieController extends chart_esm_DoughnutController { }
    PieController.id = "pie", PieController.defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
    };
    class RadarController extends chart_esm_DatasetController {
        getLabelAndValue(index) {
            const vScale = this._cachedMeta.vScale,
                parsed = this.getParsed(index);
            return {
                label: vScale.getLabels()[index],
                value: "" + vScale.getLabelForValue(parsed[vScale.axis])
            }
        }
        update(mode) {
            const meta = this._cachedMeta,
                line = meta.dataset,
                points = meta.data || [],
                labels = meta.iScale.getLabels();
            if (line.points = points, "resize" !== mode) {
                const options = this.resolveDatasetElementOptions(mode);
                this.options.showLine || (options.borderWidth = 0);
                const properties = {
                    _loop: !0,
                    _fullLoop: labels.length === points.length,
                    options: options
                };
                this.updateElement(line, void 0, properties, mode)
            }
            this.updateElements(points, 0, points.length, mode)
        }
        updateElements(points, start, count, mode) {
            const dataset = this.getDataset(),
                scale = this._cachedMeta.rScale,
                reset = "reset" === mode;
            for (let i = start; i < start + count; i++) {
                const point = points[i],
                    options = this.resolveDataElementOptions(i, point.active ? "active" : mode),
                    pointPosition = scale.getPointPositionForValue(i, dataset.data[i]),
                    x = reset ? scale.xCenter : pointPosition.x,
                    y = reset ? scale.yCenter : pointPosition.y,
                    properties = {
                        x: x,
                        y: y,
                        angle: pointPosition.angle,
                        skip: isNaN(x) || isNaN(y),
                        options: options
                    };
                this.updateElement(point, i, properties, mode)
            }
        }
    }
    RadarController.id = "radar", RadarController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: !0,
        elements: {
            line: {
                fill: "start"
            }
        }
    }, RadarController.overrides = {
        aspectRatio: 1,
        scales: {
            r: {
                type: "radialLinear"
            }
        }
    };
    class ScatterController extends chart_esm_LineController { }
    ScatterController.id = "scatter", ScatterController.defaults = {
        showLine: !1,
        fill: !1
    }, ScatterController.overrides = {
        interaction: {
            mode: "point"
        },
        plugins: {
            tooltip: {
                callbacks: {
                    title: () => "",
                    label: item => "(" + item.label + ", " + item.formattedValue + ")"
                }
            }
        },
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        }
    };

    function chart_esm_abstract() {
        throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
    }
    class DateAdapter {
        constructor(options) {
            this.options = options || {}
        }
        formats() {
            return chart_esm_abstract()
        }
        parse(value, format) {
            return chart_esm_abstract()
        }
        format(timestamp, format) {
            return chart_esm_abstract()
        }
        add(timestamp, amount, unit) {
            return chart_esm_abstract()
        }
        diff(a, b, unit) {
            return chart_esm_abstract()
        }
        startOf(timestamp, unit, weekday) {
            return chart_esm_abstract()
        }
        endOf(timestamp, unit) {
            return chart_esm_abstract()
        }
    }
    DateAdapter.override = function (members) {
        Object.assign(DateAdapter.prototype, members)
    };
    var adapters = {
        _date: DateAdapter
    };

    function chart_esm_getRelativePosition(e, chart) {
        return "native" in e ? {
            x: e.x,
            y: e.y
        } : getRelativePosition(e, chart)
    }

    function binarySearch(metaset, axis, value, intersect) {
        const {
            controller: controller,
            data: data,
            _sorted: _sorted
        } = metaset, iScale = controller._cachedMeta.iScale;
        if (iScale && axis === iScale.axis && _sorted && data.length) {
            const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
            if (!intersect) return lookupMethod(data, axis, value);
            if (controller._sharedOptions) {
                const el = data[0],
                    range = "function" == typeof el.getRange && el.getRange(axis);
                if (range) {
                    const start = lookupMethod(data, axis, value - range),
                        end = lookupMethod(data, axis, value + range);
                    return {
                        lo: start.lo,
                        hi: end.hi
                    }
                }
            }
        }
        return {
            lo: 0,
            hi: data.length - 1
        }
    }

    function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
        const metasets = chart.getSortedVisibleDatasetMetas(),
            value = position[axis];
        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
            const {
                index: index,
                data: data
            } = metasets[i], {
                lo: lo,
                hi: hi
            } = binarySearch(metasets[i], axis, value, intersect);
            for (let j = lo; j <= hi; ++j) {
                const element = data[j];
                element.skip || handler(element, index, j)
            }
        }
    }

    function getIntersectItems(chart, position, axis, useFinalPosition) {
        const items = [];
        if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) return items;
        return optimizedEvaluateItems(chart, axis, position, (function (element, datasetIndex, index) {
            element.inRange(position.x, position.y, useFinalPosition) && items.push({
                element: element,
                datasetIndex: datasetIndex,
                index: index
            })
        }), !0), items
    }

    function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
        const distanceMetric = function (axis) {
            const useX = -1 !== axis.indexOf("x"),
                useY = -1 !== axis.indexOf("y");
            return function (pt1, pt2) {
                const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0,
                    deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
                return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2))
            }
        }(axis);
        let minDistance = Number.POSITIVE_INFINITY,
            items = [];
        if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) return items;
        return optimizedEvaluateItems(chart, axis, position, (function (element, datasetIndex, index) {
            if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) return;
            const center = element.getCenterPoint(useFinalPosition);
            if (!_isPointInArea(center, chart.chartArea, chart._minPadding) && !element.inRange(position.x, position.y, useFinalPosition)) return;
            const distance = distanceMetric(position, center);
            distance < minDistance ? (items = [{
                element: element,
                datasetIndex: datasetIndex,
                index: index
            }], minDistance = distance) : distance === minDistance && items.push({
                element: element,
                datasetIndex: datasetIndex,
                index: index
            })
        })), items
    }

    function getAxisItems(chart, e, options, useFinalPosition) {
        const position = chart_esm_getRelativePosition(e, chart),
            items = [],
            axis = options.axis,
            rangeMethod = "x" === axis ? "inXRange" : "inYRange";
        let intersectsItem = !1;
        return function (chart, handler) {
            const metasets = chart.getSortedVisibleDatasetMetas();
            let index, data, element;
            for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
                ({
                    index: index,
                    data: data
                } = metasets[i]);
                for (let j = 0, jlen = data.length; j < jlen; ++j) element = data[j], element.skip || handler(element, index, j)
            }
        }(chart, (element, datasetIndex, index) => {
            element[rangeMethod](position[axis], useFinalPosition) && items.push({
                element: element,
                datasetIndex: datasetIndex,
                index: index
            }), element.inRange(position.x, position.y, useFinalPosition) && (intersectsItem = !0)
        }), options.intersect && !intersectsItem ? [] : items
    }
    var Interaction = {
        modes: {
            index(chart, e, options, useFinalPosition) {
                const position = chart_esm_getRelativePosition(e, chart),
                    axis = options.axis || "x",
                    items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, !1, useFinalPosition),
                    elements = [];
                return items.length ? (chart.getSortedVisibleDatasetMetas().forEach(meta => {
                    const index = items[0].index,
                        element = meta.data[index];
                    element && !element.skip && elements.push({
                        element: element,
                        datasetIndex: meta.index,
                        index: index
                    })
                }), elements) : []
            },
            dataset(chart, e, options, useFinalPosition) {
                const position = chart_esm_getRelativePosition(e, chart),
                    axis = options.axis || "xy";
                let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, !1, useFinalPosition);
                if (items.length > 0) {
                    const datasetIndex = items[0].datasetIndex,
                        data = chart.getDatasetMeta(datasetIndex).data;
                    items = [];
                    for (let i = 0; i < data.length; ++i) items.push({
                        element: data[i],
                        datasetIndex: datasetIndex,
                        index: i
                    })
                }
                return items
            },
            point: (chart, e, options, useFinalPosition) => getIntersectItems(chart, chart_esm_getRelativePosition(e, chart), options.axis || "xy", useFinalPosition),
            nearest: (chart, e, options, useFinalPosition) => getNearestItems(chart, chart_esm_getRelativePosition(e, chart), options.axis || "xy", options.intersect, useFinalPosition),
            x: (chart, e, options, useFinalPosition) => (options.axis = "x", getAxisItems(chart, e, options, useFinalPosition)),
            y: (chart, e, options, useFinalPosition) => (options.axis = "y", getAxisItems(chart, e, options, useFinalPosition))
        }
    };
    const STATIC_POSITIONS = ["left", "top", "right", "bottom"];

    function filterByPosition(array, position) {
        return array.filter(v => v.pos === position)
    }

    function filterDynamicPositionByAxis(array, axis) {
        return array.filter(v => -1 === STATIC_POSITIONS.indexOf(v.pos) && v.box.axis === axis)
    }

    function sortByWeight(array, reverse) {
        return array.sort((a, b) => {
            const v0 = reverse ? b : a,
                v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight
        })
    }

    function setLayoutDims(layouts, params) {
        const stacks = function (layouts) {
            const stacks = {};
            for (const wrap of layouts) {
                const {
                    stack: stack,
                    pos: pos,
                    stackWeight: stackWeight
                } = wrap;
                if (!stack || !STATIC_POSITIONS.includes(pos)) continue;
                const _stack = stacks[stack] || (stacks[stack] = {
                    count: 0,
                    placed: 0,
                    weight: 0,
                    size: 0
                });
                _stack.count++, _stack.weight += stackWeight
            }
            return stacks
        }(layouts),
            {
                vBoxMaxWidth: vBoxMaxWidth,
                hBoxMaxHeight: hBoxMaxHeight
            } = params;
        let i, ilen, layout;
        for (i = 0, ilen = layouts.length; i < ilen; ++i) {
            layout = layouts[i];
            const {
                fullSize: fullSize
            } = layout.box, stack = stacks[layout.stack], factor = stack && layout.stackWeight / stack.weight;
            layout.horizontal ? (layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth, layout.height = hBoxMaxHeight) : (layout.width = vBoxMaxWidth, layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight)
        }
        return stacks
    }

    function getCombinedMax(maxPadding, chartArea, a, b) {
        return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b])
    }

    function updateMaxPadding(maxPadding, boxPadding) {
        maxPadding.top = Math.max(maxPadding.top, boxPadding.top), maxPadding.left = Math.max(maxPadding.left, boxPadding.left), maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom), maxPadding.right = Math.max(maxPadding.right, boxPadding.right)
    }

    function updateDims(chartArea, params, layout, stacks) {
        const {
            pos: pos,
            box: box
        } = layout, maxPadding = chartArea.maxPadding;
        if (!isObject(pos)) {
            layout.size && (chartArea[pos] -= layout.size);
            const stack = stacks[layout.stack] || {
                size: 0,
                count: 1
            };
            stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width), layout.size = stack.size / stack.count, chartArea[pos] += layout.size
        }
        box.getPadding && updateMaxPadding(maxPadding, box.getPadding());
        const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right")),
            newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom")),
            widthChanged = newWidth !== chartArea.w,
            heightChanged = newHeight !== chartArea.h;
        return chartArea.w = newWidth, chartArea.h = newHeight, layout.horizontal ? {
            same: widthChanged,
            other: heightChanged
        } : {
            same: heightChanged,
            other: widthChanged
        }
    }

    function getMargins(horizontal, chartArea) {
        const maxPadding = chartArea.maxPadding;

        function marginForPositions(positions) {
            const margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            };
            return positions.forEach(pos => {
                margin[pos] = Math.max(chartArea[pos], maxPadding[pos])
            }), margin
        }
        return marginForPositions(horizontal ? ["left", "right"] : ["top", "bottom"])
    }

    function fitBoxes(boxes, chartArea, params, stacks) {
        const refitBoxes = [];
        let i, ilen, layout, box, refit, changed;
        for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
            layout = boxes[i], box = layout.box, box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
            const {
                same: same,
                other: other
            } = updateDims(chartArea, params, layout, stacks);
            refit |= same && refitBoxes.length, changed = changed || other, box.fullSize || refitBoxes.push(layout)
        }
        return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed
    }

    function setBoxDims(box, left, top, width, height) {
        box.top = top, box.left = left, box.right = left + width, box.bottom = top + height, box.width = width, box.height = height
    }

    function placeBoxes(boxes, chartArea, params, stacks) {
        const userPadding = params.padding;
        let {
            x: x,
            y: y
        } = chartArea;
        for (const layout of boxes) {
            const box = layout.box,
                stack = stacks[layout.stack] || {
                    count: 1,
                    placed: 0,
                    weight: 1
                },
                weight = layout.stackWeight / stack.weight || 1;
            if (layout.horizontal) {
                const width = chartArea.w * weight,
                    height = stack.size || box.height;
                defined(stack.start) && (y = stack.start), box.fullSize ? setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height) : setBoxDims(box, chartArea.left + stack.placed, y, width, height), stack.start = y, stack.placed += width, y = box.bottom
            } else {
                const height = chartArea.h * weight,
                    width = stack.size || box.width;
                defined(stack.start) && (x = stack.start), box.fullSize ? setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top) : setBoxDims(box, x, chartArea.top + stack.placed, width, height), stack.start = x, stack.placed += height, x = box.right
            }
        }
        chartArea.x = x, chartArea.y = y
    }
    defaults.set("layout", {
        autoPadding: !0,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    });
    var layouts = {
        addBox(chart, item) {
            chart.boxes || (chart.boxes = []), item.fullSize = item.fullSize || !1, item.position = item.position || "top", item.weight = item.weight || 0, item._layers = item._layers || function () {
                return [{
                    z: 0,
                    draw(chartArea) {
                        item.draw(chartArea)
                    }
                }]
            }, chart.boxes.push(item)
        },
        removeBox(chart, layoutItem) {
            const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1; - 1 !== index && chart.boxes.splice(index, 1)
        },
        configure(chart, item, options) {
            item.fullSize = options.fullSize, item.position = options.position, item.weight = options.weight
        },
        update(chart, width, height, minPadding) {
            if (!chart) return;
            const padding = toPadding(chart.options.layout.padding),
                availableWidth = Math.max(width - padding.width, 0),
                availableHeight = Math.max(height - padding.height, 0),
                boxes = function (boxes) {
                    const layoutBoxes = function (boxes) {
                        const layoutBoxes = [];
                        let i, ilen, box, pos, stack, stackWeight;
                        for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) box = boxes[i], ({
                            position: pos,
                            options: {
                                stack: stack,
                                stackWeight: stackWeight = 1
                            }
                        } = box), layoutBoxes.push({
                            index: i,
                            box: box,
                            pos: pos,
                            horizontal: box.isHorizontal(),
                            weight: box.weight,
                            stack: stack && pos + stack,
                            stackWeight: stackWeight
                        });
                        return layoutBoxes
                    }(boxes),
                        fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), !0),
                        left = sortByWeight(filterByPosition(layoutBoxes, "left"), !0),
                        right = sortByWeight(filterByPosition(layoutBoxes, "right")),
                        top = sortByWeight(filterByPosition(layoutBoxes, "top"), !0),
                        bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom")),
                        centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x"),
                        centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
                    return {
                        fullSize: fullSize,
                        leftAndTop: left.concat(top),
                        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
                        chartArea: filterByPosition(layoutBoxes, "chartArea"),
                        vertical: left.concat(right).concat(centerVertical),
                        horizontal: top.concat(bottom).concat(centerHorizontal)
                    }
                }(chart.boxes),
                verticalBoxes = boxes.vertical,
                horizontalBoxes = boxes.horizontal;
            each(chart.boxes, box => {
                "function" == typeof box.beforeLayout && box.beforeLayout()
            });
            const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && !1 === wrap.box.options.display ? total : total + 1, 0) || 1,
                params = Object.freeze({
                    outerWidth: width,
                    outerHeight: height,
                    padding: padding,
                    availableWidth: availableWidth,
                    availableHeight: availableHeight,
                    vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
                    hBoxMaxHeight: availableHeight / 2
                }),
                maxPadding = Object.assign({}, padding);
            updateMaxPadding(maxPadding, toPadding(minPadding));
            const chartArea = Object.assign({
                maxPadding: maxPadding,
                w: availableWidth,
                h: availableHeight,
                x: padding.left,
                y: padding.top
            }, padding),
                stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(boxes.fullSize, chartArea, params, stacks), fitBoxes(verticalBoxes, chartArea, params, stacks), fitBoxes(horizontalBoxes, chartArea, params, stacks) && fitBoxes(verticalBoxes, chartArea, params, stacks),
                function (chartArea) {
                    const maxPadding = chartArea.maxPadding;

                    function updatePos(pos) {
                        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
                        return chartArea[pos] += change, change
                    }
                    chartArea.y += updatePos("top"), chartArea.x += updatePos("left"), updatePos("right"), updatePos("bottom")
                }(chartArea), placeBoxes(boxes.leftAndTop, chartArea, params, stacks), chartArea.x += chartArea.w, chartArea.y += chartArea.h, placeBoxes(boxes.rightAndBottom, chartArea, params, stacks), chart.chartArea = {
                    left: chartArea.left,
                    top: chartArea.top,
                    right: chartArea.left + chartArea.w,
                    bottom: chartArea.top + chartArea.h,
                    height: chartArea.h,
                    width: chartArea.w
                }, each(boxes.chartArea, layout => {
                    const box = layout.box;
                    Object.assign(box, chart.chartArea), box.update(chartArea.w, chartArea.h)
                })
        }
    };
    class BasePlatform {
        acquireContext(canvas, aspectRatio) { }
        releaseContext(context) {
            return !1
        }
        addEventListener(chart, type, listener) { }
        removeEventListener(chart, type, listener) { }
        getDevicePixelRatio() {
            return 1
        }
        getMaximumSize(element, width, height, aspectRatio) {
            return width = Math.max(0, width || element.width), height = height || element.height, {
                width: width,
                height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
            }
        }
        isAttached(canvas) {
            return !0
        }
        updateConfig(config) { }
    }
    class BasicPlatform extends BasePlatform {
        acquireContext(item) {
            return item && item.getContext && item.getContext("2d") || null
        }
        updateConfig(config) {
            config.options.animation = !1
        }
    }
    const EVENT_TYPES = {
        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup",
        pointerenter: "mouseenter",
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointerleave: "mouseout",
        pointerout: "mouseout"
    },
        isNullOrEmpty = value => null === value || "" === value;
    const eventListenerOptions = !!supportsEventListenerOptions && {
        passive: !0
    };

    function removeListener(chart, type, listener) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions)
    }

    function createAttachObserver(chart, type, listener) {
        const canvas = chart.canvas,
            observer = new MutationObserver(entries => {
                for (const entry of entries)
                    for (const node of entry.addedNodes)
                        if (node === canvas || node.contains(canvas)) return listener()
            });
        return observer.observe(document, {
            childList: !0,
            subtree: !0
        }), observer
    }

    function createDetachObserver(chart, type, listener) {
        const canvas = chart.canvas,
            observer = new MutationObserver(entries => {
                for (const entry of entries)
                    for (const node of entry.removedNodes)
                        if (node === canvas || node.contains(canvas)) return listener()
            });
        return observer.observe(document, {
            childList: !0,
            subtree: !0
        }), observer
    }
    const drpListeningCharts = new Map;
    let oldDevicePixelRatio = 0;

    function onWindowResize() {
        const dpr = window.devicePixelRatio;
        dpr !== oldDevicePixelRatio && (oldDevicePixelRatio = dpr, drpListeningCharts.forEach((resize, chart) => {
            chart.currentDevicePixelRatio !== dpr && resize()
        }))
    }

    function createResizeObserver(chart, type, listener) {
        const canvas = chart.canvas,
            container = canvas && _getParentNode(canvas);
        if (!container) return;
        const resize = throttled((width, height) => {
            const w = container.clientWidth;
            listener(width, height), w < container.clientWidth && listener()
        }, window),
            observer = new ResizeObserver(entries => {
                const entry = entries[0],
                    width = entry.contentRect.width,
                    height = entry.contentRect.height;
                0 === width && 0 === height || resize(width, height)
            });
        return observer.observe(container),
            function (chart, resize) {
                drpListeningCharts.size || window.addEventListener("resize", onWindowResize), drpListeningCharts.set(chart, resize)
            }(chart, resize), observer
    }

    function releaseObserver(chart, type, observer) {
        observer && observer.disconnect(), "resize" === type && function (chart) {
            drpListeningCharts.delete(chart), drpListeningCharts.size || window.removeEventListener("resize", onWindowResize)
        }(chart)
    }

    function createProxyAndListen(chart, type, listener) {
        const canvas = chart.canvas,
            proxy = throttled(event => {
                null !== chart.ctx && listener(function (event, chart) {
                    const type = EVENT_TYPES[event.type] || event.type,
                        {
                            x: x,
                            y: y
                        } = getRelativePosition(event, chart);
                    return {
                        type: type,
                        chart: chart,
                        native: event,
                        x: void 0 !== x ? x : null,
                        y: void 0 !== y ? y : null
                    }
                }(event, chart))
            }, chart, args => {
                const event = args[0];
                return [event, event.offsetX, event.offsetY]
            });
        return function (node, type, listener) {
            node.addEventListener(type, listener, eventListenerOptions)
        }(canvas, type, proxy), proxy
    }
    class chart_esm_DomPlatform extends BasePlatform {
        acquireContext(canvas, aspectRatio) {
            const context = canvas && canvas.getContext && canvas.getContext("2d");
            return context && context.canvas === canvas ? (function (canvas, aspectRatio) {
                const style = canvas.style,
                    renderHeight = canvas.getAttribute("height"),
                    renderWidth = canvas.getAttribute("width");
                if (canvas.$chartjs = {
                    initial: {
                        height: renderHeight,
                        width: renderWidth,
                        style: {
                            display: style.display,
                            height: style.height,
                            width: style.width
                        }
                    }
                }, style.display = style.display || "block", style.boxSizing = style.boxSizing || "border-box", isNullOrEmpty(renderWidth)) {
                    const displayWidth = readUsedSize(canvas, "width");
                    void 0 !== displayWidth && (canvas.width = displayWidth)
                }
                if (isNullOrEmpty(renderHeight))
                    if ("" === canvas.style.height) canvas.height = canvas.width / (aspectRatio || 2);
                    else {
                        const displayHeight = readUsedSize(canvas, "height");
                        void 0 !== displayHeight && (canvas.height = displayHeight)
                    }
            }(canvas, aspectRatio), context) : null
        }
        releaseContext(context) {
            const canvas = context.canvas;
            if (!canvas.$chartjs) return !1;
            const initial = canvas.$chartjs.initial;
            ["height", "width"].forEach(prop => {
                const value = initial[prop];
                isNullOrUndef(value) ? canvas.removeAttribute(prop) : canvas.setAttribute(prop, value)
            });
            const style = initial.style || {};
            return Object.keys(style).forEach(key => {
                canvas.style[key] = style[key]
            }), canvas.width = canvas.width, delete canvas.$chartjs, !0
        }
        addEventListener(chart, type, listener) {
            this.removeEventListener(chart, type);
            const proxies = chart.$proxies || (chart.$proxies = {}),
                handler = {
                    attach: createAttachObserver,
                    detach: createDetachObserver,
                    resize: createResizeObserver
                }[type] || createProxyAndListen;
            proxies[type] = handler(chart, type, listener)
        }
        removeEventListener(chart, type) {
            const proxies = chart.$proxies || (chart.$proxies = {}),
                proxy = proxies[type];
            if (!proxy) return;
            ({
                attach: releaseObserver,
                detach: releaseObserver,
                resize: releaseObserver
            }[type] || removeListener)(chart, type, proxy), proxies[type] = void 0
        }
        getDevicePixelRatio() {
            return window.devicePixelRatio
        }
        getMaximumSize(canvas, width, height, aspectRatio) {
            return getMaximumSize(canvas, width, height, aspectRatio)
        }
        isAttached(canvas) {
            const container = _getParentNode(canvas);
            return !(!container || !container.isConnected)
        }
    }
    class chart_esm_Element {
        constructor() {
            this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0
        }
        tooltipPosition(useFinalPosition) {
            const {
                x: x,
                y: y
            } = this.getProps(["x", "y"], useFinalPosition);
            return {
                x: x,
                y: y
            }
        }
        hasValue() {
            return isNumber(this.x) && isNumber(this.y)
        }
        getProps(props, final) {
            const anims = this.$animations;
            if (!final || !anims) return this;
            const ret = {};
            return props.forEach(prop => {
                ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop]
            }), ret
        }
    }
    chart_esm_Element.defaults = {}, chart_esm_Element.defaultRoutes = void 0;
    const formatters = {
        values: value => isArray(value) ? value : "" + value,
        numeric(tickValue, index, ticks) {
            if (0 === tickValue) return "0";
            const locale = this.chart.options.locale;
            let notation, delta = tickValue;
            if (ticks.length > 1) {
                const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
                (maxTick < 1e-4 || maxTick > 1e15) && (notation = "scientific"), delta = function (tickValue, ticks) {
                    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
                    Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue) && (delta = tickValue - Math.floor(tickValue));
                    return delta
                }(tickValue, ticks)
            }
            const logDelta = log10(Math.abs(delta)),
                numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0),
                options = {
                    notation: notation,
                    minimumFractionDigits: numDecimal,
                    maximumFractionDigits: numDecimal
                };
            return Object.assign(options, this.options.ticks.format), formatNumber(tickValue, locale, options)
        },
        logarithmic(tickValue, index, ticks) {
            if (0 === tickValue) return "0";
            const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
            return 1 === remain || 2 === remain || 5 === remain ? formatters.numeric.call(this, tickValue, index, ticks) : ""
        }
    };
    var Ticks = {
        formatters: formatters
    };

    function autoSkip(scale, ticks) {
        const tickOpts = scale.options.ticks,
            ticksLimit = tickOpts.maxTicksLimit || function (scale) {
                const offset = scale.options.offset,
                    tickLength = scale._tickSize(),
                    maxScale = scale._length / tickLength + (offset ? 0 : 1),
                    maxChart = scale._maxLength / tickLength;
                return Math.floor(Math.min(maxScale, maxChart))
            }(scale),
            majorIndices = tickOpts.major.enabled ? function (ticks) {
                const result = [];
                let i, ilen;
                for (i = 0, ilen = ticks.length; i < ilen; i++) ticks[i].major && result.push(i);
                return result
            }(ticks) : [],
            numMajorIndices = majorIndices.length,
            first = majorIndices[0],
            last = majorIndices[numMajorIndices - 1],
            newTicks = [];
        if (numMajorIndices > ticksLimit) return function (ticks, newTicks, majorIndices, spacing) {
            let i, count = 0,
                next = majorIndices[0];
            for (spacing = Math.ceil(spacing), i = 0; i < ticks.length; i++) i === next && (newTicks.push(ticks[i]), count++, next = majorIndices[count * spacing])
        }(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit), newTicks;
        const spacing = function (majorIndices, ticks, ticksLimit) {
            const evenMajorSpacing = function (arr) {
                const len = arr.length;
                let i, diff;
                if (len < 2) return !1;
                for (diff = arr[0], i = 1; i < len; ++i)
                    if (arr[i] - arr[i - 1] !== diff) return !1;
                return diff
            }(majorIndices),
                spacing = ticks.length / ticksLimit;
            if (!evenMajorSpacing) return Math.max(spacing, 1);
            const factors = function (value) {
                const result = [],
                    sqrt = Math.sqrt(value);
                let i;
                for (i = 1; i < sqrt; i++) value % i == 0 && (result.push(i), result.push(value / i));
                return sqrt === (0 | sqrt) && result.push(sqrt), result.sort((a, b) => a - b).pop(), result
            }(evenMajorSpacing);
            for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
                const factor = factors[i];
                if (factor > spacing) return factor
            }
            return Math.max(spacing, 1)
        }(majorIndices, ticks, ticksLimit);
        if (numMajorIndices > 0) {
            let i, ilen;
            const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
            for (chart_esm_skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first), i = 0, ilen = numMajorIndices - 1; i < ilen; i++) chart_esm_skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
            return chart_esm_skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing), newTicks
        }
        return chart_esm_skip(ticks, newTicks, spacing), newTicks
    }

    function chart_esm_skip(ticks, newTicks, spacing, majorStart, majorEnd) {
        const start = valueOrDefault(majorStart, 0),
            end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
        let length, i, next, count = 0;
        for (spacing = Math.ceil(spacing), majorEnd && (length = majorEnd - majorStart, spacing = length / Math.floor(length / spacing)), next = start; next < 0;) count++, next = Math.round(start + count * spacing);
        for (i = Math.max(start, 0); i < end; i++) i === next && (newTicks.push(ticks[i]), count++, next = Math.round(start + count * spacing))
    }
    defaults.set("scale", {
        display: !0,
        offset: !1,
        reverse: !1,
        beginAtZero: !1,
        bounds: "ticks",
        grace: 0,
        grid: {
            display: !0,
            lineWidth: 1,
            drawBorder: !0,
            drawOnChartArea: !0,
            drawTicks: !0,
            tickLength: 8,
            tickWidth: (_ctx, options) => options.lineWidth,
            tickColor: (_ctx, options) => options.color,
            offset: !1,
            borderDash: [],
            borderDashOffset: 0,
            borderWidth: 1
        },
        title: {
            display: !1,
            text: "",
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: !1,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: !0,
            autoSkip: !0,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: !1,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
        }
    }), defaults.route("scale.ticks", "color", "", "color"), defaults.route("scale.grid", "color", "", "borderColor"), defaults.route("scale.grid", "borderColor", "", "borderColor"), defaults.route("scale.title", "color", "", "color"), defaults.describe("scale", {
        _fallback: !1,
        _scriptable: name => !name.startsWith("before") && !name.startsWith("after") && "callback" !== name && "parser" !== name,
        _indexable: name => "borderDash" !== name && "tickBorderDash" !== name
    }), defaults.describe("scales", {
        _fallback: "scale"
    }), defaults.describe("scale.ticks", {
        _scriptable: name => "backdropPadding" !== name && "callback" !== name,
        _indexable: name => "backdropPadding" !== name
    });
    const offsetFromEdge = (scale, edge, offset) => "top" === edge || "left" === edge ? scale[edge] + offset : scale[edge] - offset;

    function sample(arr, numItems) {
        const result = [],
            increment = arr.length / numItems,
            len = arr.length;
        let i = 0;
        for (; i < len; i += increment) result.push(arr[Math.floor(i)]);
        return result
    }

    function getPixelForGridLine(scale, index, offsetGridLines) {
        const length = scale.ticks.length,
            validIndex = Math.min(index, length - 1),
            start = scale._startPixel,
            end = scale._endPixel;
        let offset, lineValue = scale.getPixelForTick(validIndex);
        if (!(offsetGridLines && (offset = 1 === length ? Math.max(lineValue - start, end - lineValue) : 0 === index ? (scale.getPixelForTick(1) - lineValue) / 2 : (lineValue - scale.getPixelForTick(validIndex - 1)) / 2, lineValue += validIndex < index ? offset : -offset, lineValue < start - 1e-6 || lineValue > end + 1e-6))) return lineValue
    }

    function getTickMarkLength(options) {
        return options.drawTicks ? options.tickLength : 0
    }

    function getTitleHeight(options, fallback) {
        if (!options.display) return 0;
        const font = toFont(options.font, fallback),
            padding = toPadding(options.padding);
        return (isArray(options.text) ? options.text.length : 1) * font.lineHeight + padding.height
    }

    function titleAlign(align, position, reverse) {
        let ret = _toLeftRightCenter(align);
        return (reverse && "right" !== position || !reverse && "right" === position) && (ret = (align => "left" === align ? "right" : "right" === align ? "left" : align)(ret)), ret
    }
    class chart_esm_Scale extends chart_esm_Element {
        constructor(cfg) {
            super(), this.id = cfg.id, this.type = cfg.type, this.options = void 0, this.ctx = cfg.ctx, this.chart = cfg.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0
        }
        init(options) {
            this.options = options.setContext(this.getContext()), this.axis = options.axis, this._userMin = this.parse(options.min), this._userMax = this.parse(options.max), this._suggestedMin = this.parse(options.suggestedMin), this._suggestedMax = this.parse(options.suggestedMax)
        }
        parse(raw, index) {
            return raw
        }
        getUserBounds() {
            let {
                _userMin: _userMin,
                _userMax: _userMax,
                _suggestedMin: _suggestedMin,
                _suggestedMax: _suggestedMax
            } = this;
            return _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY), _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY), _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY), _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY), {
                min: finiteOrDefault(_userMin, _suggestedMin),
                max: finiteOrDefault(_userMax, _suggestedMax),
                minDefined: isNumberFinite(_userMin),
                maxDefined: isNumberFinite(_userMax)
            }
        }
        getMinMax(canStack) {
            let range, {
                min: min,
                max: max,
                minDefined: minDefined,
                maxDefined: maxDefined
            } = this.getUserBounds();
            if (minDefined && maxDefined) return {
                min: min,
                max: max
            };
            const metas = this.getMatchingVisibleMetas();
            for (let i = 0, ilen = metas.length; i < ilen; ++i) range = metas[i].controller.getMinMax(this, canStack), minDefined || (min = Math.min(min, range.min)), maxDefined || (max = Math.max(max, range.max));
            return min = maxDefined && min > max ? max : min, max = minDefined && min > max ? min : max, {
                min: finiteOrDefault(min, finiteOrDefault(max, min)),
                max: finiteOrDefault(max, finiteOrDefault(min, max))
            }
        }
        getPadding() {
            return {
                left: this.paddingLeft || 0,
                top: this.paddingTop || 0,
                right: this.paddingRight || 0,
                bottom: this.paddingBottom || 0
            }
        }
        getTicks() {
            return this.ticks
        }
        getLabels() {
            const data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || []
        }
        beforeLayout() {
            this._cache = {}, this._dataLimitsCached = !1
        }
        beforeUpdate() {
            helpers_segment_callback(this.options.beforeUpdate, [this])
        }
        update(maxWidth, maxHeight, margins) {
            const {
                beginAtZero: beginAtZero,
                grace: grace,
                ticks: tickOpts
            } = this.options, sampleSize = tickOpts.sampleSize;
            this.beforeUpdate(), this.maxWidth = maxWidth, this.maxHeight = maxHeight, this._margins = margins = Object.assign({
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, margins), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = function (minmax, grace, beginAtZero) {
                const {
                    min: min,
                    max: max
                } = minmax, change = toDimension(grace, (max - min) / 2), keepZero = (value, add) => beginAtZero && 0 === value ? 0 : value + add;
                return {
                    min: keepZero(min, -Math.abs(change)),
                    max: keepZero(max, change)
                }
            }(this, grace, beginAtZero), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
            const samplingEnabled = sampleSize < this.ticks.length;
            this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), tickOpts.display && (tickOpts.autoSkip || "auto" === tickOpts.source) && (this.ticks = autoSkip(this, this.ticks), this._labelSizes = null), samplingEnabled && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate()
        }
        configure() {
            let startPixel, endPixel, reversePixels = this.options.reverse;
            this.isHorizontal() ? (startPixel = this.left, endPixel = this.right) : (startPixel = this.top, endPixel = this.bottom, reversePixels = !reversePixels), this._startPixel = startPixel, this._endPixel = endPixel, this._reversePixels = reversePixels, this._length = endPixel - startPixel, this._alignToPixels = this.options.alignToPixels
        }
        afterUpdate() {
            helpers_segment_callback(this.options.afterUpdate, [this])
        }
        beforeSetDimensions() {
            helpers_segment_callback(this.options.beforeSetDimensions, [this])
        }
        setDimensions() {
            this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0
        }
        afterSetDimensions() {
            helpers_segment_callback(this.options.afterSetDimensions, [this])
        }
        _callHooks(name) {
            this.chart.notifyPlugins(name, this.getContext()), helpers_segment_callback(this.options[name], [this])
        }
        beforeDataLimits() {
            this._callHooks("beforeDataLimits")
        }
        determineDataLimits() { }
        afterDataLimits() {
            this._callHooks("afterDataLimits")
        }
        beforeBuildTicks() {
            this._callHooks("beforeBuildTicks")
        }
        buildTicks() {
            return []
        }
        afterBuildTicks() {
            this._callHooks("afterBuildTicks")
        }
        beforeTickToLabelConversion() {
            helpers_segment_callback(this.options.beforeTickToLabelConversion, [this])
        }
        generateTickLabels(ticks) {
            const tickOpts = this.options.ticks;
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; i++) tick = ticks[i], tick.label = helpers_segment_callback(tickOpts.callback, [tick.value, i, ticks], this)
        }
        afterTickToLabelConversion() {
            helpers_segment_callback(this.options.afterTickToLabelConversion, [this])
        }
        beforeCalculateLabelRotation() {
            helpers_segment_callback(this.options.beforeCalculateLabelRotation, [this])
        }
        calculateLabelRotation() {
            const options = this.options,
                tickOpts = options.ticks,
                numTicks = this.ticks.length,
                minRotation = tickOpts.minRotation || 0,
                maxRotation = tickOpts.maxRotation;
            let tickWidth, maxHeight, maxLabelDiagonal, labelRotation = minRotation;
            if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) return void (this.labelRotation = minRotation);
            const labelSizes = this._getLabelSizes(),
                maxLabelWidth = labelSizes.widest.width,
                maxLabelHeight = labelSizes.highest.height,
                maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
            tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1), maxLabelWidth + 6 > tickWidth && (tickWidth = maxWidth / (numTicks - (options.offset ? .5 : 1)), maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font), maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight), labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1)))), labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation))), this.labelRotation = labelRotation
        }
        afterCalculateLabelRotation() {
            helpers_segment_callback(this.options.afterCalculateLabelRotation, [this])
        }
        beforeFit() {
            helpers_segment_callback(this.options.beforeFit, [this])
        }
        fit() {
            const minSize = {
                width: 0,
                height: 0
            },
                {
                    chart: chart,
                    options: {
                        ticks: tickOpts,
                        title: titleOpts,
                        grid: gridOpts
                    }
                } = this,
                display = this._isVisible(),
                isHorizontal = this.isHorizontal();
            if (display) {
                const titleHeight = getTitleHeight(titleOpts, chart.options.font);
                if (isHorizontal ? (minSize.width = this.maxWidth, minSize.height = getTickMarkLength(gridOpts) + titleHeight) : (minSize.height = this.maxHeight, minSize.width = getTickMarkLength(gridOpts) + titleHeight), tickOpts.display && this.ticks.length) {
                    const {
                        first: first,
                        last: last,
                        widest: widest,
                        highest: highest
                    } = this._getLabelSizes(), tickPadding = 2 * tickOpts.padding, angleRadians = toRadians(this.labelRotation), cos = Math.cos(angleRadians), sin = Math.sin(angleRadians);
                    if (isHorizontal) {
                        const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                        minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding)
                    } else {
                        const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                        minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding)
                    }
                    this._calculatePadding(first, last, sin, cos)
                }
            }
            this._handleMargins(), isHorizontal ? (this.width = this._length = chart.width - this._margins.left - this._margins.right, this.height = minSize.height) : (this.width = minSize.width, this.height = this._length = chart.height - this._margins.top - this._margins.bottom)
        }
        _calculatePadding(first, last, sin, cos) {
            const {
                ticks: {
                    align: align,
                    padding: padding
                },
                position: position
            } = this.options, isRotated = 0 !== this.labelRotation, labelsBelowTicks = "top" !== position && "x" === this.axis;
            if (this.isHorizontal()) {
                const offsetLeft = this.getPixelForTick(0) - this.left,
                    offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
                let paddingLeft = 0,
                    paddingRight = 0;
                isRotated ? labelsBelowTicks ? (paddingLeft = cos * first.width, paddingRight = sin * last.height) : (paddingLeft = sin * first.height, paddingRight = cos * last.width) : "start" === align ? paddingRight = last.width : "end" === align ? paddingLeft = first.width : (paddingLeft = first.width / 2, paddingRight = last.width / 2), this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0), this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0)
            } else {
                let paddingTop = last.height / 2,
                    paddingBottom = first.height / 2;
                "start" === align ? (paddingTop = 0, paddingBottom = first.height) : "end" === align && (paddingTop = last.height, paddingBottom = 0), this.paddingTop = paddingTop + padding, this.paddingBottom = paddingBottom + padding
            }
        }
        _handleMargins() {
            this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
        }
        afterFit() {
            helpers_segment_callback(this.options.afterFit, [this])
        }
        isHorizontal() {
            const {
                axis: axis,
                position: position
            } = this.options;
            return "top" === position || "bottom" === position || "x" === axis
        }
        isFullSize() {
            return this.options.fullSize
        }
        _convertTicksToLabels(ticks) {
            let i, ilen;
            for (this.beforeTickToLabelConversion(), this.generateTickLabels(ticks), i = 0, ilen = ticks.length; i < ilen; i++) isNullOrUndef(ticks[i].label) && (ticks.splice(i, 1), ilen--, i--);
            this.afterTickToLabelConversion()
        }
        _getLabelSizes() {
            let labelSizes = this._labelSizes;
            if (!labelSizes) {
                const sampleSize = this.options.ticks.sampleSize;
                let ticks = this.ticks;
                sampleSize < ticks.length && (ticks = sample(ticks, sampleSize)), this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length)
            }
            return labelSizes
        }
        _computeLabelSizes(ticks, length) {
            const {
                ctx: ctx,
                _longestTextCache: caches
            } = this, widths = [], heights = [];
            let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widestLabelSize = 0,
                highestLabelSize = 0;
            for (i = 0; i < length; ++i) {
                if (label = ticks[i].label, tickFont = this._resolveTickFontOptions(i), ctx.font = fontString = tickFont.string, cache = caches[fontString] = caches[fontString] || {
                    data: {},
                    gc: []
                }, lineHeight = tickFont.lineHeight, width = height = 0, isNullOrUndef(label) || isArray(label)) {
                    if (isArray(label))
                        for (j = 0, jlen = label.length; j < jlen; ++j) nestedLabel = label[j], isNullOrUndef(nestedLabel) || isArray(nestedLabel) || (width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel), height += lineHeight)
                } else width = _measureText(ctx, cache.data, cache.gc, width, label), height = lineHeight;
                widths.push(width), heights.push(height), widestLabelSize = Math.max(width, widestLabelSize), highestLabelSize = Math.max(height, highestLabelSize)
            } ! function (caches, length) {
                each(caches, cache => {
                    const gc = cache.gc,
                        gcLen = gc.length / 2;
                    let i;
                    if (gcLen > length) {
                        for (i = 0; i < gcLen; ++i) delete cache.data[gc[i]];
                        gc.splice(0, gcLen)
                    }
                })
            }(caches, length);
            const widest = widths.indexOf(widestLabelSize),
                highest = heights.indexOf(highestLabelSize),
                valueAt = idx => ({
                    width: widths[idx] || 0,
                    height: heights[idx] || 0
                });
            return {
                first: valueAt(0),
                last: valueAt(length - 1),
                widest: valueAt(widest),
                highest: valueAt(highest),
                widths: widths,
                heights: heights
            }
        }
        getLabelForValue(value) {
            return value
        }
        getPixelForValue(value, index) {
            return NaN
        }
        getValueForPixel(pixel) { }
        getPixelForTick(index) {
            const ticks = this.ticks;
            return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index].value)
        }
        getPixelForDecimal(decimal) {
            this._reversePixels && (decimal = 1 - decimal);
            const pixel = this._startPixel + decimal * this._length;
            return _limitValue(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel, -32768, 32767)
        }
        getDecimalForPixel(pixel) {
            const decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal
        }
        getBasePixel() {
            return this.getPixelForValue(this.getBaseValue())
        }
        getBaseValue() {
            const {
                min: min,
                max: max
            } = this;
            return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0
        }
        getContext(index) {
            const ticks = this.ticks || [];
            if (index >= 0 && index < ticks.length) {
                const tick = ticks[index];
                return tick.$context || (tick.$context = function (parent, index, tick) {
                    return createContext(parent, {
                        tick: tick,
                        index: index,
                        type: "tick"
                    })
                }(this.getContext(), index, tick))
            }
            return this.$context || (this.$context = createContext(this.chart.getContext(), {
                scale: this,
                type: "scale"
            }))
        }
        _tickSize() {
            const optionTicks = this.options.ticks,
                rot = toRadians(this.labelRotation),
                cos = Math.abs(Math.cos(rot)),
                sin = Math.abs(Math.sin(rot)),
                labelSizes = this._getLabelSizes(),
                padding = optionTicks.autoSkipPadding || 0,
                w = labelSizes ? labelSizes.widest.width + padding : 0,
                h = labelSizes ? labelSizes.highest.height + padding : 0;
            return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin
        }
        _isVisible() {
            const display = this.options.display;
            return "auto" !== display ? !!display : this.getMatchingVisibleMetas().length > 0
        }
        _computeGridLineItems(chartArea) {
            const axis = this.axis,
                chart = this.chart,
                options = this.options,
                {
                    grid: grid,
                    position: position
                } = options,
                offset = grid.offset,
                isHorizontal = this.isHorizontal(),
                ticksLength = this.ticks.length + (offset ? 1 : 0),
                tl = getTickMarkLength(grid),
                items = [],
                borderOpts = grid.setContext(this.getContext()),
                axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0,
                axisHalfWidth = axisWidth / 2,
                alignBorderValue = function (pixel) {
                    return _alignPixel(chart, pixel, axisWidth)
                };
            let borderValue, i, lineValue, alignedLineValue, tx1, ty1, tx2, ty2, x1, y1, x2, y2;
            if ("top" === position) borderValue = alignBorderValue(this.bottom), ty1 = this.bottom - tl, ty2 = borderValue - axisHalfWidth, y1 = alignBorderValue(chartArea.top) + axisHalfWidth, y2 = chartArea.bottom;
            else if ("bottom" === position) borderValue = alignBorderValue(this.top), y1 = chartArea.top, y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth, ty1 = borderValue + axisHalfWidth, ty2 = this.top + tl;
            else if ("left" === position) borderValue = alignBorderValue(this.right), tx1 = this.right - tl, tx2 = borderValue - axisHalfWidth, x1 = alignBorderValue(chartArea.left) + axisHalfWidth, x2 = chartArea.right;
            else if ("right" === position) borderValue = alignBorderValue(this.left), x1 = chartArea.left, x2 = alignBorderValue(chartArea.right) - axisHalfWidth, tx1 = borderValue + axisHalfWidth, tx2 = this.left + tl;
            else if ("x" === axis) {
                if ("center" === position) borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + .5);
                else if (isObject(position)) {
                    const positionAxisID = Object.keys(position)[0],
                        value = position[positionAxisID];
                    borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value))
                }
                y1 = chartArea.top, y2 = chartArea.bottom, ty1 = borderValue + axisHalfWidth, ty2 = ty1 + tl
            } else if ("y" === axis) {
                if ("center" === position) borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
                else if (isObject(position)) {
                    const positionAxisID = Object.keys(position)[0],
                        value = position[positionAxisID];
                    borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value))
                }
                tx1 = borderValue - axisHalfWidth, tx2 = tx1 - tl, x1 = chartArea.left, x2 = chartArea.right
            }
            const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength),
                step = Math.max(1, Math.ceil(ticksLength / limit));
            for (i = 0; i < ticksLength; i += step) {
                const optsAtIndex = grid.setContext(this.getContext(i)),
                    lineWidth = optsAtIndex.lineWidth,
                    lineColor = optsAtIndex.color,
                    borderDash = grid.borderDash || [],
                    borderDashOffset = optsAtIndex.borderDashOffset,
                    tickWidth = optsAtIndex.tickWidth,
                    tickColor = optsAtIndex.tickColor,
                    tickBorderDash = optsAtIndex.tickBorderDash || [],
                    tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
                lineValue = getPixelForGridLine(this, i, offset), void 0 !== lineValue && (alignedLineValue = _alignPixel(chart, lineValue, lineWidth), isHorizontal ? tx1 = tx2 = x1 = x2 = alignedLineValue : ty1 = ty2 = y1 = y2 = alignedLineValue, items.push({
                    tx1: tx1,
                    ty1: ty1,
                    tx2: tx2,
                    ty2: ty2,
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                    width: lineWidth,
                    color: lineColor,
                    borderDash: borderDash,
                    borderDashOffset: borderDashOffset,
                    tickWidth: tickWidth,
                    tickColor: tickColor,
                    tickBorderDash: tickBorderDash,
                    tickBorderDashOffset: tickBorderDashOffset
                }))
            }
            return this._ticksLength = ticksLength, this._borderValue = borderValue, items
        }
        _computeLabelItems(chartArea) {
            const axis = this.axis,
                options = this.options,
                {
                    position: position,
                    ticks: optionTicks
                } = options,
                isHorizontal = this.isHorizontal(),
                ticks = this.ticks,
                {
                    align: align,
                    crossAlign: crossAlign,
                    padding: padding,
                    mirror: mirror
                } = optionTicks,
                tl = getTickMarkLength(options.grid),
                tickAndPadding = tl + padding,
                hTickAndPadding = mirror ? -padding : tickAndPadding,
                rotation = -toRadians(this.labelRotation),
                items = [];
            let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset, textBaseline = "middle";
            if ("top" === position) y = this.bottom - hTickAndPadding, textAlign = this._getXAxisLabelAlignment();
            else if ("bottom" === position) y = this.top + hTickAndPadding, textAlign = this._getXAxisLabelAlignment();
            else if ("left" === position) {
                const ret = this._getYAxisLabelAlignment(tl);
                textAlign = ret.textAlign, x = ret.x
            } else if ("right" === position) {
                const ret = this._getYAxisLabelAlignment(tl);
                textAlign = ret.textAlign, x = ret.x
            } else if ("x" === axis) {
                if ("center" === position) y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
                else if (isObject(position)) {
                    const positionAxisID = Object.keys(position)[0],
                        value = position[positionAxisID];
                    y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding
                }
                textAlign = this._getXAxisLabelAlignment()
            } else if ("y" === axis) {
                if ("center" === position) x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
                else if (isObject(position)) {
                    const positionAxisID = Object.keys(position)[0],
                        value = position[positionAxisID];
                    x = this.chart.scales[positionAxisID].getPixelForValue(value)
                }
                textAlign = this._getYAxisLabelAlignment(tl).textAlign
            }
            "y" === axis && ("start" === align ? textBaseline = "top" : "end" === align && (textBaseline = "bottom"));
            const labelSizes = this._getLabelSizes();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                tick = ticks[i], label = tick.label;
                const optsAtIndex = optionTicks.setContext(this.getContext(i));
                pixel = this.getPixelForTick(i) + optionTicks.labelOffset, font = this._resolveTickFontOptions(i), lineHeight = font.lineHeight, lineCount = isArray(label) ? label.length : 1;
                const halfCount = lineCount / 2,
                    color = optsAtIndex.color,
                    strokeColor = optsAtIndex.textStrokeColor,
                    strokeWidth = optsAtIndex.textStrokeWidth;
                let backdrop;
                if (isHorizontal ? (x = pixel, textOffset = "top" === position ? "near" === crossAlign || 0 !== rotation ? -lineCount * lineHeight + lineHeight / 2 : "center" === crossAlign ? -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight : -labelSizes.highest.height + lineHeight / 2 : "near" === crossAlign || 0 !== rotation ? lineHeight / 2 : "center" === crossAlign ? labelSizes.highest.height / 2 - halfCount * lineHeight : labelSizes.highest.height - lineCount * lineHeight, mirror && (textOffset *= -1)) : (y = pixel, textOffset = (1 - lineCount) * lineHeight / 2), optsAtIndex.showLabelBackdrop) {
                    const labelPadding = toPadding(optsAtIndex.backdropPadding),
                        height = labelSizes.heights[i],
                        width = labelSizes.widths[i];
                    let top = y + textOffset - labelPadding.top,
                        left = x - labelPadding.left;
                    switch (textBaseline) {
                        case "middle":
                            top -= height / 2;
                            break;
                        case "bottom":
                            top -= height
                    }
                    switch (textAlign) {
                        case "center":
                            left -= width / 2;
                            break;
                        case "right":
                            left -= width
                    }
                    backdrop = {
                        left: left,
                        top: top,
                        width: width + labelPadding.width,
                        height: height + labelPadding.height,
                        color: optsAtIndex.backdropColor
                    }
                }
                items.push({
                    rotation: rotation,
                    label: label,
                    font: font,
                    color: color,
                    strokeColor: strokeColor,
                    strokeWidth: strokeWidth,
                    textOffset: textOffset,
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    translation: [x, y],
                    backdrop: backdrop
                })
            }
            return items
        }
        _getXAxisLabelAlignment() {
            const {
                position: position,
                ticks: ticks
            } = this.options;
            if (-toRadians(this.labelRotation)) return "top" === position ? "left" : "right";
            let align = "center";
            return "start" === ticks.align ? align = "left" : "end" === ticks.align && (align = "right"), align
        }
        _getYAxisLabelAlignment(tl) {
            const {
                position: position,
                ticks: {
                    crossAlign: crossAlign,
                    mirror: mirror,
                    padding: padding
                }
            } = this.options, tickAndPadding = tl + padding, widest = this._getLabelSizes().widest.width;
            let textAlign, x;
            return "left" === position ? mirror ? (x = this.right + padding, "near" === crossAlign ? textAlign = "left" : "center" === crossAlign ? (textAlign = "center", x += widest / 2) : (textAlign = "right", x += widest)) : (x = this.right - tickAndPadding, "near" === crossAlign ? textAlign = "right" : "center" === crossAlign ? (textAlign = "center", x -= widest / 2) : (textAlign = "left", x = this.left)) : "right" === position ? mirror ? (x = this.left + padding, "near" === crossAlign ? textAlign = "right" : "center" === crossAlign ? (textAlign = "center", x -= widest / 2) : (textAlign = "left", x -= widest)) : (x = this.left + tickAndPadding, "near" === crossAlign ? textAlign = "left" : "center" === crossAlign ? (textAlign = "center", x += widest / 2) : (textAlign = "right", x = this.right)) : textAlign = "right", {
                textAlign: textAlign,
                x: x
            }
        }
        _computeLabelArea() {
            if (this.options.ticks.mirror) return;
            const chart = this.chart,
                position = this.options.position;
            return "left" === position || "right" === position ? {
                top: 0,
                left: this.left,
                bottom: chart.height,
                right: this.right
            } : "top" === position || "bottom" === position ? {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: chart.width
            } : void 0
        }
        drawBackground() {
            const {
                ctx: ctx,
                options: {
                    backgroundColor: backgroundColor
                },
                left: left,
                top: top,
                width: width,
                height: height
            } = this;
            backgroundColor && (ctx.save(), ctx.fillStyle = backgroundColor, ctx.fillRect(left, top, width, height), ctx.restore())
        }
        getLineWidthForValue(value) {
            const grid = this.options.grid;
            if (!this._isVisible() || !grid.display) return 0;
            const index = this.ticks.findIndex(t => t.value === value);
            if (index >= 0) {
                return grid.setContext(this.getContext(index)).lineWidth
            }
            return 0
        }
        drawGrid(chartArea) {
            const grid = this.options.grid,
                ctx = this.ctx,
                items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
            let i, ilen;
            const drawLine = (p1, p2, style) => {
                style.width && style.color && (ctx.save(), ctx.lineWidth = style.width, ctx.strokeStyle = style.color, ctx.setLineDash(style.borderDash || []), ctx.lineDashOffset = style.borderDashOffset, ctx.beginPath(), ctx.moveTo(p1.x, p1.y), ctx.lineTo(p2.x, p2.y), ctx.stroke(), ctx.restore())
            };
            if (grid.display)
                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    const item = items[i];
                    grid.drawOnChartArea && drawLine({
                        x: item.x1,
                        y: item.y1
                    }, {
                        x: item.x2,
                        y: item.y2
                    }, item), grid.drawTicks && drawLine({
                        x: item.tx1,
                        y: item.ty1
                    }, {
                        x: item.tx2,
                        y: item.ty2
                    }, {
                        color: item.tickColor,
                        width: item.tickWidth,
                        borderDash: item.tickBorderDash,
                        borderDashOffset: item.tickBorderDashOffset
                    })
                }
        }
        drawBorder() {
            const {
                chart: chart,
                ctx: ctx,
                options: {
                    grid: grid
                }
            } = this, borderOpts = grid.setContext(this.getContext()), axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
            if (!axisWidth) return;
            const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth,
                borderValue = this._borderValue;
            let x1, x2, y1, y2;
            this.isHorizontal() ? (x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2, x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2, y1 = y2 = borderValue) : (y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2, y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2, x1 = x2 = borderValue), ctx.save(), ctx.lineWidth = borderOpts.borderWidth, ctx.strokeStyle = borderOpts.borderColor, ctx.beginPath(), ctx.moveTo(x1, y1), ctx.lineTo(x2, y2), ctx.stroke(), ctx.restore()
        }
        drawLabels(chartArea) {
            if (!this.options.ticks.display) return;
            const ctx = this.ctx,
                area = this._computeLabelArea();
            area && clipArea(ctx, area);
            const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
            let i, ilen;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
                const item = items[i],
                    tickFont = item.font,
                    label = item.label;
                item.backdrop && (ctx.fillStyle = item.backdrop.color, ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height)), renderText(ctx, label, 0, item.textOffset, tickFont, item)
            }
            area && unclipArea(ctx)
        }
        drawTitle() {
            const {
                ctx: ctx,
                options: {
                    position: position,
                    title: title,
                    reverse: reverse
                }
            } = this;
            if (!title.display) return;
            const font = toFont(title.font),
                padding = toPadding(title.padding),
                align = title.align;
            let offset = font.lineHeight / 2;
            "bottom" === position || "center" === position || isObject(position) ? (offset += padding.bottom, isArray(title.text) && (offset += font.lineHeight * (title.text.length - 1))) : offset += padding.top;
            const {
                titleX: titleX,
                titleY: titleY,
                maxWidth: maxWidth,
                rotation: rotation
            } = function (scale, offset, position, align) {
                const {
                    top: top,
                    left: left,
                    bottom: bottom,
                    right: right,
                    chart: chart
                } = scale, {
                    chartArea: chartArea,
                    scales: scales
                } = chart;
                let maxWidth, titleX, titleY, rotation = 0;
                const height = bottom - top,
                    width = right - left;
                if (scale.isHorizontal()) {
                    if (titleX = _alignStartEnd(align, left, right), isObject(position)) {
                        const positionAxisID = Object.keys(position)[0],
                            value = position[positionAxisID];
                        titleY = scales[positionAxisID].getPixelForValue(value) + height - offset
                    } else titleY = "center" === position ? (chartArea.bottom + chartArea.top) / 2 + height - offset : offsetFromEdge(scale, position, offset);
                    maxWidth = right - left
                } else {
                    if (isObject(position)) {
                        const positionAxisID = Object.keys(position)[0],
                            value = position[positionAxisID];
                        titleX = scales[positionAxisID].getPixelForValue(value) - width + offset
                    } else titleX = "center" === position ? (chartArea.left + chartArea.right) / 2 - width + offset : offsetFromEdge(scale, position, offset);
                    titleY = _alignStartEnd(align, bottom, top), rotation = "left" === position ? -HALF_PI : HALF_PI
                }
                return {
                    titleX: titleX,
                    titleY: titleY,
                    maxWidth: maxWidth,
                    rotation: rotation
                }
            }(this, offset, position, align);
            renderText(ctx, title.text, 0, 0, font, {
                color: title.color,
                maxWidth: maxWidth,
                rotation: rotation,
                textAlign: titleAlign(align, position, reverse),
                textBaseline: "middle",
                translation: [titleX, titleY]
            })
        }
        draw(chartArea) {
            this._isVisible() && (this.drawBackground(), this.drawGrid(chartArea), this.drawBorder(), this.drawTitle(), this.drawLabels(chartArea))
        }
        _layers() {
            const opts = this.options,
                tz = opts.ticks && opts.ticks.z || 0,
                gz = valueOrDefault(opts.grid && opts.grid.z, -1);
            return this._isVisible() && this.draw === chart_esm_Scale.prototype.draw ? [{
                z: gz,
                draw: chartArea => {
                    this.drawBackground(), this.drawGrid(chartArea), this.drawTitle()
                }
            }, {
                z: gz + 1,
                draw: () => {
                    this.drawBorder()
                }
            }, {
                z: tz,
                draw: chartArea => {
                    this.drawLabels(chartArea)
                }
            }] : [{
                z: tz,
                draw: chartArea => {
                    this.draw(chartArea)
                }
            }]
        }
        getMatchingVisibleMetas(type) {
            const metas = this.chart.getSortedVisibleDatasetMetas(),
                axisID = this.axis + "AxisID",
                result = [];
            let i, ilen;
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
                const meta = metas[i];
                meta[axisID] !== this.id || type && meta.type !== type || result.push(meta)
            }
            return result
        }
        _resolveTickFontOptions(index) {
            return toFont(this.options.ticks.setContext(this.getContext(index)).font)
        }
        _maxDigits() {
            const fontSize = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / fontSize
        }
    }
    class chart_esm_TypedRegistry {
        constructor(type, scope, override) {
            this.type = type, this.scope = scope, this.override = override, this.items = Object.create(null)
        }
        isForType(type) {
            return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype)
        }
        register(item) {
            const proto = Object.getPrototypeOf(item);
            let parentScope;
            (function (proto) {
                return "id" in proto && "defaults" in proto
            })(proto) && (parentScope = this.register(proto));
            const items = this.items,
                id = item.id,
                scope = this.scope + "." + id;
            if (!id) throw new Error("class does not have id: " + item);
            return id in items || (items[id] = item, function (item, scope, parentScope) {
                const itemDefaults = merge(Object.create(null), [parentScope ? defaults.get(parentScope) : {}, defaults.get(scope), item.defaults]);
                defaults.set(scope, itemDefaults), item.defaultRoutes && function (scope, routes) {
                    Object.keys(routes).forEach(property => {
                        const propertyParts = property.split("."),
                            sourceName = propertyParts.pop(),
                            sourceScope = [scope].concat(propertyParts).join("."),
                            parts = routes[property].split("."),
                            targetName = parts.pop(),
                            targetScope = parts.join(".");
                        defaults.route(sourceScope, sourceName, targetScope, targetName)
                    })
                }(scope, item.defaultRoutes);
                item.descriptors && defaults.describe(scope, item.descriptors)
            }(item, scope, parentScope), this.override && defaults.override(item.id, item.overrides)), scope
        }
        get(id) {
            return this.items[id]
        }
        unregister(item) {
            const items = this.items,
                id = item.id,
                scope = this.scope;
            id in items && delete items[id], scope && id in defaults[scope] && (delete defaults[scope][id], this.override && delete overrides[id])
        }
    }
    var chart_esm_registry = new class {
        constructor() {
            this.controllers = new chart_esm_TypedRegistry(chart_esm_DatasetController, "datasets", !0), this.elements = new chart_esm_TypedRegistry(chart_esm_Element, "elements"), this.plugins = new chart_esm_TypedRegistry(Object, "plugins"), this.scales = new chart_esm_TypedRegistry(chart_esm_Scale, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements]
        }
        add(...args) {
            this._each("register", args)
        }
        remove(...args) {
            this._each("unregister", args)
        }
        addControllers(...args) {
            this._each("register", args, this.controllers)
        }
        addElements(...args) {
            this._each("register", args, this.elements)
        }
        addPlugins(...args) {
            this._each("register", args, this.plugins)
        }
        addScales(...args) {
            this._each("register", args, this.scales)
        }
        getController(id) {
            return this._get(id, this.controllers, "controller")
        }
        getElement(id) {
            return this._get(id, this.elements, "element")
        }
        getPlugin(id) {
            return this._get(id, this.plugins, "plugin")
        }
        getScale(id) {
            return this._get(id, this.scales, "scale")
        }
        removeControllers(...args) {
            this._each("unregister", args, this.controllers)
        }
        removeElements(...args) {
            this._each("unregister", args, this.elements)
        }
        removePlugins(...args) {
            this._each("unregister", args, this.plugins)
        }
        removeScales(...args) {
            this._each("unregister", args, this.scales)
        }
        _each(method, args, typedRegistry) {
            [...args].forEach(arg => {
                const reg = typedRegistry || this._getRegistryForType(arg);
                typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id ? this._exec(method, reg, arg) : each(arg, item => {
                    const itemReg = typedRegistry || this._getRegistryForType(item);
                    this._exec(method, itemReg, item)
                })
            })
        }
        _exec(method, registry, component) {
            const camelMethod = _capitalize(method);
            helpers_segment_callback(component["before" + camelMethod], [], component), registry[method](component), helpers_segment_callback(component["after" + camelMethod], [], component)
        }
        _getRegistryForType(type) {
            for (let i = 0; i < this._typedRegistries.length; i++) {
                const reg = this._typedRegistries[i];
                if (reg.isForType(type)) return reg
            }
            return this.plugins
        }
        _get(id, typedRegistry, type) {
            const item = typedRegistry.get(id);
            if (void 0 === item) throw new Error('"' + id + '" is not a registered ' + type + ".");
            return item
        }
    };
    class chart_esm_PluginService {
        constructor() {
            this._init = []
        }
        notify(chart, hook, args, filter) {
            "beforeInit" === hook && (this._init = this._createDescriptors(chart, !0), this._notify(this._init, chart, "install"));
            const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart),
                result = this._notify(descriptors, chart, hook, args);
            return "destroy" === hook && (this._notify(descriptors, chart, "stop"), this._notify(this._init, chart, "uninstall")), result
        }
        _notify(descriptors, chart, hook, args) {
            args = args || {};
            for (const descriptor of descriptors) {
                const plugin = descriptor.plugin;
                if (!1 === helpers_segment_callback(plugin[hook], [chart, args, descriptor.options], plugin) && args.cancelable) return !1
            }
            return !0
        }
        invalidate() {
            isNullOrUndef(this._cache) || (this._oldCache = this._cache, this._cache = void 0)
        }
        _descriptors(chart) {
            if (this._cache) return this._cache;
            const descriptors = this._cache = this._createDescriptors(chart);
            return this._notifyStateChanges(chart), descriptors
        }
        _createDescriptors(chart, all) {
            const config = chart && chart.config,
                options = valueOrDefault(config.options && config.options.plugins, {}),
                plugins = function (config) {
                    const plugins = [],
                        keys = Object.keys(chart_esm_registry.plugins.items);
                    for (let i = 0; i < keys.length; i++) plugins.push(chart_esm_registry.getPlugin(keys[i]));
                    const local = config.plugins || [];
                    for (let i = 0; i < local.length; i++) {
                        const plugin = local[i]; - 1 === plugins.indexOf(plugin) && plugins.push(plugin)
                    }
                    return plugins
                }(config);
            return !1 !== options || all ? function (chart, plugins, options, all) {
                const result = [],
                    context = chart.getContext();
                for (let i = 0; i < plugins.length; i++) {
                    const plugin = plugins[i],
                        id = plugin.id,
                        opts = getOpts(options[id], all);
                    null !== opts && result.push({
                        plugin: plugin,
                        options: pluginOpts(chart.config, plugin, opts, context)
                    })
                }
                return result
            }(chart, plugins, options, all) : []
        }
        _notifyStateChanges(chart) {
            const previousDescriptors = this._oldCache || [],
                descriptors = this._cache,
                diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));
            this._notify(diff(previousDescriptors, descriptors), chart, "stop"), this._notify(diff(descriptors, previousDescriptors), chart, "start")
        }
    }

    function getOpts(options, all) {
        return all || !1 !== options ? !0 === options ? {} : options : null
    }

    function pluginOpts(config, plugin, opts, context) {
        const keys = config.pluginScopeKeys(plugin),
            scopes = config.getOptionScopes(opts, keys);
        return config.createResolver(scopes, context, [""], {
            scriptable: !1,
            indexable: !1,
            allKeys: !0
        })
    }

    function getIndexAxis(type, options) {
        const datasetDefaults = defaults.datasets[type] || {};
        return ((options.datasets || {})[type] || {}).indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x"
    }

    function determineAxis(id, scaleOptions) {
        return "x" === id || "y" === id ? id : scaleOptions.axis || ("top" === (position = scaleOptions.position) || "bottom" === position ? "x" : "left" === position || "right" === position ? "y" : void 0) || id.charAt(0).toLowerCase();
        var position
    }

    function initOptions(config) {
        const options = config.options || (config.options = {});
        options.plugins = valueOrDefault(options.plugins, {}), options.scales = function (config, options) {
            const chartDefaults = overrides[config.type] || {
                scales: {}
            },
                configScales = options.scales || {},
                chartIndexAxis = getIndexAxis(config.type, options),
                firstIDs = Object.create(null),
                scales = Object.create(null);
            return Object.keys(configScales).forEach(id => {
                const scaleConf = configScales[id];
                if (!isObject(scaleConf)) return;
                if (scaleConf._proxy) return;
                const axis = determineAxis(id, scaleConf),
                    defaultId = function (axis, indexAxis) {
                        return axis === indexAxis ? "_index_" : "_value_"
                    }(axis, chartIndexAxis),
                    defaultScaleOptions = chartDefaults.scales || {};
                firstIDs[axis] = firstIDs[axis] || id, scales[id] = mergeIf(Object.create(null), [{
                    axis: axis
                }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]])
            }), config.data.datasets.forEach(dataset => {
                const type = dataset.type || config.type,
                    indexAxis = dataset.indexAxis || getIndexAxis(type, options),
                    defaultScaleOptions = (overrides[type] || {}).scales || {};
                Object.keys(defaultScaleOptions).forEach(defaultID => {
                    const axis = function (id, indexAxis) {
                        let axis = id;
                        return "_index_" === id ? axis = indexAxis : "_value_" === id && (axis = "x" === indexAxis ? "y" : "x"), axis
                    }(defaultID, indexAxis),
                        id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
                    scales[id] = scales[id] || Object.create(null), mergeIf(scales[id], [{
                        axis: axis
                    }, configScales[id], defaultScaleOptions[defaultID]])
                })
            }), Object.keys(scales).forEach(key => {
                const scale = scales[key];
                mergeIf(scale, [defaults.scales[scale.type], defaults.scale])
            }), scales
        }(config, options)
    }

    function initData(data) {
        return (data = data || {}).datasets = data.datasets || [], data.labels = data.labels || [], data
    }
    const keyCache = new Map,
        keysCached = new Set;

    function cachedKeys(cacheKey, generate) {
        let keys = keyCache.get(cacheKey);
        return keys || (keys = generate(), keyCache.set(cacheKey, keys), keysCached.add(keys)), keys
    }
    const addIfFound = (set, obj, key) => {
        const opts = resolveObjectKey(obj, key);
        void 0 !== opts && set.add(opts)
    };
    class chart_esm_Config {
        constructor(config) {
            this._config = function (config) {
                return (config = config || {}).data = initData(config.data), initOptions(config), config
            }(config), this._scopeCache = new Map, this._resolverCache = new Map
        }
        get platform() {
            return this._config.platform
        }
        get type() {
            return this._config.type
        }
        set type(type) {
            this._config.type = type
        }
        get data() {
            return this._config.data
        }
        set data(data) {
            this._config.data = initData(data)
        }
        get options() {
            return this._config.options
        }
        set options(options) {
            this._config.options = options
        }
        get plugins() {
            return this._config.plugins
        }
        update() {
            const config = this._config;
            this.clearCache(), initOptions(config)
        }
        clearCache() {
            this._scopeCache.clear(), this._resolverCache.clear()
        }
        datasetScopeKeys(datasetType) {
            return cachedKeys(datasetType, () => [
                ["datasets." + datasetType, ""]
            ])
        }
        datasetAnimationScopeKeys(datasetType, transition) {
            return cachedKeys(`${datasetType}.transition.${transition}`, () => [
                [`datasets.${datasetType}.transitions.${transition}`, "transitions." + transition],
                ["datasets." + datasetType, ""]
            ])
        }
        datasetElementScopeKeys(datasetType, elementType) {
            return cachedKeys(`${datasetType}-${elementType}`, () => [
                [`datasets.${datasetType}.elements.${elementType}`, "datasets." + datasetType, "elements." + elementType, ""]
            ])
        }
        pluginScopeKeys(plugin) {
            const id = plugin.id;
            return cachedKeys(`${this.type}-plugin-${id}`, () => [
                ["plugins." + id, ...plugin.additionalOptionScopes || []]
            ])
        }
        _cachedScopes(mainScope, resetCache) {
            const _scopeCache = this._scopeCache;
            let cache = _scopeCache.get(mainScope);
            return cache && !resetCache || (cache = new Map, _scopeCache.set(mainScope, cache)), cache
        }
        getOptionScopes(mainScope, keyLists, resetCache) {
            const {
                options: options,
                type: type
            } = this, cache = this._cachedScopes(mainScope, resetCache), cached = cache.get(keyLists);
            if (cached) return cached;
            const scopes = new Set;
            keyLists.forEach(keys => {
                mainScope && (scopes.add(mainScope), keys.forEach(key => addIfFound(scopes, mainScope, key))), keys.forEach(key => addIfFound(scopes, options, key)), keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key)), keys.forEach(key => addIfFound(scopes, defaults, key)), keys.forEach(key => addIfFound(scopes, helpers_segment_descriptors, key))
            });
            const array = Array.from(scopes);
            return 0 === array.length && array.push(Object.create(null)), keysCached.has(keyLists) && cache.set(keyLists, array), array
        }
        chartOptionScopes() {
            const {
                options: options,
                type: type
            } = this;
            return [options, overrides[type] || {}, defaults.datasets[type] || {}, {
                type: type
            }, defaults, helpers_segment_descriptors]
        }
        resolveNamedOptions(scopes, names, context, prefixes = [""]) {
            const result = {
                $shared: !0
            },
                {
                    resolver: resolver,
                    subPrefixes: subPrefixes
                } = getResolver(this._resolverCache, scopes, prefixes);
            let options = resolver;
            if (function (proxy, names) {
                const {
                    isScriptable: isScriptable,
                    isIndexable: isIndexable
                } = _descriptors(proxy);
                for (const prop of names) {
                    const scriptable = isScriptable(prop),
                        indexable = isIndexable(prop),
                        value = (indexable || scriptable) && proxy[prop];
                    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) return !0
                }
                return !1
            }(resolver, names)) {
                result.$shared = !1;
                options = _attachContext(resolver, context = isFunction(context) ? context() : context, this.createResolver(scopes, context, subPrefixes))
            }
            for (const prop of names) result[prop] = options[prop];
            return result
        }
        createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
            const {
                resolver: resolver
            } = getResolver(this._resolverCache, scopes, prefixes);
            return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver
        }
    }

    function getResolver(resolverCache, scopes, prefixes) {
        let cache = resolverCache.get(scopes);
        cache || (cache = new Map, resolverCache.set(scopes, cache));
        const cacheKey = prefixes.join();
        let cached = cache.get(cacheKey);
        if (!cached) {
            cached = {
                resolver: _createResolver(scopes, prefixes),
                subPrefixes: prefixes.filter(p => !p.toLowerCase().includes("hover"))
            }, cache.set(cacheKey, cached)
        }
        return cached
    }
    const hasFunction = value => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), !1);
    const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];

    function positionIsHorizontal(position, axis) {
        return "top" === position || "bottom" === position || -1 === KNOWN_POSITIONS.indexOf(position) && "x" === axis
    }

    function compare2Level(l1, l2) {
        return function (a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1]
        }
    }

    function onAnimationsComplete(context) {
        const chart = context.chart,
            animationOptions = chart.options.animation;
        chart.notifyPlugins("afterRender"), helpers_segment_callback(animationOptions && animationOptions.onComplete, [context], chart)
    }

    function onAnimationProgress(context) {
        const chart = context.chart,
            animationOptions = chart.options.animation;
        helpers_segment_callback(animationOptions && animationOptions.onProgress, [context], chart)
    }

    function getCanvas(item) {
        return _isDomSupported() && "string" == typeof item ? item = document.getElementById(item) : item && item.length && (item = item[0]), item && item.canvas && (item = item.canvas), item
    }
    const instances = {},
        getChart = key => {
            const canvas = getCanvas(key);
            return Object.values(instances).filter(c => c.canvas === canvas).pop()
        };
    class chart_esm_Chart {
        constructor(item, userConfig) {
            const config = this.config = new chart_esm_Config(userConfig),
                initialCanvas = getCanvas(item),
                existingChart = getChart(initialCanvas);
            if (existingChart) throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
            const options = config.createResolver(config.chartOptionScopes(), this.getContext());
            this.platform = new (config.platform || function (canvas) {
                return !_isDomSupported() || "undefined" != typeof OffscreenCanvas && canvas instanceof OffscreenCanvas ? BasicPlatform : chart_esm_DomPlatform
            }(initialCanvas)), this.platform.updateConfig(config);
            const context = this.platform.acquireContext(initialCanvas, options.aspectRatio),
                canvas = context && context.canvas,
                height = canvas && canvas.height,
                width = canvas && canvas.width;
            this.id = uid(), this.ctx = context, this.canvas = canvas, this.width = width, this.height = height, this._options = options, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new chart_esm_PluginService, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function (fn, delay) {
                let timeout;
                return function (...args) {
                    return delay ? (clearTimeout(timeout), timeout = setTimeout(fn, delay, args)) : fn.apply(this, args), delay
                }
            }(mode => this.update(mode), options.resizeDelay || 0), instances[this.id] = this, context && canvas && (animator.listen(this, "complete", onAnimationsComplete), animator.listen(this, "progress", onAnimationProgress), this._initialize(), this.attached && this.update())
        }
        get aspectRatio() {
            const {
                options: {
                    aspectRatio: aspectRatio,
                    maintainAspectRatio: maintainAspectRatio
                },
                width: width,
                height: height,
                _aspectRatio: _aspectRatio
            } = this;
            return isNullOrUndef(aspectRatio) ? maintainAspectRatio && _aspectRatio ? _aspectRatio : height ? width / height : null : aspectRatio
        }
        get data() {
            return this.config.data
        }
        set data(data) {
            this.config.data = data
        }
        get options() {
            return this._options
        }
        set options(options) {
            this.config.options = options
        }
        _initialize() {
            return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : retinaScale(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this
        }
        clear() {
            return clearCanvas(this.canvas, this.ctx), this
        }
        stop() {
            return animator.stop(this), this
        }
        resize(width, height) {
            animator.running(this) ? this._resizeBeforeDraw = {
                width: width,
                height: height
            } : this._resize(width, height)
        }
        _resize(width, height) {
            const options = this.options,
                canvas = this.canvas,
                aspectRatio = options.maintainAspectRatio && this.aspectRatio,
                newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio),
                newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio(),
                mode = this.width ? "resize" : "attach";
            this.width = newSize.width, this.height = newSize.height, this._aspectRatio = this.aspectRatio, retinaScale(this, newRatio, !0) && (this.notifyPlugins("resize", {
                size: newSize
            }), helpers_segment_callback(options.onResize, [this, newSize], this), this.attached && this._doResize(mode) && this.render())
        }
        ensureScalesHaveIDs() {
            each(this.options.scales || {}, (axisOptions, axisID) => {
                axisOptions.id = axisID
            })
        }
        buildOrUpdateScales() {
            const options = this.options,
                scaleOpts = options.scales,
                scales = this.scales,
                updated = Object.keys(scales).reduce((obj, id) => (obj[id] = !1, obj), {});
            let items = [];
            scaleOpts && (items = items.concat(Object.keys(scaleOpts).map(id => {
                const scaleOptions = scaleOpts[id],
                    axis = determineAxis(id, scaleOptions),
                    isRadial = "r" === axis,
                    isHorizontal = "x" === axis;
                return {
                    options: scaleOptions,
                    dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                    dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                }
            }))), each(items, item => {
                const scaleOptions = item.options,
                    id = scaleOptions.id,
                    axis = determineAxis(id, scaleOptions),
                    scaleType = valueOrDefault(scaleOptions.type, item.dtype);
                void 0 !== scaleOptions.position && positionIsHorizontal(scaleOptions.position, axis) === positionIsHorizontal(item.dposition) || (scaleOptions.position = item.dposition), updated[id] = !0;
                let scale = null;
                if (id in scales && scales[id].type === scaleType) scale = scales[id];
                else {
                    scale = new (chart_esm_registry.getScale(scaleType))({
                        id: id,
                        type: scaleType,
                        ctx: this.ctx,
                        chart: this
                    }), scales[scale.id] = scale
                }
                scale.init(scaleOptions, options)
            }), each(updated, (hasUpdated, id) => {
                hasUpdated || delete scales[id]
            }), each(scales, scale => {
                layouts.configure(this, scale, scale.options), layouts.addBox(this, scale)
            })
        }
        _updateMetasets() {
            const metasets = this._metasets,
                numData = this.data.datasets.length,
                numMeta = metasets.length;
            if (metasets.sort((a, b) => a.index - b.index), numMeta > numData) {
                for (let i = numData; i < numMeta; ++i) this._destroyDatasetMeta(i);
                metasets.splice(numData, numMeta - numData)
            }
            this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"))
        }
        _removeUnreferencedMetasets() {
            const {
                _metasets: metasets,
                data: {
                    datasets: datasets
                }
            } = this;
            metasets.length > datasets.length && delete this._stacks, metasets.forEach((meta, index) => {
                0 === datasets.filter(x => x === meta._dataset).length && this._destroyDatasetMeta(index)
            })
        }
        buildOrUpdateControllers() {
            const newControllers = [],
                datasets = this.data.datasets;
            let i, ilen;
            for (this._removeUnreferencedMetasets(), i = 0, ilen = datasets.length; i < ilen; i++) {
                const dataset = datasets[i];
                let meta = this.getDatasetMeta(i);
                const type = dataset.type || this.config.type;
                if (meta.type && meta.type !== type && (this._destroyDatasetMeta(i), meta = this.getDatasetMeta(i)), meta.type = type, meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options), meta.order = dataset.order || 0, meta.index = i, meta.label = "" + dataset.label, meta.visible = this.isDatasetVisible(i), meta.controller) meta.controller.updateIndex(i), meta.controller.linkScales();
                else {
                    const ControllerClass = chart_esm_registry.getController(type),
                        {
                            datasetElementType: datasetElementType,
                            dataElementType: dataElementType
                        } = defaults.datasets[type];
                    Object.assign(ControllerClass.prototype, {
                        dataElementType: chart_esm_registry.getElement(dataElementType),
                        datasetElementType: datasetElementType && chart_esm_registry.getElement(datasetElementType)
                    }), meta.controller = new ControllerClass(this, i), newControllers.push(meta.controller)
                }
            }
            return this._updateMetasets(), newControllers
        }
        _resetElements() {
            each(this.data.datasets, (dataset, datasetIndex) => {
                this.getDatasetMeta(datasetIndex).controller.reset()
            }, this)
        }
        reset() {
            this._resetElements(), this.notifyPlugins("reset")
        }
        update(mode) {
            const config = this.config;
            config.update();
            const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
            each(this.scales, scale => {
                layouts.removeBox(this, scale)
            });
            const animsDisabled = this._animationsDisabled = !options.animation;
            this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
            if (((a, b) => {
                if (a.size !== b.size) return !1;
                for (const item of a)
                    if (!b.has(item)) return !1;
                return !0
            })(new Set(Object.keys(this._listeners)), new Set(options.events)) && !!this._responsiveListeners === options.responsive || (this.unbindEvents(), this.bindEvents()), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", {
                mode: mode,
                cancelable: !0
            })) return;
            const newControllers = this.buildOrUpdateControllers();
            this.notifyPlugins("beforeElementsUpdate");
            let minPadding = 0;
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
                const {
                    controller: controller
                } = this.getDatasetMeta(i), reset = !animsDisabled && -1 === newControllers.indexOf(controller);
                controller.buildOrUpdateElements(reset), minPadding = Math.max(+controller.getMaxOverflow(), minPadding)
            }
            minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0, this._updateLayout(minPadding), animsDisabled || each(newControllers, controller => {
                controller.reset()
            }), this._updateDatasets(mode), this.notifyPlugins("afterUpdate", {
                mode: mode
            }), this._layers.sort(compare2Level("z", "_idx")), this._lastEvent && this._eventHandler(this._lastEvent, !0), this.render()
        }
        _updateLayout(minPadding) {
            if (!1 === this.notifyPlugins("beforeLayout", {
                cancelable: !0
            })) return;
            layouts.update(this, this.width, this.height, minPadding);
            const area = this.chartArea,
                noArea = area.width <= 0 || area.height <= 0;
            this._layers = [], each(this.boxes, box => {
                noArea && "chartArea" === box.position || (box.configure && box.configure(), this._layers.push(...box._layers()))
            }, this), this._layers.forEach((item, index) => {
                item._idx = index
            }), this.notifyPlugins("afterLayout")
        }
        _updateDatasets(mode) {
            if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
                mode: mode,
                cancelable: !0
            })) {
                for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) this._updateDataset(i, isFunction(mode) ? mode({
                    datasetIndex: i
                }) : mode);
                this.notifyPlugins("afterDatasetsUpdate", {
                    mode: mode
                })
            }
        }
        _updateDataset(index, mode) {
            const meta = this.getDatasetMeta(index),
                args = {
                    meta: meta,
                    index: index,
                    mode: mode,
                    cancelable: !0
                };
            !1 !== this.notifyPlugins("beforeDatasetUpdate", args) && (meta.controller._update(mode), args.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", args))
        }
        render() {
            !1 !== this.notifyPlugins("beforeRender", {
                cancelable: !0
            }) && (animator.has(this) ? this.attached && !animator.running(this) && animator.start(this) : (this.draw(), onAnimationsComplete({
                chart: this
            })))
        }
        draw() {
            let i;
            if (this._resizeBeforeDraw) {
                const {
                    width: width,
                    height: height
                } = this._resizeBeforeDraw;
                this._resize(width, height), this._resizeBeforeDraw = null
            }
            if (this.clear(), this.width <= 0 || this.height <= 0) return;
            if (!1 === this.notifyPlugins("beforeDraw", {
                cancelable: !0
            })) return;
            const layers = this._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) layers[i].draw(this.chartArea);
            for (this._drawDatasets(); i < layers.length; ++i) layers[i].draw(this.chartArea);
            this.notifyPlugins("afterDraw")
        }
        _getSortedDatasetMetas(filterVisible) {
            const metasets = this._sortedMetasets,
                result = [];
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) {
                const meta = metasets[i];
                filterVisible && !meta.visible || result.push(meta)
            }
            return result
        }
        getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(!0)
        }
        _drawDatasets() {
            if (!1 === this.notifyPlugins("beforeDatasetsDraw", {
                cancelable: !0
            })) return;
            const metasets = this.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) this._drawDataset(metasets[i]);
            this.notifyPlugins("afterDatasetsDraw")
        }
        _drawDataset(meta) {
            const ctx = this.ctx,
                clip = meta._clip,
                useClip = !clip.disabled,
                area = this.chartArea,
                args = {
                    meta: meta,
                    index: meta.index,
                    cancelable: !0
                };
            !1 !== this.notifyPlugins("beforeDatasetDraw", args) && (useClip && clipArea(ctx, {
                left: !1 === clip.left ? 0 : area.left - clip.left,
                right: !1 === clip.right ? this.width : area.right + clip.right,
                top: !1 === clip.top ? 0 : area.top - clip.top,
                bottom: !1 === clip.bottom ? this.height : area.bottom + clip.bottom
            }), meta.controller.draw(), useClip && unclipArea(ctx), args.cancelable = !1, this.notifyPlugins("afterDatasetDraw", args))
        }
        getElementsAtEventForMode(e, mode, options, useFinalPosition) {
            const method = Interaction.modes[mode];
            return "function" == typeof method ? method(this, e, options, useFinalPosition) : []
        }
        getDatasetMeta(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex],
                metasets = this._metasets;
            let meta = metasets.filter(x => x && x._dataset === dataset).pop();
            return meta || (meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: !1
            }, metasets.push(meta)), meta
        }
        getContext() {
            return this.$context || (this.$context = createContext(null, {
                chart: this,
                type: "chart"
            }))
        }
        getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length
        }
        isDatasetVisible(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            if (!dataset) return !1;
            const meta = this.getDatasetMeta(datasetIndex);
            return "boolean" == typeof meta.hidden ? !meta.hidden : !dataset.hidden
        }
        setDatasetVisibility(datasetIndex, visible) {
            this.getDatasetMeta(datasetIndex).hidden = !visible
        }
        toggleDataVisibility(index) {
            this._hiddenIndices[index] = !this._hiddenIndices[index]
        }
        getDataVisibility(index) {
            return !this._hiddenIndices[index]
        }
        _updateVisibility(datasetIndex, dataIndex, visible) {
            const mode = visible ? "show" : "hide",
                meta = this.getDatasetMeta(datasetIndex),
                anims = meta.controller._resolveAnimations(void 0, mode);
            defined(dataIndex) ? (meta.data[dataIndex].hidden = !visible, this.update()) : (this.setDatasetVisibility(datasetIndex, visible), anims.update(meta, {
                visible: visible
            }), this.update(ctx => ctx.datasetIndex === datasetIndex ? mode : void 0))
        }
        hide(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, !1)
        }
        show(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, !0)
        }
        _destroyDatasetMeta(datasetIndex) {
            const meta = this._metasets[datasetIndex];
            meta && meta.controller && meta.controller._destroy(), delete this._metasets[datasetIndex]
        }
        _stop() {
            let i, ilen;
            for (this.stop(), animator.remove(this), i = 0, ilen = this.data.datasets.length; i < ilen; ++i) this._destroyDatasetMeta(i)
        }
        destroy() {
            const {
                canvas: canvas,
                ctx: ctx
            } = this;
            this._stop(), this.config.clearCache(), canvas && (this.unbindEvents(), clearCanvas(canvas, ctx), this.platform.releaseContext(ctx), this.canvas = null, this.ctx = null), this.notifyPlugins("destroy"), delete instances[this.id]
        }
        toBase64Image(...args) {
            return this.canvas.toDataURL(...args)
        }
        bindEvents() {
            this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
        }
        bindUserEvents() {
            const listeners = this._listeners,
                platform = this.platform,
                _add = (type, listener) => {
                    platform.addEventListener(this, type, listener), listeners[type] = listener
                },
                listener = (e, x, y) => {
                    e.offsetX = x, e.offsetY = y, this._eventHandler(e)
                };
            each(this.options.events, type => _add(type, listener))
        }
        bindResponsiveEvents() {
            this._responsiveListeners || (this._responsiveListeners = {});
            const listeners = this._responsiveListeners,
                platform = this.platform,
                _add = (type, listener) => {
                    platform.addEventListener(this, type, listener), listeners[type] = listener
                },
                _remove = (type, listener) => {
                    listeners[type] && (platform.removeEventListener(this, type, listener), delete listeners[type])
                },
                listener = (width, height) => {
                    this.canvas && this.resize(width, height)
                };
            let detached;
            const attached = () => {
                _remove("attach", attached), this.attached = !0, this.resize(), _add("resize", listener), _add("detach", detached)
            };
            detached = () => {
                this.attached = !1, _remove("resize", listener), this._stop(), this._resize(0, 0), _add("attach", attached)
            }, platform.isAttached(this.canvas) ? attached() : detached()
        }
        unbindEvents() {
            each(this._listeners, (listener, type) => {
                this.platform.removeEventListener(this, type, listener)
            }), this._listeners = {}, each(this._responsiveListeners, (listener, type) => {
                this.platform.removeEventListener(this, type, listener)
            }), this._responsiveListeners = void 0
        }
        updateHoverStyle(items, mode, enabled) {
            const prefix = enabled ? "set" : "remove";
            let meta, item, i, ilen;
            for ("dataset" === mode && (meta = this.getDatasetMeta(items[0].datasetIndex), meta.controller["_" + prefix + "DatasetHoverStyle"]()), i = 0, ilen = items.length; i < ilen; ++i) {
                item = items[i];
                const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
                controller && controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index)
            }
        }
        getActiveElements() {
            return this._active || []
        }
        setActiveElements(activeElements) {
            const lastActive = this._active || [],
                active = activeElements.map(({
                    datasetIndex: datasetIndex,
                    index: index
                }) => {
                    const meta = this.getDatasetMeta(datasetIndex);
                    if (!meta) throw new Error("No dataset found at index " + datasetIndex);
                    return {
                        datasetIndex: datasetIndex,
                        element: meta.data[index],
                        index: index
                    }
                });
            !_elementsEqual(active, lastActive) && (this._active = active, this._updateHoverStyles(active, lastActive))
        }
        notifyPlugins(hook, args, filter) {
            return this._plugins.notify(this, hook, args, filter)
        }
        _updateHoverStyles(active, lastActive, replay) {
            const hoverOptions = this.options.hover,
                diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index)),
                deactivated = diff(lastActive, active),
                activated = replay ? active : diff(active, lastActive);
            deactivated.length && this.updateHoverStyle(deactivated, hoverOptions.mode, !1), activated.length && hoverOptions.mode && this.updateHoverStyle(activated, hoverOptions.mode, !0)
        }
        _eventHandler(e, replay) {
            const args = {
                event: e,
                replay: replay,
                cancelable: !0
            },
                eventFilter = plugin => (plugin.options.events || this.options.events).includes(e.native.type);
            if (!1 === this.notifyPlugins("beforeEvent", args, eventFilter)) return;
            const changed = this._handleEvent(e, replay);
            return args.cancelable = !1, this.notifyPlugins("afterEvent", args, eventFilter), (changed || args.changed) && this.render(), this
        }
        _handleEvent(e, replay) {
            const {
                _active: lastActive = [],
                options: options
            } = this, hoverOptions = options.hover, useFinalPosition = replay;
            let active = [],
                changed = !1,
                lastEvent = null;
            return "mouseout" !== e.type && (active = this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition), lastEvent = "click" === e.type ? this._lastEvent : e), this._lastEvent = null, _isPointInArea(e, this.chartArea, this._minPadding) && (helpers_segment_callback(options.onHover, [e, active, this], this), "mouseup" !== e.type && "click" !== e.type && "contextmenu" !== e.type || helpers_segment_callback(options.onClick, [e, active, this], this)), changed = !_elementsEqual(active, lastActive), (changed || replay) && (this._active = active, this._updateHoverStyles(active, lastActive, replay)), this._lastEvent = lastEvent, changed
        }
    }
    const invalidatePlugins = () => each(chart_esm_Chart.instances, chart => chart._plugins.invalidate());

    function clipArc(ctx, element, endAngle) {
        const {
            startAngle: startAngle,
            pixelMargin: pixelMargin,
            x: x,
            y: y,
            outerRadius: outerRadius,
            innerRadius: innerRadius
        } = element;
        let angleMargin = pixelMargin / outerRadius;
        ctx.beginPath(), ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin), innerRadius > pixelMargin ? (angleMargin = pixelMargin / innerRadius, ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, !0)) : ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI), ctx.closePath(), ctx.clip()
    }

    function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
        const o = _readValueToProps(arc.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
        const halfThickness = (outerRadius - innerRadius) / 2,
            innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2),
            computeOuterLimit = val => {
                const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
                return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit))
            };
        return {
            outerStart: computeOuterLimit(o.outerStart),
            outerEnd: computeOuterLimit(o.outerEnd),
            innerStart: _limitValue(o.innerStart, 0, innerLimit),
            innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
        }
    }

    function rThetaToXY(r, theta, x, y) {
        return {
            x: x + r * Math.cos(theta),
            y: y + r * Math.sin(theta)
        }
    }

    function pathArc(ctx, element, offset, spacing, end) {
        const {
            x: x,
            y: y,
            startAngle: start,
            pixelMargin: pixelMargin,
            innerRadius: innerR
        } = element, outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0), innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
        let spacingOffset = 0;
        const alpha = end - start;
        if (spacing) {
            const avNogSpacingRadius = ((innerR > 0 ? innerR - spacing : 0) + (outerRadius > 0 ? outerRadius - spacing : 0)) / 2;
            spacingOffset = (alpha - (0 !== avNogSpacingRadius ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha)) / 2
        }
        const angleOffset = (alpha - Math.max(.001, alpha * outerRadius - offset / PI) / outerRadius) / 2,
            startAngle = start + angleOffset + spacingOffset,
            endAngle = end - angleOffset - spacingOffset,
            {
                outerStart: outerStart,
                outerEnd: outerEnd,
                innerStart: innerStart,
                innerEnd: innerEnd
            } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle),
            outerStartAdjustedRadius = outerRadius - outerStart,
            outerEndAdjustedRadius = outerRadius - outerEnd,
            outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius,
            outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius,
            innerStartAdjustedRadius = innerRadius + innerStart,
            innerEndAdjustedRadius = innerRadius + innerEnd,
            innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius,
            innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
        if (ctx.beginPath(), ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle), outerEnd > 0) {
            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI)
        }
        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
        if (ctx.lineTo(p4.x, p4.y), innerEnd > 0) {
            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI)
        }
        if (ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, !0), innerStart > 0) {
            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI)
        }
        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
        if (ctx.lineTo(p8.x, p8.y), outerStart > 0) {
            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle)
        }
        ctx.closePath()
    }

    function drawBorder(ctx, element, offset, spacing, endAngle) {
        const {
            options: options
        } = element, inner = "inner" === options.borderAlign;
        options.borderWidth && (inner ? (ctx.lineWidth = 2 * options.borderWidth, ctx.lineJoin = "round") : (ctx.lineWidth = options.borderWidth, ctx.lineJoin = "bevel"), element.fullCircles && function (ctx, element, inner) {
            const {
                x: x,
                y: y,
                startAngle: startAngle,
                pixelMargin: pixelMargin,
                fullCircles: fullCircles
            } = element, outerRadius = Math.max(element.outerRadius - pixelMargin, 0), innerRadius = element.innerRadius + pixelMargin;
            let i;
            for (inner && clipArc(ctx, element, startAngle + TAU), ctx.beginPath(), ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, !0), i = 0; i < fullCircles; ++i) ctx.stroke();
            for (ctx.beginPath(), ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU), i = 0; i < fullCircles; ++i) ctx.stroke()
        }(ctx, element, inner), inner && clipArc(ctx, element, endAngle), pathArc(ctx, element, offset, spacing, endAngle), ctx.stroke())
    }
    Object.defineProperties(chart_esm_Chart, {
        defaults: {
            enumerable: !0,
            value: defaults
        },
        instances: {
            enumerable: !0,
            value: instances
        },
        overrides: {
            enumerable: !0,
            value: overrides
        },
        registry: {
            enumerable: !0,
            value: chart_esm_registry
        },
        version: {
            enumerable: !0,
            value: "3.6.0"
        },
        getChart: {
            enumerable: !0,
            value: getChart
        },
        register: {
            enumerable: !0,
            value: (...items) => {
                chart_esm_registry.add(...items), invalidatePlugins()
            }
        },
        unregister: {
            enumerable: !0,
            value: (...items) => {
                chart_esm_registry.remove(...items), invalidatePlugins()
            }
        }
    });
    class chart_esm_ArcElement extends chart_esm_Element {
        constructor(cfg) {
            super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, cfg && Object.assign(this, cfg)
        }
        inRange(chartX, chartY, useFinalPosition) {
            const point = this.getProps(["x", "y"], useFinalPosition),
                {
                    angle: angle,
                    distance: distance
                } = function (centrePoint, anglePoint) {
                    const distanceFromXCenter = anglePoint.x - centrePoint.x,
                        distanceFromYCenter = anglePoint.y - centrePoint.y,
                        radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
                    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
                    return angle < -.5 * PI && (angle += TAU), {
                        angle: angle,
                        distance: radialDistanceFromCenter
                    }
                }(point, {
                    x: chartX,
                    y: chartY
                }),
                {
                    startAngle: startAngle,
                    endAngle: endAngle,
                    innerRadius: innerRadius,
                    outerRadius: outerRadius,
                    circumference: circumference
                } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], useFinalPosition),
                rAdjust = this.options.spacing / 2;
            return (circumference >= TAU || _angleBetween(angle, startAngle, endAngle)) && (distance >= innerRadius + rAdjust && distance <= outerRadius + rAdjust)
        }
        getCenterPoint(useFinalPosition) {
            const {
                x: x,
                y: y,
                startAngle: startAngle,
                endAngle: endAngle,
                innerRadius: innerRadius,
                outerRadius: outerRadius
            } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], useFinalPosition), {
                offset: offset,
                spacing: spacing
            } = this.options, halfAngle = (startAngle + endAngle) / 2, halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
            return {
                x: x + Math.cos(halfAngle) * halfRadius,
                y: y + Math.sin(halfAngle) * halfRadius
            }
        }
        tooltipPosition(useFinalPosition) {
            return this.getCenterPoint(useFinalPosition)
        }
        draw(ctx) {
            const {
                options: options,
                circumference: circumference
            } = this, offset = (options.offset || 0) / 2, spacing = (options.spacing || 0) / 2;
            if (this.pixelMargin = "inner" === options.borderAlign ? .33 : 0, this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0, 0 === circumference || this.innerRadius < 0 || this.outerRadius < 0) return;
            ctx.save();
            let radiusOffset = 0;
            if (offset) {
                radiusOffset = offset / 2;
                const halfAngle = (this.startAngle + this.endAngle) / 2;
                ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset), this.circumference >= PI && (radiusOffset = offset)
            }
            ctx.fillStyle = options.backgroundColor, ctx.strokeStyle = options.borderColor;
            const endAngle = function (ctx, element, offset, spacing) {
                const {
                    fullCircles: fullCircles,
                    startAngle: startAngle,
                    circumference: circumference
                } = element;
                let endAngle = element.endAngle;
                if (fullCircles) {
                    pathArc(ctx, element, offset, spacing, startAngle + TAU);
                    for (let i = 0; i < fullCircles; ++i) ctx.fill();
                    isNaN(circumference) || (endAngle = startAngle + circumference % TAU, circumference % TAU == 0 && (endAngle += TAU))
                }
                return pathArc(ctx, element, offset, spacing, endAngle), ctx.fill(), endAngle
            }(ctx, this, radiusOffset, spacing);
            drawBorder(ctx, this, radiusOffset, spacing, endAngle), ctx.restore()
        }
    }

    function setStyle(ctx, options, style = options) {
        ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle), ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash)), ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset), ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle), ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth), ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor)
    }

    function lineTo(ctx, previous, target) {
        ctx.lineTo(target.x, target.y)
    }

    function pathVars(points, segment, params = {}) {
        const count = points.length,
            {
                start: paramsStart = 0,
                end: paramsEnd = count - 1
            } = params,
            {
                start: segmentStart,
                end: segmentEnd
            } = segment,
            start = Math.max(paramsStart, segmentStart),
            end = Math.min(paramsEnd, segmentEnd),
            outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
        return {
            count: count,
            start: start,
            loop: segment.loop,
            ilen: end < start && !outside ? count + end - start : end - start
        }
    }

    function pathSegment(ctx, line, segment, params) {
        const {
            points: points,
            options: options
        } = line, {
            count: count,
            start: start,
            loop: loop,
            ilen: ilen
        } = pathVars(points, segment, params), lineMethod = function (options) {
            return options.stepped ? _steppedLineTo : options.tension || "monotone" === options.cubicInterpolationMode ? _bezierCurveTo : lineTo
        }(options);
        let i, point, prev, {
            move: move = !0,
            reverse: reverse
        } = params || {};
        for (i = 0; i <= ilen; ++i) point = points[(start + (reverse ? ilen - i : i)) % count], point.skip || (move ? (ctx.moveTo(point.x, point.y), move = !1) : lineMethod(ctx, prev, point, reverse, options.stepped), prev = point);
        return loop && (point = points[(start + (reverse ? ilen : 0)) % count], lineMethod(ctx, prev, point, reverse, options.stepped)), !!loop
    }

    function fastPathSegment(ctx, line, segment, params) {
        const points = line.points,
            {
                count: count,
                start: start,
                ilen: ilen
            } = pathVars(points, segment, params),
            {
                move: move = !0,
                reverse: reverse
            } = params || {};
        let i, point, prevX, minY, maxY, lastY, avgX = 0,
            countX = 0;
        const pointIndex = index => (start + (reverse ? ilen - index : index)) % count,
            drawX = () => {
                minY !== maxY && (ctx.lineTo(avgX, maxY), ctx.lineTo(avgX, minY), ctx.lineTo(avgX, lastY))
            };
        for (move && (point = points[pointIndex(0)], ctx.moveTo(point.x, point.y)), i = 0; i <= ilen; ++i) {
            if (point = points[pointIndex(i)], point.skip) continue;
            const x = point.x,
                y = point.y,
                truncX = 0 | x;
            truncX === prevX ? (y < minY ? minY = y : y > maxY && (maxY = y), avgX = (countX * avgX + x) / ++countX) : (drawX(), ctx.lineTo(x, y), prevX = truncX, countX = 0, minY = maxY = y), lastY = y
        }
        drawX()
    }

    function _getSegmentMethod(line) {
        const opts = line.options,
            borderDash = opts.borderDash && opts.borderDash.length;
        return !(line._decimated || line._loop || opts.tension || "monotone" === opts.cubicInterpolationMode || opts.stepped || borderDash) ? fastPathSegment : pathSegment
    }
    chart_esm_ArcElement.id = "arc", chart_esm_ArcElement.defaults = {
        borderAlign: "center",
        borderColor: "#fff",
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: void 0
    }, chart_esm_ArcElement.defaultRoutes = {
        backgroundColor: "backgroundColor"
    };
    const usePath2D = "function" == typeof Path2D;

    function draw(ctx, line, start, count) {
        usePath2D && !line.options.segment ? function (ctx, line, start, count) {
            let path = line._path;
            path || (path = line._path = new Path2D, line.path(path, start, count) && path.closePath()), setStyle(ctx, line.options), ctx.stroke(path)
        }(ctx, line, start, count) : function (ctx, line, start, count) {
            const {
                segments: segments,
                options: options
            } = line, segmentMethod = _getSegmentMethod(line);
            for (const segment of segments) setStyle(ctx, options, segment.style), ctx.beginPath(), segmentMethod(ctx, line, segment, {
                start: start,
                end: start + count - 1
            }) && ctx.closePath(), ctx.stroke()
        }(ctx, line, start, count)
    }
    class chart_esm_LineElement extends chart_esm_Element {
        constructor(cfg) {
            super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, cfg && Object.assign(this, cfg)
        }
        updateControlPoints(chartArea, indexAxis) {
            const options = this.options;
            if ((options.tension || "monotone" === options.cubicInterpolationMode) && !options.stepped && !this._pointsUpdated) {
                const loop = options.spanGaps ? this._loop : this._fullLoop;
                _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis), this._pointsUpdated = !0
            }
        }
        set points(points) {
            this._points = points, delete this._segments, delete this._path, this._pointsUpdated = !1
        }
        get points() {
            return this._points
        }
        get segments() {
            return this._segments || (this._segments = function (line, segmentOptions) {
                const points = line.points,
                    spanGaps = line.options.spanGaps,
                    count = points.length;
                if (!count) return [];
                const loop = !!line._loop,
                    {
                        start: start,
                        end: end
                    } = function (points, count, loop, spanGaps) {
                        let start = 0,
                            end = count - 1;
                        if (loop && !spanGaps)
                            for (; start < count && !points[start].skip;) start++;
                        for (; start < count && points[start].skip;) start++;
                        for (start %= count, loop && (end += start); end > start && points[end % count].skip;) end--;
                        return end %= count, {
                            start: start,
                            end: end
                        }
                    }(points, count, loop, spanGaps);
                return splitByStyles(line, !0 === spanGaps ? [{
                    start: start,
                    end: end,
                    loop: loop
                }] : function (points, start, max, loop) {
                    const count = points.length,
                        result = [];
                    let end, last = start,
                        prev = points[start];
                    for (end = start + 1; end <= max; ++end) {
                        const cur = points[end % count];
                        cur.skip || cur.stop ? prev.skip || (loop = !1, result.push({
                            start: start % count,
                            end: (end - 1) % count,
                            loop: loop
                        }), start = last = cur.stop ? end : null) : (last = end, prev.skip && (start = end)), prev = cur
                    }
                    return null !== last && result.push({
                        start: start % count,
                        end: last % count,
                        loop: loop
                    }), result
                }(points, start, end < start ? end + count : end, !!line._fullLoop && 0 === start && end === count - 1), points, segmentOptions)
            }(this, this.options.segment))
        }
        first() {
            const segments = this.segments,
                points = this.points;
            return segments.length && points[segments[0].start]
        }
        last() {
            const segments = this.segments,
                points = this.points,
                count = segments.length;
            return count && points[segments[count - 1].end]
        }
        interpolate(point, property) {
            const options = this.options,
                value = point[property],
                points = this.points,
                segments = _boundSegments(this, {
                    property: property,
                    start: value,
                    end: value
                });
            if (!segments.length) return;
            const result = [],
                _interpolate = function (options) {
                    return options.stepped ? _steppedInterpolation : options.tension || "monotone" === options.cubicInterpolationMode ? _bezierInterpolation : _pointInLine
                }(options);
            let i, ilen;
            for (i = 0, ilen = segments.length; i < ilen; ++i) {
                const {
                    start: start,
                    end: end
                } = segments[i], p1 = points[start], p2 = points[end];
                if (p1 === p2) {
                    result.push(p1);
                    continue
                }
                const interpolated = _interpolate(p1, p2, Math.abs((value - p1[property]) / (p2[property] - p1[property])), options.stepped);
                interpolated[property] = point[property], result.push(interpolated)
            }
            return 1 === result.length ? result[0] : result
        }
        pathSegment(ctx, segment, params) {
            return _getSegmentMethod(this)(ctx, this, segment, params)
        }
        path(ctx, start, count) {
            const segments = this.segments,
                segmentMethod = _getSegmentMethod(this);
            let loop = this._loop;
            start = start || 0, count = count || this.points.length - start;
            for (const segment of segments) loop &= segmentMethod(ctx, this, segment, {
                start: start,
                end: start + count - 1
            });
            return !!loop
        }
        draw(ctx, chartArea, start, count) {
            const options = this.options || {};
            (this.points || []).length && options.borderWidth && (ctx.save(), draw(ctx, this, start, count), ctx.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0)
        }
    }

    function inRange$1(el, pos, axis, useFinalPosition) {
        const options = el.options,
            {
                [axis]: value
            } = el.getProps([axis], useFinalPosition);
        return Math.abs(pos - value) < options.radius + options.hitRadius
    }
    chart_esm_LineElement.id = "line", chart_esm_LineElement.defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: !0,
        cubicInterpolationMode: "default",
        fill: !1,
        spanGaps: !1,
        stepped: !1,
        tension: 0
    }, chart_esm_LineElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    }, chart_esm_LineElement.descriptors = {
        _scriptable: !0,
        _indexable: name => "borderDash" !== name && "fill" !== name
    };
    class chart_esm_PointElement extends chart_esm_Element {
        constructor(cfg) {
            super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, cfg && Object.assign(this, cfg)
        }
        inRange(mouseX, mouseY, useFinalPosition) {
            const options = this.options,
                {
                    x: x,
                    y: y
                } = this.getProps(["x", "y"], useFinalPosition);
            return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2)
        }
        inXRange(mouseX, useFinalPosition) {
            return inRange$1(this, mouseX, "x", useFinalPosition)
        }
        inYRange(mouseY, useFinalPosition) {
            return inRange$1(this, mouseY, "y", useFinalPosition)
        }
        getCenterPoint(useFinalPosition) {
            const {
                x: x,
                y: y
            } = this.getProps(["x", "y"], useFinalPosition);
            return {
                x: x,
                y: y
            }
        }
        size(options) {
            let radius = (options = options || this.options || {}).radius || 0;
            radius = Math.max(radius, radius && options.hoverRadius || 0);
            return 2 * (radius + (radius && options.borderWidth || 0))
        }
        draw(ctx, area) {
            const options = this.options;
            this.skip || options.radius < .1 || !_isPointInArea(this, area, this.size(options) / 2) || (ctx.strokeStyle = options.borderColor, ctx.lineWidth = options.borderWidth, ctx.fillStyle = options.backgroundColor, drawPoint(ctx, options, this.x, this.y))
        }
        getRange() {
            const options = this.options || {};
            return options.radius + options.hitRadius
        }
    }

    function getBarBounds(bar, useFinalPosition) {
        const {
            x: x,
            y: y,
            base: base,
            width: width,
            height: height
        } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
        let left, right, top, bottom, half;
        return bar.horizontal ? (half = height / 2, left = Math.min(x, base), right = Math.max(x, base), top = y - half, bottom = y + half) : (half = width / 2, left = x - half, right = x + half, top = Math.min(y, base), bottom = Math.max(y, base)), {
            left: left,
            top: top,
            right: right,
            bottom: bottom
        }
    }

    function skipOrLimit(skip, value, min, max) {
        return skip ? 0 : _limitValue(value, min, max)
    }

    function boundingRects(bar) {
        const bounds = getBarBounds(bar),
            width = bounds.right - bounds.left,
            height = bounds.bottom - bounds.top,
            border = function (bar, maxW, maxH) {
                const value = bar.options.borderWidth,
                    skip = bar.borderSkipped,
                    o = toTRBL(value);
                return {
                    t: skipOrLimit(skip.top, o.top, 0, maxH),
                    r: skipOrLimit(skip.right, o.right, 0, maxW),
                    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
                    l: skipOrLimit(skip.left, o.left, 0, maxW)
                }
            }(bar, width / 2, height / 2),
            radius = function (bar, maxW, maxH) {
                const {
                    enableBorderRadius: enableBorderRadius
                } = bar.getProps(["enableBorderRadius"]), value = bar.options.borderRadius, o = toTRBLCorners(value), maxR = Math.min(maxW, maxH), skip = bar.borderSkipped, enableBorder = enableBorderRadius || isObject(value);
                return {
                    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
                    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
                    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
                    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
                }
            }(bar, width / 2, height / 2);
        return {
            outer: {
                x: bounds.left,
                y: bounds.top,
                w: width,
                h: height,
                radius: radius
            },
            inner: {
                x: bounds.left + border.l,
                y: bounds.top + border.t,
                w: width - border.l - border.r,
                h: height - border.t - border.b,
                radius: {
                    topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                    topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                    bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                    bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
                }
            }
        }
    }

    function inRange(bar, x, y, useFinalPosition) {
        const skipX = null === x,
            skipY = null === y,
            bounds = bar && !(skipX && skipY) && getBarBounds(bar, useFinalPosition);
        return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom)
    }

    function addNormalRectPath(ctx, rect) {
        ctx.rect(rect.x, rect.y, rect.w, rect.h)
    }

    function inflateRect(rect, amount, refRect = {}) {
        const x = rect.x !== refRect.x ? -amount : 0,
            y = rect.y !== refRect.y ? -amount : 0,
            w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x,
            h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
        return {
            x: rect.x + x,
            y: rect.y + y,
            w: rect.w + w,
            h: rect.h + h,
            radius: rect.radius
        }
    }
    chart_esm_PointElement.id = "point", chart_esm_PointElement.defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
    }, chart_esm_PointElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    class chart_esm_BarElement extends chart_esm_Element {
        constructor(cfg) {
            super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, cfg && Object.assign(this, cfg)
        }
        draw(ctx) {
            const {
                inflateAmount: inflateAmount,
                options: {
                    borderColor: borderColor,
                    backgroundColor: backgroundColor
                }
            } = this, {
                inner: inner,
                outer: outer
            } = boundingRects(this), addRectPath = (radius = outer.radius).topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight ? addRoundedRectPath : addNormalRectPath;
            var radius;
            ctx.save(), outer.w === inner.w && outer.h === inner.h || (ctx.beginPath(), addRectPath(ctx, inflateRect(outer, inflateAmount, inner)), ctx.clip(), addRectPath(ctx, inflateRect(inner, -inflateAmount, outer)), ctx.fillStyle = borderColor, ctx.fill("evenodd")), ctx.beginPath(), addRectPath(ctx, inflateRect(inner, inflateAmount)), ctx.fillStyle = backgroundColor, ctx.fill(), ctx.restore()
        }
        inRange(mouseX, mouseY, useFinalPosition) {
            return inRange(this, mouseX, mouseY, useFinalPosition)
        }
        inXRange(mouseX, useFinalPosition) {
            return inRange(this, mouseX, null, useFinalPosition)
        }
        inYRange(mouseY, useFinalPosition) {
            return inRange(this, null, mouseY, useFinalPosition)
        }
        getCenterPoint(useFinalPosition) {
            const {
                x: x,
                y: y,
                base: base,
                horizontal: horizontal
            } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
            return {
                x: horizontal ? (x + base) / 2 : x,
                y: horizontal ? y : (y + base) / 2
            }
        }
        getRange(axis) {
            return "x" === axis ? this.width / 2 : this.height / 2
        }
    }
    chart_esm_BarElement.id = "bar", chart_esm_BarElement.defaults = {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: "auto",
        pointStyle: void 0
    }, chart_esm_BarElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    new WeakMap;
    const positioners = {
        average(items) {
            if (!items.length) return !1;
            let i, len, x = 0,
                y = 0,
                count = 0;
            for (i = 0, len = items.length; i < len; ++i) {
                const el = items[i].element;
                if (el && el.hasValue()) {
                    const pos = el.tooltipPosition();
                    x += pos.x, y += pos.y, ++count
                }
            }
            return {
                x: x / count,
                y: y / count
            }
        },
        nearest(items, eventPosition) {
            if (!items.length) return !1;
            let i, len, nearestElement, x = eventPosition.x,
                y = eventPosition.y,
                minDistance = Number.POSITIVE_INFINITY;
            for (i = 0, len = items.length; i < len; ++i) {
                const el = items[i].element;
                if (el && el.hasValue()) {
                    const d = distanceBetweenPoints(eventPosition, el.getCenterPoint());
                    d < minDistance && (minDistance = d, nearestElement = el)
                }
            }
            if (nearestElement) {
                const tp = nearestElement.tooltipPosition();
                x = tp.x, y = tp.y
            }
            return {
                x: x,
                y: y
            }
        }
    };

    function pushOrConcat(base, toPush) {
        return toPush && (isArray(toPush) ? Array.prototype.push.apply(base, toPush) : base.push(toPush)), base
    }

    function splitNewlines(str) {
        return ("string" == typeof str || str instanceof String) && str.indexOf("\n") > -1 ? str.split("\n") : str
    }

    function createTooltipItem(chart, item) {
        const {
            element: element,
            datasetIndex: datasetIndex,
            index: index
        } = item, controller = chart.getDatasetMeta(datasetIndex).controller, {
            label: label,
            value: value
        } = controller.getLabelAndValue(index);
        return {
            chart: chart,
            label: label,
            parsed: controller.getParsed(index),
            raw: chart.data.datasets[datasetIndex].data[index],
            formattedValue: value,
            dataset: controller.getDataset(),
            dataIndex: index,
            datasetIndex: datasetIndex,
            element: element
        }
    }

    function getTooltipSize(tooltip, options) {
        const ctx = tooltip._chart.ctx,
            {
                body: body,
                footer: footer,
                title: title
            } = tooltip,
            {
                boxWidth: boxWidth,
                boxHeight: boxHeight
            } = options,
            bodyFont = toFont(options.bodyFont),
            titleFont = toFont(options.titleFont),
            footerFont = toFont(options.footerFont),
            titleLineCount = title.length,
            footerLineCount = footer.length,
            bodyLineItemCount = body.length,
            padding = toPadding(options.padding);
        let height = padding.height,
            width = 0,
            combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
        if (combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length, titleLineCount && (height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom), combinedBodyLength) {
            height += bodyLineItemCount * (options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight) + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing
        }
        footerLineCount && (height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing);
        let widthPadding = 0;
        const maxLineWidth = function (line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding)
        };
        return ctx.save(), ctx.font = titleFont.string, each(tooltip.title, maxLineWidth), ctx.font = bodyFont.string, each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth), widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0, each(body, bodyItem => {
            each(bodyItem.before, maxLineWidth), each(bodyItem.lines, maxLineWidth), each(bodyItem.after, maxLineWidth)
        }), widthPadding = 0, ctx.font = footerFont.string, each(tooltip.footer, maxLineWidth), ctx.restore(), width += padding.width, {
            width: width,
            height: height
        }
    }

    function determineXAlign(chart, options, size, yAlign) {
        const {
            x: x,
            width: width
        } = size, {
            width: chartWidth,
            chartArea: {
                left: left,
                right: right
            }
        } = chart;
        let xAlign = "center";
        return "center" === yAlign ? xAlign = x <= (left + right) / 2 ? "left" : "right" : x <= width / 2 ? xAlign = "left" : x >= chartWidth - width / 2 && (xAlign = "right"),
            function (xAlign, chart, options, size) {
                const {
                    x: x,
                    width: width
                } = size, caret = options.caretSize + options.caretPadding;
                return "left" === xAlign && x + width + caret > chart.width || ("right" === xAlign && x - width - caret < 0 || void 0)
            }(xAlign, chart, options, size) && (xAlign = "center"), xAlign
    }

    function determineAlignment(chart, options, size) {
        const yAlign = options.yAlign || function (chart, size) {
            const {
                y: y,
                height: height
            } = size;
            return y < height / 2 ? "top" : y > chart.height - height / 2 ? "bottom" : "center"
        }(chart, size);
        return {
            xAlign: options.xAlign || determineXAlign(chart, options, size, yAlign),
            yAlign: yAlign
        }
    }

    function getBackgroundPoint(options, size, alignment, chart) {
        const {
            caretSize: caretSize,
            caretPadding: caretPadding,
            cornerRadius: cornerRadius
        } = options, {
            xAlign: xAlign,
            yAlign: yAlign
        } = alignment, paddingAndSize = caretSize + caretPadding, {
            topLeft: topLeft,
            topRight: topRight,
            bottomLeft: bottomLeft,
            bottomRight: bottomRight
        } = toTRBLCorners(cornerRadius);
        let x = function (size, xAlign) {
            let {
                x: x,
                width: width
            } = size;
            return "right" === xAlign ? x -= width : "center" === xAlign && (x -= width / 2), x
        }(size, xAlign);
        const y = function (size, yAlign, paddingAndSize) {
            let {
                y: y,
                height: height
            } = size;
            return "top" === yAlign ? y += paddingAndSize : y -= "bottom" === yAlign ? height + paddingAndSize : height / 2, y
        }(size, yAlign, paddingAndSize);
        return "center" === yAlign ? "left" === xAlign ? x += paddingAndSize : "right" === xAlign && (x -= paddingAndSize) : "left" === xAlign ? x -= Math.max(topLeft, bottomLeft) + caretPadding : "right" === xAlign && (x += Math.max(topRight, bottomRight) + caretPadding), {
            x: _limitValue(x, 0, chart.width - size.width),
            y: _limitValue(y, 0, chart.height - size.height)
        }
    }

    function getAlignedX(tooltip, align, options) {
        const padding = toPadding(options.padding);
        return "center" === align ? tooltip.x + tooltip.width / 2 : "right" === align ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left
    }

    function getBeforeAfterBodyLines(callback) {
        return pushOrConcat([], splitNewlines(callback))
    }

    function overrideCallbacks(callbacks, context) {
        const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
        return override ? callbacks.override(override) : callbacks
    }
    class chart_esm_Tooltip extends chart_esm_Element {
        constructor(config) {
            super(), this.opacity = 0, this._active = [], this._chart = config._chart, this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.options = config.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0
        }
        initialize(options) {
            this.options = options, this._cachedAnimations = void 0, this.$context = void 0
        }
        _resolveAnimations() {
            const cached = this._cachedAnimations;
            if (cached) return cached;
            const chart = this._chart,
                options = this.options.setContext(this.getContext()),
                opts = options.enabled && chart.options.animation && options.animations,
                animations = new chart_esm_Animations(this._chart, opts);
            return opts._cacheable && (this._cachedAnimations = Object.freeze(animations)), animations
        }
        getContext() {
            return this.$context || (this.$context = (parent = this._chart.getContext(), tooltip = this, tooltipItems = this._tooltipItems, createContext(parent, {
                tooltip: tooltip,
                tooltipItems: tooltipItems,
                type: "tooltip"
            })));
            var parent, tooltip, tooltipItems
        }
        getTitle(context, options) {
            const {
                callbacks: callbacks
            } = options, beforeTitle = callbacks.beforeTitle.apply(this, [context]), title = callbacks.title.apply(this, [context]), afterTitle = callbacks.afterTitle.apply(this, [context]);
            let lines = [];
            return lines = pushOrConcat(lines, splitNewlines(beforeTitle)), lines = pushOrConcat(lines, splitNewlines(title)), lines = pushOrConcat(lines, splitNewlines(afterTitle)), lines
        }
        getBeforeBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]))
        }
        getBody(tooltipItems, options) {
            const {
                callbacks: callbacks
            } = options, bodyItems = [];
            return each(tooltipItems, context => {
                const bodyItem = {
                    before: [],
                    lines: [],
                    after: []
                },
                    scoped = overrideCallbacks(callbacks, context);
                pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context))), pushOrConcat(bodyItem.lines, scoped.label.call(this, context)), pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context))), bodyItems.push(bodyItem)
            }), bodyItems
        }
        getAfterBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]))
        }
        getFooter(tooltipItems, options) {
            const {
                callbacks: callbacks
            } = options, beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]), footer = callbacks.footer.apply(this, [tooltipItems]), afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
            let lines = [];
            return lines = pushOrConcat(lines, splitNewlines(beforeFooter)), lines = pushOrConcat(lines, splitNewlines(footer)), lines = pushOrConcat(lines, splitNewlines(afterFooter)), lines
        }
        _createItems(options) {
            const active = this._active,
                data = this._chart.data,
                labelColors = [],
                labelPointStyles = [],
                labelTextColors = [];
            let i, len, tooltipItems = [];
            for (i = 0, len = active.length; i < len; ++i) tooltipItems.push(createTooltipItem(this._chart, active[i]));
            return options.filter && (tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data))), options.itemSort && (tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data))), each(tooltipItems, context => {
                const scoped = overrideCallbacks(options.callbacks, context);
                labelColors.push(scoped.labelColor.call(this, context)), labelPointStyles.push(scoped.labelPointStyle.call(this, context)), labelTextColors.push(scoped.labelTextColor.call(this, context))
            }), this.labelColors = labelColors, this.labelPointStyles = labelPointStyles, this.labelTextColors = labelTextColors, this.dataPoints = tooltipItems, tooltipItems
        }
        update(changed, replay) {
            const options = this.options.setContext(this.getContext()),
                active = this._active;
            let properties, tooltipItems = [];
            if (active.length) {
                const position = positioners[options.position].call(this, active, this._eventPosition);
                tooltipItems = this._createItems(options), this.title = this.getTitle(tooltipItems, options), this.beforeBody = this.getBeforeBody(tooltipItems, options), this.body = this.getBody(tooltipItems, options), this.afterBody = this.getAfterBody(tooltipItems, options), this.footer = this.getFooter(tooltipItems, options);
                const size = this._size = getTooltipSize(this, options),
                    positionAndSize = Object.assign({}, position, size),
                    alignment = determineAlignment(this._chart, options, positionAndSize),
                    backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this._chart);
                this.xAlign = alignment.xAlign, this.yAlign = alignment.yAlign, properties = {
                    opacity: 1,
                    x: backgroundPoint.x,
                    y: backgroundPoint.y,
                    width: size.width,
                    height: size.height,
                    caretX: position.x,
                    caretY: position.y
                }
            } else 0 !== this.opacity && (properties = {
                opacity: 0
            });
            this._tooltipItems = tooltipItems, this.$context = void 0, properties && this._resolveAnimations().update(this, properties), changed && options.external && options.external.call(this, {
                chart: this._chart,
                tooltip: this,
                replay: replay
            })
        }
        drawCaret(tooltipPoint, ctx, size, options) {
            const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
            ctx.lineTo(caretPosition.x1, caretPosition.y1), ctx.lineTo(caretPosition.x2, caretPosition.y2), ctx.lineTo(caretPosition.x3, caretPosition.y3)
        }
        getCaretPosition(tooltipPoint, size, options) {
            const {
                xAlign: xAlign,
                yAlign: yAlign
            } = this, {
                caretSize: caretSize,
                cornerRadius: cornerRadius
            } = options, {
                topLeft: topLeft,
                topRight: topRight,
                bottomLeft: bottomLeft,
                bottomRight: bottomRight
            } = toTRBLCorners(cornerRadius), {
                x: ptX,
                y: ptY
            } = tooltipPoint, {
                width: width,
                height: height
            } = size;
            let x1, x2, x3, y1, y2, y3;
            return "center" === yAlign ? (y2 = ptY + height / 2, "left" === xAlign ? (x1 = ptX, x2 = x1 - caretSize, y1 = y2 + caretSize, y3 = y2 - caretSize) : (x1 = ptX + width, x2 = x1 + caretSize, y1 = y2 - caretSize, y3 = y2 + caretSize), x3 = x1) : (x2 = "left" === xAlign ? ptX + Math.max(topLeft, bottomLeft) + caretSize : "right" === xAlign ? ptX + width - Math.max(topRight, bottomRight) - caretSize : this.caretX, "top" === yAlign ? (y1 = ptY, y2 = y1 - caretSize, x1 = x2 - caretSize, x3 = x2 + caretSize) : (y1 = ptY + height, y2 = y1 + caretSize, x1 = x2 + caretSize, x3 = x2 - caretSize), y3 = y1), {
                x1: x1,
                x2: x2,
                x3: x3,
                y1: y1,
                y2: y2,
                y3: y3
            }
        }
        drawTitle(pt, ctx, options) {
            const title = this.title,
                length = title.length;
            let titleFont, titleSpacing, i;
            if (length) {
                const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                for (pt.x = getAlignedX(this, options.titleAlign, options), ctx.textAlign = rtlHelper.textAlign(options.titleAlign), ctx.textBaseline = "middle", titleFont = toFont(options.titleFont), titleSpacing = options.titleSpacing, ctx.fillStyle = options.titleColor, ctx.font = titleFont.string, i = 0; i < length; ++i) ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2), pt.y += titleFont.lineHeight + titleSpacing, i + 1 === length && (pt.y += options.titleMarginBottom - titleSpacing)
            }
        }
        _drawColorBox(ctx, pt, i, rtlHelper, options) {
            const labelColors = this.labelColors[i],
                labelPointStyle = this.labelPointStyles[i],
                {
                    boxHeight: boxHeight,
                    boxWidth: boxWidth,
                    boxPadding: boxPadding
                } = options,
                bodyFont = toFont(options.bodyFont),
                colorX = getAlignedX(this, "left", options),
                rtlColorX = rtlHelper.x(colorX),
                yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0,
                colorY = pt.y + yOffSet;
            if (options.usePointStyle) {
                const drawOptions = {
                    radius: Math.min(boxWidth, boxHeight) / 2,
                    pointStyle: labelPointStyle.pointStyle,
                    rotation: labelPointStyle.rotation,
                    borderWidth: 1
                },
                    centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2,
                    centerY = colorY + boxHeight / 2;
                ctx.strokeStyle = options.multiKeyBackground, ctx.fillStyle = options.multiKeyBackground, drawPoint(ctx, drawOptions, centerX, centerY), ctx.strokeStyle = labelColors.borderColor, ctx.fillStyle = labelColors.backgroundColor, drawPoint(ctx, drawOptions, centerX, centerY)
            } else {
                ctx.lineWidth = labelColors.borderWidth || 1, ctx.strokeStyle = labelColors.borderColor, ctx.setLineDash(labelColors.borderDash || []), ctx.lineDashOffset = labelColors.borderDashOffset || 0;
                const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding),
                    innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2),
                    borderRadius = toTRBLCorners(labelColors.borderRadius);
                Object.values(borderRadius).some(v => 0 !== v) ? (ctx.beginPath(), ctx.fillStyle = options.multiKeyBackground, addRoundedRectPath(ctx, {
                    x: outerX,
                    y: colorY,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                }), ctx.fill(), ctx.stroke(), ctx.fillStyle = labelColors.backgroundColor, ctx.beginPath(), addRoundedRectPath(ctx, {
                    x: innerX,
                    y: colorY + 1,
                    w: boxWidth - 2,
                    h: boxHeight - 2,
                    radius: borderRadius
                }), ctx.fill()) : (ctx.fillStyle = options.multiKeyBackground, ctx.fillRect(outerX, colorY, boxWidth, boxHeight), ctx.strokeRect(outerX, colorY, boxWidth, boxHeight), ctx.fillStyle = labelColors.backgroundColor, ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2))
            }
            ctx.fillStyle = this.labelTextColors[i]
        }
        drawBody(pt, ctx, options) {
            const {
                body: body
            } = this, {
                bodySpacing: bodySpacing,
                bodyAlign: bodyAlign,
                displayColors: displayColors,
                boxHeight: boxHeight,
                boxWidth: boxWidth,
                boxPadding: boxPadding
            } = options, bodyFont = toFont(options.bodyFont);
            let bodyLineHeight = bodyFont.lineHeight,
                xLinePadding = 0;
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width),
                fillLineOfText = function (line) {
                    ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2), pt.y += bodyLineHeight + bodySpacing
                },
                bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            let bodyItem, textColor, lines, i, j, ilen, jlen;
            for (ctx.textAlign = bodyAlign, ctx.textBaseline = "middle", ctx.font = bodyFont.string, pt.x = getAlignedX(this, bodyAlignForCalculation, options), ctx.fillStyle = options.bodyColor, each(this.beforeBody, fillLineOfText), xLinePadding = displayColors && "right" !== bodyAlignForCalculation ? "center" === bodyAlign ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0, i = 0, ilen = body.length; i < ilen; ++i) {
                for (bodyItem = body[i], textColor = this.labelTextColors[i], ctx.fillStyle = textColor, each(bodyItem.before, fillLineOfText), lines = bodyItem.lines, displayColors && lines.length && (this._drawColorBox(ctx, pt, i, rtlHelper, options), bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight)), j = 0, jlen = lines.length; j < jlen; ++j) fillLineOfText(lines[j]), bodyLineHeight = bodyFont.lineHeight;
                each(bodyItem.after, fillLineOfText)
            }
            xLinePadding = 0, bodyLineHeight = bodyFont.lineHeight, each(this.afterBody, fillLineOfText), pt.y -= bodySpacing
        }
        drawFooter(pt, ctx, options) {
            const footer = this.footer,
                length = footer.length;
            let footerFont, i;
            if (length) {
                const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                for (pt.x = getAlignedX(this, options.footerAlign, options), pt.y += options.footerMarginTop, ctx.textAlign = rtlHelper.textAlign(options.footerAlign), ctx.textBaseline = "middle", footerFont = toFont(options.footerFont), ctx.fillStyle = options.footerColor, ctx.font = footerFont.string, i = 0; i < length; ++i) ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2), pt.y += footerFont.lineHeight + options.footerSpacing
            }
        }
        drawBackground(pt, ctx, tooltipSize, options) {
            const {
                xAlign: xAlign,
                yAlign: yAlign
            } = this, {
                x: x,
                y: y
            } = pt, {
                width: width,
                height: height
            } = tooltipSize, {
                topLeft: topLeft,
                topRight: topRight,
                bottomLeft: bottomLeft,
                bottomRight: bottomRight
            } = toTRBLCorners(options.cornerRadius);
            ctx.fillStyle = options.backgroundColor, ctx.strokeStyle = options.borderColor, ctx.lineWidth = options.borderWidth, ctx.beginPath(), ctx.moveTo(x + topLeft, y), "top" === yAlign && this.drawCaret(pt, ctx, tooltipSize, options), ctx.lineTo(x + width - topRight, y), ctx.quadraticCurveTo(x + width, y, x + width, y + topRight), "center" === yAlign && "right" === xAlign && this.drawCaret(pt, ctx, tooltipSize, options), ctx.lineTo(x + width, y + height - bottomRight), ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height), "bottom" === yAlign && this.drawCaret(pt, ctx, tooltipSize, options), ctx.lineTo(x + bottomLeft, y + height), ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft), "center" === yAlign && "left" === xAlign && this.drawCaret(pt, ctx, tooltipSize, options), ctx.lineTo(x, y + topLeft), ctx.quadraticCurveTo(x, y, x + topLeft, y), ctx.closePath(), ctx.fill(), options.borderWidth > 0 && ctx.stroke()
        }
        _updateAnimationTarget(options) {
            const chart = this._chart,
                anims = this.$animations,
                animX = anims && anims.x,
                animY = anims && anims.y;
            if (animX || animY) {
                const position = positioners[options.position].call(this, this._active, this._eventPosition);
                if (!position) return;
                const size = this._size = getTooltipSize(this, options),
                    positionAndSize = Object.assign({}, position, this._size),
                    alignment = determineAlignment(chart, options, positionAndSize),
                    point = getBackgroundPoint(options, positionAndSize, alignment, chart);
                animX._to === point.x && animY._to === point.y || (this.xAlign = alignment.xAlign, this.yAlign = alignment.yAlign, this.width = size.width, this.height = size.height, this.caretX = position.x, this.caretY = position.y, this._resolveAnimations().update(this, point))
            }
        }
        draw(ctx) {
            const options = this.options.setContext(this.getContext());
            let opacity = this.opacity;
            if (!opacity) return;
            this._updateAnimationTarget(options);
            const tooltipSize = {
                width: this.width,
                height: this.height
            },
                pt = {
                    x: this.x,
                    y: this.y
                };
            opacity = Math.abs(opacity) < .001 ? 0 : opacity;
            const padding = toPadding(options.padding),
                hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
            options.enabled && hasTooltipContent && (ctx.save(), ctx.globalAlpha = opacity, this.drawBackground(pt, ctx, tooltipSize, options), overrideTextDirection(ctx, options.textDirection), pt.y += padding.top, this.drawTitle(pt, ctx, options), this.drawBody(pt, ctx, options), this.drawFooter(pt, ctx, options), restoreTextDirection(ctx, options.textDirection), ctx.restore())
        }
        getActiveElements() {
            return this._active || []
        }
        setActiveElements(activeElements, eventPosition) {
            const lastActive = this._active,
                active = activeElements.map(({
                    datasetIndex: datasetIndex,
                    index: index
                }) => {
                    const meta = this._chart.getDatasetMeta(datasetIndex);
                    if (!meta) throw new Error("Cannot find a dataset at index " + datasetIndex);
                    return {
                        datasetIndex: datasetIndex,
                        element: meta.data[index],
                        index: index
                    }
                }),
                changed = !_elementsEqual(lastActive, active),
                positionChanged = this._positionChanged(active, eventPosition);
            (changed || positionChanged) && (this._active = active, this._eventPosition = eventPosition, this.update(!0))
        }
        handleEvent(e, replay) {
            const options = this.options,
                lastActive = this._active || [];
            let changed = !1,
                active = [];
            "mouseout" !== e.type && (active = this._chart.getElementsAtEventForMode(e, options.mode, options, replay), options.reverse && active.reverse());
            const positionChanged = this._positionChanged(active, e);
            return changed = replay || !_elementsEqual(active, lastActive) || positionChanged, changed && (this._active = active, (options.enabled || options.external) && (this._eventPosition = {
                x: e.x,
                y: e.y
            }, this.update(!0, replay))), changed
        }
        _positionChanged(active, e) {
            const {
                caretX: caretX,
                caretY: caretY,
                options: options
            } = this, position = positioners[options.position].call(this, active, e);
            return !1 !== position && (caretX !== position.x || caretY !== position.y)
        }
    }
    chart_esm_Tooltip.positioners = positioners;
    var plugin_tooltip = {
        id: "tooltip",
        _element: chart_esm_Tooltip,
        positioners: positioners,
        afterInit(chart, _args, options) {
            options && (chart.tooltip = new chart_esm_Tooltip({
                _chart: chart,
                options: options
            }))
        },
        beforeUpdate(chart, _args, options) {
            chart.tooltip && chart.tooltip.initialize(options)
        },
        reset(chart, _args, options) {
            chart.tooltip && chart.tooltip.initialize(options)
        },
        afterDraw(chart) {
            const tooltip = chart.tooltip,
                args = {
                    tooltip: tooltip
                };
            !1 !== chart.notifyPlugins("beforeTooltipDraw", args) && (tooltip && tooltip.draw(chart.ctx), chart.notifyPlugins("afterTooltipDraw", args))
        },
        afterEvent(chart, args) {
            if (chart.tooltip) {
                const useFinalPosition = args.replay;
                chart.tooltip.handleEvent(args.event, useFinalPosition) && (args.changed = !0)
            }
        },
        defaults: {
            enabled: !0,
            external: null,
            position: "average",
            backgroundColor: "rgba(0,0,0,0.8)",
            titleColor: "#fff",
            titleFont: {
                weight: "bold"
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: "left",
            bodyColor: "#fff",
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: "left",
            footerColor: "#fff",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
                weight: "bold"
            },
            footerAlign: "left",
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (ctx, opts) => opts.bodyFont.size,
            boxWidth: (ctx, opts) => opts.bodyFont.size,
            multiKeyBackground: "#fff",
            displayColors: !0,
            boxPadding: 0,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            animation: {
                duration: 400,
                easing: "easeOutQuart"
            },
            animations: {
                numbers: {
                    type: "number",
                    properties: ["x", "y", "width", "height", "caretX", "caretY"]
                },
                opacity: {
                    easing: "linear",
                    duration: 200
                }
            },
            callbacks: {
                beforeTitle: noop,
                title(tooltipItems) {
                    if (tooltipItems.length > 0) {
                        const item = tooltipItems[0],
                            labels = item.chart.data.labels,
                            labelCount = labels ? labels.length : 0;
                        if (this && this.options && "dataset" === this.options.mode) return item.dataset.label || "";
                        if (item.label) return item.label;
                        if (labelCount > 0 && item.dataIndex < labelCount) return labels[item.dataIndex]
                    }
                    return ""
                },
                afterTitle: noop,
                beforeBody: noop,
                beforeLabel: noop,
                label(tooltipItem) {
                    if (this && this.options && "dataset" === this.options.mode) return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
                    let label = tooltipItem.dataset.label || "";
                    label && (label += ": ");
                    const value = tooltipItem.formattedValue;
                    return isNullOrUndef(value) || (label += value), label
                },
                labelColor(tooltipItem) {
                    const options = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex).controller.getStyle(tooltipItem.dataIndex);
                    return {
                        borderColor: options.borderColor,
                        backgroundColor: options.backgroundColor,
                        borderWidth: options.borderWidth,
                        borderDash: options.borderDash,
                        borderDashOffset: options.borderDashOffset,
                        borderRadius: 0
                    }
                },
                labelTextColor() {
                    return this.options.bodyColor
                },
                labelPointStyle(tooltipItem) {
                    const options = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex).controller.getStyle(tooltipItem.dataIndex);
                    return {
                        pointStyle: options.pointStyle,
                        rotation: options.rotation
                    }
                },
                afterLabel: noop,
                afterBody: noop,
                beforeFooter: noop,
                footer: noop,
                afterFooter: noop
            }
        },
        defaultRoutes: {
            bodyFont: "font",
            footerFont: "font",
            titleFont: "font"
        },
        descriptors: {
            _scriptable: name => "filter" !== name && "itemSort" !== name && "external" !== name,
            _indexable: !1,
            callbacks: {
                _scriptable: !1,
                _indexable: !1
            },
            animation: {
                _fallback: !1
            },
            animations: {
                _fallback: "animation"
            }
        },
        additionalOptionScopes: ["interaction"]
    };

    function findOrAddLabel(labels, raw, index) {
        const first = labels.indexOf(raw);
        if (-1 === first) return ((labels, raw, index) => "string" == typeof raw ? labels.push(raw) - 1 : isNaN(raw) ? null : index)(labels, raw, index);
        return first !== labels.lastIndexOf(raw) ? index : first
    }
    class chart_esm_CategoryScale extends chart_esm_Scale {
        constructor(cfg) {
            super(cfg), this._startValue = void 0, this._valueRange = 0
        }
        parse(raw, index) {
            if (isNullOrUndef(raw)) return null;
            const labels = this.getLabels();
            return ((index, max) => null === index ? null : _limitValue(Math.round(index), 0, max))(index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw)), labels.length - 1)
        }
        determineDataLimits() {
            const {
                minDefined: minDefined,
                maxDefined: maxDefined
            } = this.getUserBounds();
            let {
                min: min,
                max: max
            } = this.getMinMax(!0);
            "ticks" === this.options.bounds && (minDefined || (min = 0), maxDefined || (max = this.getLabels().length - 1)), this.min = min, this.max = max
        }
        buildTicks() {
            const min = this.min,
                max = this.max,
                offset = this.options.offset,
                ticks = [];
            let labels = this.getLabels();
            labels = 0 === min && max === labels.length - 1 ? labels : labels.slice(min, max + 1), this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1), this._startValue = this.min - (offset ? .5 : 0);
            for (let value = min; value <= max; value++) ticks.push({
                value: value
            });
            return ticks
        }
        getLabelForValue(value) {
            const labels = this.getLabels();
            return value >= 0 && value < labels.length ? labels[value] : value
        }
        configure() {
            super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)
        }
        getPixelForValue(value) {
            return "number" != typeof value && (value = this.parse(value)), null === value ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange)
        }
        getPixelForTick(index) {
            const ticks = this.ticks;
            return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index].value)
        }
        getValueForPixel(pixel) {
            return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange)
        }
        getBasePixel() {
            return this.bottom
        }
    }

    function generateTicks$1(generationOptions, dataRange) {
        const ticks = [],
            {
                bounds: bounds,
                step: step,
                min: min,
                max: max,
                precision: precision,
                count: count,
                maxTicks: maxTicks,
                maxDigits: maxDigits,
                includeBounds: includeBounds
            } = generationOptions,
            unit = step || 1,
            maxSpaces = maxTicks - 1,
            {
                min: rmin,
                max: rmax
            } = dataRange,
            minDefined = !isNullOrUndef(min),
            maxDefined = !isNullOrUndef(max),
            countDefined = !isNullOrUndef(count),
            minSpacing = (rmax - rmin) / (maxDigits + 1);
        let factor, niceMin, niceMax, numSpaces, spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
        if (spacing < 1e-14 && !minDefined && !maxDefined) return [{
            value: rmin
        }, {
            value: rmax
        }];
        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing), numSpaces > maxSpaces && (spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit), isNullOrUndef(precision) || (factor = Math.pow(10, precision), spacing = Math.ceil(spacing * factor) / factor), "ticks" === bounds ? (niceMin = Math.floor(rmin / spacing) * spacing, niceMax = Math.ceil(rmax / spacing) * spacing) : (niceMin = rmin, niceMax = rmax), minDefined && maxDefined && step && function (x, epsilon) {
            const rounded = Math.round(x);
            return rounded - epsilon <= x && rounded + epsilon >= x
        }((max - min) / step, spacing / 1e3) ? (numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks)), spacing = (max - min) / numSpaces, niceMin = min, niceMax = max) : countDefined ? (niceMin = minDefined ? min : niceMin, niceMax = maxDefined ? max : niceMax, numSpaces = count - 1, spacing = (niceMax - niceMin) / numSpaces) : (numSpaces = (niceMax - niceMin) / spacing, numSpaces = almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3) ? Math.round(numSpaces) : Math.ceil(numSpaces));
        const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
        factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision), niceMin = Math.round(niceMin * factor) / factor, niceMax = Math.round(niceMax * factor) / factor;
        let j = 0;
        for (minDefined && (includeBounds && niceMin !== min ? (ticks.push({
            value: min
        }), niceMin < min && j++, almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions)) && j++) : niceMin < min && j++); j < numSpaces; ++j) ticks.push({
            value: Math.round((niceMin + j * spacing) * factor) / factor
        });
        return maxDefined && includeBounds && niceMax !== max ? ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions)) ? ticks[ticks.length - 1].value = max : ticks.push({
            value: max
        }) : maxDefined && niceMax !== max || ticks.push({
            value: niceMax
        }), ticks
    }

    function relativeLabelSize(value, minSpacing, {
        horizontal: horizontal,
        minRotation: minRotation
    }) {
        const rad = toRadians(minRotation),
            ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || .001,
            length = .75 * minSpacing * ("" + value).length;
        return Math.min(minSpacing / ratio, length)
    }
    chart_esm_CategoryScale.id = "category", chart_esm_CategoryScale.defaults = {
        ticks: {
            callback: chart_esm_CategoryScale.prototype.getLabelForValue
        }
    };
    class chart_esm_LinearScaleBase extends chart_esm_Scale {
        constructor(cfg) {
            super(cfg), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0
        }
        parse(raw, index) {
            return isNullOrUndef(raw) || ("number" == typeof raw || raw instanceof Number) && !isFinite(+raw) ? null : +raw
        }
        handleTickRangeOptions() {
            const {
                beginAtZero: beginAtZero
            } = this.options, {
                minDefined: minDefined,
                maxDefined: maxDefined
            } = this.getUserBounds();
            let {
                min: min,
                max: max
            } = this;
            const setMin = v => min = minDefined ? min : v,
                setMax = v => max = maxDefined ? max : v;
            if (beginAtZero) {
                const minSign = sign(min),
                    maxSign = sign(max);
                minSign < 0 && maxSign < 0 ? setMax(0) : minSign > 0 && maxSign > 0 && setMin(0)
            }
            if (min === max) {
                let offset = 1;
                (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) && (offset = Math.abs(.05 * max)), setMax(max + offset), beginAtZero || setMin(min - offset)
            }
            this.min = min, this.max = max
        }
        getTickLimit() {
            const tickOpts = this.options.ticks;
            let maxTicks, {
                maxTicksLimit: maxTicksLimit,
                stepSize: stepSize
            } = tickOpts;
            return stepSize ? (maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1, maxTicks > 1e3 && (maxTicks = 1e3)) : (maxTicks = this.computeTickLimit(), maxTicksLimit = maxTicksLimit || 11), maxTicksLimit && (maxTicks = Math.min(maxTicksLimit, maxTicks)), maxTicks
        }
        computeTickLimit() {
            return Number.POSITIVE_INFINITY
        }
        buildTicks() {
            const opts = this.options,
                tickOpts = opts.ticks;
            let maxTicks = this.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            const ticks = generateTicks$1({
                maxTicks: maxTicks,
                bounds: opts.bounds,
                min: opts.min,
                max: opts.max,
                precision: tickOpts.precision,
                step: tickOpts.stepSize,
                count: tickOpts.count,
                maxDigits: this._maxDigits(),
                horizontal: this.isHorizontal(),
                minRotation: tickOpts.minRotation || 0,
                includeBounds: !1 !== tickOpts.includeBounds
            }, this._range || this);
            return "ticks" === opts.bounds && _setMinAndMaxByKey(ticks, this, "value"), opts.reverse ? (ticks.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), ticks
        }
        configure() {
            const ticks = this.ticks;
            let start = this.min,
                end = this.max;
            if (super.configure(), this.options.offset && ticks.length) {
                const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
                start -= offset, end += offset
            }
            this._startValue = start, this._endValue = end, this._valueRange = end - start
        }
        getLabelForValue(value) {
            return formatNumber(value, this.chart.options.locale)
        }
    }
    class chart_esm_LinearScale extends chart_esm_LinearScaleBase {
        determineDataLimits() {
            const {
                min: min,
                max: max
            } = this.getMinMax(!0);
            this.min = isNumberFinite(min) ? min : 0, this.max = isNumberFinite(max) ? max : 1, this.handleTickRangeOptions()
        }
        computeTickLimit() {
            const horizontal = this.isHorizontal(),
                length = horizontal ? this.width : this.height,
                minRotation = toRadians(this.options.ticks.minRotation),
                ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || .001,
                tickFont = this._resolveTickFontOptions(0);
            return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio))
        }
        getPixelForValue(value) {
            return null === value ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange)
        }
        getValueForPixel(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange
        }
    }

    function isMajor(tickVal) {
        return 1 === tickVal / Math.pow(10, Math.floor(log10(tickVal)))
    }
    chart_esm_LinearScale.id = "linear", chart_esm_LinearScale.defaults = {
        ticks: {
            callback: Ticks.formatters.numeric
        }
    };
    class chart_esm_LogarithmicScale extends chart_esm_Scale {
        constructor(cfg) {
            super(cfg), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0
        }
        parse(raw, index) {
            const value = chart_esm_LinearScaleBase.prototype.parse.apply(this, [raw, index]);
            if (0 !== value) return isNumberFinite(value) && value > 0 ? value : null;
            this._zero = !0
        }
        determineDataLimits() {
            const {
                min: min,
                max: max
            } = this.getMinMax(!0);
            this.min = isNumberFinite(min) ? Math.max(0, min) : null, this.max = isNumberFinite(max) ? Math.max(0, max) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions()
        }
        handleTickRangeOptions() {
            const {
                minDefined: minDefined,
                maxDefined: maxDefined
            } = this.getUserBounds();
            let min = this.min,
                max = this.max;
            const setMin = v => min = minDefined ? min : v,
                setMax = v => max = maxDefined ? max : v,
                exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
            min === max && (min <= 0 ? (setMin(1), setMax(10)) : (setMin(exp(min, -1)), setMax(exp(max, 1)))), min <= 0 && setMin(exp(max, -1)), max <= 0 && setMax(exp(min, 1)), this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0) && setMin(exp(min, -1)), this.min = min, this.max = max
        }
        buildTicks() {
            const opts = this.options,
                ticks = function (generationOptions, dataRange) {
                    const endExp = Math.floor(log10(dataRange.max)),
                        endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp)),
                        ticks = [];
                    let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min)))),
                        exp = Math.floor(log10(tickVal)),
                        significand = Math.floor(tickVal / Math.pow(10, exp)),
                        precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
                    do {
                        ticks.push({
                            value: tickVal,
                            major: isMajor(tickVal)
                        }), ++significand, 10 === significand && (significand = 1, ++exp, precision = exp >= 0 ? 1 : precision), tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision
                    } while (exp < endExp || exp === endExp && significand < endSignificand);
                    const lastTick = finiteOrDefault(generationOptions.max, tickVal);
                    return ticks.push({
                        value: lastTick,
                        major: isMajor(tickVal)
                    }), ticks
                }({
                    min: this._userMin,
                    max: this._userMax
                }, this);
            return "ticks" === opts.bounds && _setMinAndMaxByKey(ticks, this, "value"), opts.reverse ? (ticks.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), ticks
        }
        getLabelForValue(value) {
            return void 0 === value ? "0" : formatNumber(value, this.chart.options.locale)
        }
        configure() {
            const start = this.min;
            super.configure(), this._startValue = log10(start), this._valueRange = log10(this.max) - log10(start)
        }
        getPixelForValue(value) {
            return void 0 !== value && 0 !== value || (value = this.min), null === value || isNaN(value) ? NaN : this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange)
        }
        getValueForPixel(pixel) {
            const decimal = this.getDecimalForPixel(pixel);
            return Math.pow(10, this._startValue + decimal * this._valueRange)
        }
    }

    function getTickBackdropHeight(opts) {
        const tickOpts = opts.ticks;
        if (tickOpts.display && opts.display) {
            const padding = toPadding(tickOpts.backdropPadding);
            return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height
        }
        return 0
    }

    function determineLimits(angle, pos, size, min, max) {
        return angle === min || angle === max ? {
            start: pos - size / 2,
            end: pos + size / 2
        } : angle < min || angle > max ? {
            start: pos - size,
            end: pos
        } : {
            start: pos,
            end: pos + size
        }
    }

    function fitWithPointLabels(scale) {
        const furthestLimits = {
            l: 0,
            r: scale.width,
            t: 0,
            b: scale.height - scale.paddingTop
        },
            furthestAngles = {},
            labelSizes = [],
            padding = [],
            valueCount = scale.getLabels().length;
        for (let i = 0; i < valueCount; i++) {
            const opts = scale.options.pointLabels.setContext(scale.getPointLabelContext(i));
            padding[i] = opts.padding;
            const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]),
                plFont = toFont(opts.font),
                textSize = (ctx = scale.ctx, font = plFont, label = isArray(label = scale._pointLabels[i]) ? label : [label], {
                    w: _longestText(ctx, font.string, label),
                    h: label.length * font.lineHeight
                });
            labelSizes[i] = textSize;
            const angleRadians = scale.getIndexAngle(i),
                angle = toDegrees(angleRadians),
                hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180),
                vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            hLimits.start < furthestLimits.l && (furthestLimits.l = hLimits.start, furthestAngles.l = angleRadians), hLimits.end > furthestLimits.r && (furthestLimits.r = hLimits.end, furthestAngles.r = angleRadians), vLimits.start < furthestLimits.t && (furthestLimits.t = vLimits.start, furthestAngles.t = angleRadians), vLimits.end > furthestLimits.b && (furthestLimits.b = vLimits.end, furthestAngles.b = angleRadians)
        }
        var ctx, font, label;
        scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles), scale._pointLabelItems = function (scale, labelSizes, padding) {
            const items = [],
                valueCount = scale.getLabels().length,
                opts = scale.options,
                tickBackdropHeight = getTickBackdropHeight(opts),
                outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
            for (let i = 0; i < valueCount; i++) {
                const extra = 0 === i ? tickBackdropHeight / 2 : 0,
                    pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]),
                    angle = toDegrees(scale.getIndexAngle(i)),
                    size = labelSizes[i],
                    y = yForAngle(pointLabelPosition.y, size.h, angle),
                    textAlign = getTextAlignForAngle(angle),
                    left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
                items.push({
                    x: pointLabelPosition.x,
                    y: y,
                    textAlign: textAlign,
                    left: left,
                    top: y,
                    right: left + size.w,
                    bottom: y + size.h
                })
            }
            return items
        }(scale, labelSizes, padding)
    }

    function getTextAlignForAngle(angle) {
        return 0 === angle || 180 === angle ? "center" : angle < 180 ? "left" : "right"
    }

    function leftForTextAlign(x, w, align) {
        return "right" === align ? x -= w : "center" === align && (x -= w / 2), x
    }

    function yForAngle(y, h, angle) {
        return 90 === angle || 270 === angle ? y -= h / 2 : (angle > 270 || angle < 90) && (y -= h), y
    }

    function pathRadiusLine(scale, radius, circular, labelCount) {
        const {
            ctx: ctx
        } = scale;
        if (circular) ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
        else {
            let pointPosition = scale.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (let i = 1; i < labelCount; i++) pointPosition = scale.getPointPosition(i, radius), ctx.lineTo(pointPosition.x, pointPosition.y)
        }
    }

    function chart_esm_numberOrZero(param) {
        return isNumber(param) ? param : 0
    }
    chart_esm_LogarithmicScale.id = "logarithmic", chart_esm_LogarithmicScale.defaults = {
        ticks: {
            callback: Ticks.formatters.logarithmic,
            major: {
                enabled: !0
            }
        }
    };
    class chart_esm_RadialLinearScale extends chart_esm_LinearScaleBase {
        constructor(cfg) {
            super(cfg), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = []
        }
        setDimensions() {
            this.width = this.maxWidth, this.height = this.maxHeight, this.paddingTop = getTickBackdropHeight(this.options) / 2, this.xCenter = Math.floor(this.width / 2), this.yCenter = Math.floor((this.height - this.paddingTop) / 2), this.drawingArea = Math.min(this.height - this.paddingTop, this.width) / 2
        }
        determineDataLimits() {
            const {
                min: min,
                max: max
            } = this.getMinMax(!1);
            this.min = isNumberFinite(min) && !isNaN(min) ? min : 0, this.max = isNumberFinite(max) && !isNaN(max) ? max : 0, this.handleTickRangeOptions()
        }
        computeTickLimit() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options))
        }
        generateTickLabels(ticks) {
            chart_esm_LinearScaleBase.prototype.generateTickLabels.call(this, ticks), this._pointLabels = this.getLabels().map((value, index) => {
                const label = helpers_segment_callback(this.options.pointLabels.callback, [value, index], this);
                return label || 0 === label ? label : ""
            })
        }
        fit() {
            const opts = this.options;
            opts.display && opts.pointLabels.display ? fitWithPointLabels(this) : this.setCenterPoint(0, 0, 0, 0)
        }
        _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
            let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l),
                radiusReductionRight = Math.max(furthestLimits.r - this.width, 0) / Math.sin(furthestAngles.r),
                radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t),
                radiusReductionBottom = -Math.max(furthestLimits.b - (this.height - this.paddingTop), 0) / Math.cos(furthestAngles.b);
            radiusReductionLeft = chart_esm_numberOrZero(radiusReductionLeft), radiusReductionRight = chart_esm_numberOrZero(radiusReductionRight), radiusReductionTop = chart_esm_numberOrZero(radiusReductionTop), radiusReductionBottom = chart_esm_numberOrZero(radiusReductionBottom), this.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2))), this.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom)
        }
        setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
            const maxRight = this.width - rightMovement - this.drawingArea,
                maxLeft = leftMovement + this.drawingArea,
                maxTop = topMovement + this.drawingArea,
                maxBottom = this.height - this.paddingTop - bottomMovement - this.drawingArea;
            this.xCenter = Math.floor((maxLeft + maxRight) / 2 + this.left), this.yCenter = Math.floor((maxTop + maxBottom) / 2 + this.top + this.paddingTop)
        }
        getIndexAngle(index) {
            return _normalizeAngle(index * (TAU / this.getLabels().length) + toRadians(this.options.startAngle || 0))
        }
        getDistanceFromCenterForValue(value) {
            if (isNullOrUndef(value)) return NaN;
            const scalingFactor = this.drawingArea / (this.max - this.min);
            return this.options.reverse ? (this.max - value) * scalingFactor : (value - this.min) * scalingFactor
        }
        getValueForDistanceFromCenter(distance) {
            if (isNullOrUndef(distance)) return NaN;
            const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
            return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance
        }
        getPointLabelContext(index) {
            const pointLabels = this._pointLabels || [];
            if (index >= 0 && index < pointLabels.length) {
                const pointLabel = pointLabels[index];
                return function (parent, index, label) {
                    return createContext(parent, {
                        label: label,
                        index: index,
                        type: "pointLabel"
                    })
                }(this.getContext(), index, pointLabel)
            }
        }
        getPointPosition(index, distanceFromCenter) {
            const angle = this.getIndexAngle(index) - HALF_PI;
            return {
                x: Math.cos(angle) * distanceFromCenter + this.xCenter,
                y: Math.sin(angle) * distanceFromCenter + this.yCenter,
                angle: angle
            }
        }
        getPointPositionForValue(index, value) {
            return this.getPointPosition(index, this.getDistanceFromCenterForValue(value))
        }
        getBasePosition(index) {
            return this.getPointPositionForValue(index || 0, this.getBaseValue())
        }
        getPointLabelPosition(index) {
            const {
                left: left,
                top: top,
                right: right,
                bottom: bottom
            } = this._pointLabelItems[index];
            return {
                left: left,
                top: top,
                right: right,
                bottom: bottom
            }
        }
        drawBackground() {
            const {
                backgroundColor: backgroundColor,
                grid: {
                    circular: circular
                }
            } = this.options;
            if (backgroundColor) {
                const ctx = this.ctx;
                ctx.save(), ctx.beginPath(), pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this.getLabels().length), ctx.closePath(), ctx.fillStyle = backgroundColor, ctx.fill(), ctx.restore()
            }
        }
        drawGrid() {
            const ctx = this.ctx,
                opts = this.options,
                {
                    angleLines: angleLines,
                    grid: grid
                } = opts,
                labelCount = this.getLabels().length;
            let i, offset, position;
            if (opts.pointLabels.display && function (scale, labelCount) {
                const {
                    ctx: ctx,
                    options: {
                        pointLabels: pointLabels
                    }
                } = scale;
                for (let i = labelCount - 1; i >= 0; i--) {
                    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i)),
                        plFont = toFont(optsAtIndex.font),
                        {
                            x: x,
                            y: y,
                            textAlign: textAlign,
                            left: left,
                            top: top,
                            right: right,
                            bottom: bottom
                        } = scale._pointLabelItems[i],
                        {
                            backdropColor: backdropColor
                        } = optsAtIndex;
                    if (!isNullOrUndef(backdropColor)) {
                        const padding = toPadding(optsAtIndex.backdropPadding);
                        ctx.fillStyle = backdropColor, ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height)
                    }
                    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
                        color: optsAtIndex.color,
                        textAlign: textAlign,
                        textBaseline: "middle"
                    })
                }
            }(this, labelCount), grid.display && this.ticks.forEach((tick, index) => {
                if (0 !== index) {
                    offset = this.getDistanceFromCenterForValue(tick.value);
                    ! function (scale, gridLineOpts, radius, labelCount) {
                        const ctx = scale.ctx,
                            circular = gridLineOpts.circular,
                            {
                                color: color,
                                lineWidth: lineWidth
                            } = gridLineOpts;
                        !circular && !labelCount || !color || !lineWidth || radius < 0 || (ctx.save(), ctx.strokeStyle = color, ctx.lineWidth = lineWidth, ctx.setLineDash(gridLineOpts.borderDash), ctx.lineDashOffset = gridLineOpts.borderDashOffset, ctx.beginPath(), pathRadiusLine(scale, radius, circular, labelCount), ctx.closePath(), ctx.stroke(), ctx.restore())
                    }(this, grid.setContext(this.getContext(index - 1)), offset, labelCount)
                }
            }), angleLines.display) {
                for (ctx.save(), i = this.getLabels().length - 1; i >= 0; i--) {
                    const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i)),
                        {
                            color: color,
                            lineWidth: lineWidth
                        } = optsAtIndex;
                    lineWidth && color && (ctx.lineWidth = lineWidth, ctx.strokeStyle = color, ctx.setLineDash(optsAtIndex.borderDash), ctx.lineDashOffset = optsAtIndex.borderDashOffset, offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max), position = this.getPointPosition(i, offset), ctx.beginPath(), ctx.moveTo(this.xCenter, this.yCenter), ctx.lineTo(position.x, position.y), ctx.stroke())
                }
                ctx.restore()
            }
        }
        drawBorder() { }
        drawLabels() {
            const ctx = this.ctx,
                opts = this.options,
                tickOpts = opts.ticks;
            if (!tickOpts.display) return;
            const startAngle = this.getIndexAngle(0);
            let offset, width;
            ctx.save(), ctx.translate(this.xCenter, this.yCenter), ctx.rotate(startAngle), ctx.textAlign = "center", ctx.textBaseline = "middle", this.ticks.forEach((tick, index) => {
                if (0 === index && !opts.reverse) return;
                const optsAtIndex = tickOpts.setContext(this.getContext(index)),
                    tickFont = toFont(optsAtIndex.font);
                if (offset = this.getDistanceFromCenterForValue(this.ticks[index].value), optsAtIndex.showLabelBackdrop) {
                    ctx.font = tickFont.string, width = ctx.measureText(tick.label).width, ctx.fillStyle = optsAtIndex.backdropColor;
                    const padding = toPadding(optsAtIndex.backdropPadding);
                    ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height)
                }
                renderText(ctx, tick.label, 0, -offset, tickFont, {
                    color: optsAtIndex.color
                })
            }), ctx.restore()
        }
        drawTitle() { }
    }
    chart_esm_RadialLinearScale.id = "radialLinear", chart_esm_RadialLinearScale.defaults = {
        display: !0,
        animate: !0,
        position: "chartArea",
        angleLines: {
            display: !0,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
        },
        grid: {
            circular: !1
        },
        startAngle: 0,
        ticks: {
            showLabelBackdrop: !0,
            callback: Ticks.formatters.numeric
        },
        pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: !0,
            font: {
                size: 10
            },
            callback: label => label,
            padding: 5
        }
    }, chart_esm_RadialLinearScale.defaultRoutes = {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
    }, chart_esm_RadialLinearScale.descriptors = {
        angleLines: {
            _fallback: "grid"
        }
    };
    const INTERVALS = {
        millisecond: {
            common: !0,
            size: 1,
            steps: 1e3
        },
        second: {
            common: !0,
            size: 1e3,
            steps: 60
        },
        minute: {
            common: !0,
            size: 6e4,
            steps: 60
        },
        hour: {
            common: !0,
            size: 36e5,
            steps: 24
        },
        day: {
            common: !0,
            size: 864e5,
            steps: 30
        },
        week: {
            common: !1,
            size: 6048e5,
            steps: 4
        },
        month: {
            common: !0,
            size: 2628e6,
            steps: 12
        },
        quarter: {
            common: !1,
            size: 7884e6,
            steps: 4
        },
        year: {
            common: !0,
            size: 3154e7
        }
    },
        UNITS = Object.keys(INTERVALS);

    function sorter(a, b) {
        return a - b
    }

    function parse(scale, input) {
        if (isNullOrUndef(input)) return null;
        const adapter = scale._adapter,
            {
                parser: parser,
                round: round,
                isoWeekday: isoWeekday
            } = scale._parseOpts;
        let value = input;
        return "function" == typeof parser && (value = parser(value)), isNumberFinite(value) || (value = "string" == typeof parser ? adapter.parse(value, parser) : adapter.parse(value)), null === value ? null : (round && (value = "week" !== round || !isNumber(isoWeekday) && !0 !== isoWeekday ? adapter.startOf(value, round) : adapter.startOf(value, "isoWeek", isoWeekday)), +value)
    }

    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
        const ilen = UNITS.length;
        for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            const interval = INTERVALS[UNITS[i]],
                factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) return UNITS[i]
        }
        return UNITS[ilen - 1]
    }

    function addTick(ticks, time, timestamps) {
        if (timestamps) {
            if (timestamps.length) {
                const {
                    lo: lo,
                    hi: hi
                } = _lookup(timestamps, time);
                ticks[timestamps[lo] >= time ? timestamps[lo] : timestamps[hi]] = !0
            }
        } else ticks[time] = !0
    }

    function ticksFromTimestamps(scale, values, majorUnit) {
        const ticks = [],
            map = {},
            ilen = values.length;
        let i, value;
        for (i = 0; i < ilen; ++i) value = values[i], map[value] = i, ticks.push({
            value: value,
            major: !1
        });
        return 0 !== ilen && majorUnit ? function (scale, ticks, map, majorUnit) {
            const adapter = scale._adapter,
                first = +adapter.startOf(ticks[0].value, majorUnit),
                last = ticks[ticks.length - 1].value;
            let major, index;
            for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) index = map[major], index >= 0 && (ticks[index].major = !0);
            return ticks
        }(scale, ticks, map, majorUnit) : ticks
    }
    class chart_esm_TimeScale extends chart_esm_Scale {
        constructor(props) {
            super(props), this._cache = {
                data: [],
                labels: [],
                all: []
            }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0
        }
        init(scaleOpts, opts) {
            const time = scaleOpts.time || (scaleOpts.time = {}),
                adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
            mergeIf(time.displayFormats, adapter.formats()), this._parseOpts = {
                parser: time.parser,
                round: time.round,
                isoWeekday: time.isoWeekday
            }, super.init(scaleOpts), this._normalized = opts.normalized
        }
        parse(raw, index) {
            return void 0 === raw ? null : parse(this, raw)
        }
        beforeLayout() {
            super.beforeLayout(), this._cache = {
                data: [],
                labels: [],
                all: []
            }
        }
        determineDataLimits() {
            const options = this.options,
                adapter = this._adapter,
                unit = options.time.unit || "day";
            let {
                min: min,
                max: max,
                minDefined: minDefined,
                maxDefined: maxDefined
            } = this.getUserBounds();

            function _applyBounds(bounds) {
                minDefined || isNaN(bounds.min) || (min = Math.min(min, bounds.min)), maxDefined || isNaN(bounds.max) || (max = Math.max(max, bounds.max))
            }
            minDefined && maxDefined || (_applyBounds(this._getLabelBounds()), "ticks" === options.bounds && "labels" === options.ticks.source || _applyBounds(this.getMinMax(!1))), min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit), max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1, this.min = Math.min(min, max - 1), this.max = Math.max(min + 1, max)
        }
        _getLabelBounds() {
            const arr = this.getLabelTimestamps();
            let min = Number.POSITIVE_INFINITY,
                max = Number.NEGATIVE_INFINITY;
            return arr.length && (min = arr[0], max = arr[arr.length - 1]), {
                min: min,
                max: max
            }
        }
        buildTicks() {
            const options = this.options,
                timeOpts = options.time,
                tickOpts = options.ticks,
                timestamps = "labels" === tickOpts.source ? this.getLabelTimestamps() : this._generate();
            "ticks" === options.bounds && timestamps.length && (this.min = this._userMin || timestamps[0], this.max = this._userMax || timestamps[timestamps.length - 1]);
            const min = this.min,
                ticks = function (values, min, max) {
                    let start = 0,
                        end = values.length;
                    for (; start < end && values[start] < min;) start++;
                    for (; end > start && values[end - 1] > max;) end--;
                    return start > 0 || end < values.length ? values.slice(start, end) : values
                }(timestamps, min, this.max);
            return this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : function (scale, numTicks, minUnit, min, max) {
                for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
                    const unit = UNITS[i];
                    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) return unit
                }
                return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0]
            }(this, ticks.length, timeOpts.minUnit, this.min, this.max)), this._majorUnit = tickOpts.major.enabled && "year" !== this._unit ? function (unit) {
                for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i)
                    if (INTERVALS[UNITS[i]].common) return UNITS[i]
            }(this._unit) : void 0, this.initOffsets(timestamps), options.reverse && ticks.reverse(), ticksFromTimestamps(this, ticks, this._majorUnit)
        }
        initOffsets(timestamps) {
            let first, last, start = 0,
                end = 0;
            this.options.offset && timestamps.length && (first = this.getDecimalForValue(timestamps[0]), start = 1 === timestamps.length ? 1 - first : (this.getDecimalForValue(timestamps[1]) - first) / 2, last = this.getDecimalForValue(timestamps[timestamps.length - 1]), end = 1 === timestamps.length ? last : (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2);
            const limit = timestamps.length < 3 ? .5 : .25;
            start = _limitValue(start, 0, limit), end = _limitValue(end, 0, limit), this._offsets = {
                start: start,
                end: end,
                factor: 1 / (start + 1 + end)
            }
        }
        _generate() {
            const adapter = this._adapter,
                min = this.min,
                max = this.max,
                options = this.options,
                timeOpts = options.time,
                minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min)),
                stepSize = valueOrDefault(timeOpts.stepSize, 1),
                weekday = "week" === minor && timeOpts.isoWeekday,
                hasWeekday = isNumber(weekday) || !0 === weekday,
                ticks = {};
            let time, count, first = min;
            if (hasWeekday && (first = +adapter.startOf(first, "isoWeek", weekday)), first = +adapter.startOf(first, hasWeekday ? "day" : minor), adapter.diff(max, min, minor) > 1e5 * stepSize) throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
            const timestamps = "data" === options.ticks.source && this.getDataTimestamps();
            for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) addTick(ticks, time, timestamps);
            return time !== max && "ticks" !== options.bounds && 1 !== count || addTick(ticks, time, timestamps), Object.keys(ticks).sort((a, b) => a - b).map(x => +x)
        }
        getLabelForValue(value) {
            const adapter = this._adapter,
                timeOpts = this.options.time;
            return timeOpts.tooltipFormat ? adapter.format(value, timeOpts.tooltipFormat) : adapter.format(value, timeOpts.displayFormats.datetime)
        }
        _tickFormatFunction(time, index, ticks, format) {
            const options = this.options,
                formats = options.time.displayFormats,
                unit = this._unit,
                majorUnit = this._majorUnit,
                minorFormat = unit && formats[unit],
                majorFormat = majorUnit && formats[majorUnit],
                tick = ticks[index],
                major = majorUnit && majorFormat && tick && tick.major,
                label = this._adapter.format(time, format || (major ? majorFormat : minorFormat)),
                formatter = options.ticks.callback;
            return formatter ? helpers_segment_callback(formatter, [label, index, ticks], this) : label
        }
        generateTickLabels(ticks) {
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) tick = ticks[i], tick.label = this._tickFormatFunction(tick.value, i, ticks)
        }
        getDecimalForValue(value) {
            return null === value ? NaN : (value - this.min) / (this.max - this.min)
        }
        getPixelForValue(value) {
            const offsets = this._offsets,
                pos = this.getDecimalForValue(value);
            return this.getPixelForDecimal((offsets.start + pos) * offsets.factor)
        }
        getValueForPixel(pixel) {
            const offsets = this._offsets,
                pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return this.min + pos * (this.max - this.min)
        }
        _getLabelSize(label) {
            const ticksOpts = this.options.ticks,
                tickLabelWidth = this.ctx.measureText(label).width,
                angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation),
                cosRotation = Math.cos(angle),
                sinRotation = Math.sin(angle),
                tickFontSize = this._resolveTickFontOptions(0).size;
            return {
                w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
                h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            }
        }
        _getLabelCapacity(exampleTime) {
            const timeOpts = this.options.time,
                displayFormats = timeOpts.displayFormats,
                format = displayFormats[timeOpts.unit] || displayFormats.millisecond,
                exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format),
                size = this._getLabelSize(exampleLabel),
                capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
            return capacity > 0 ? capacity : 1
        }
        getDataTimestamps() {
            let i, ilen, timestamps = this._cache.data || [];
            if (timestamps.length) return timestamps;
            const metas = this.getMatchingVisibleMetas();
            if (this._normalized && metas.length) return this._cache.data = metas[0].controller.getAllParsedValues(this);
            for (i = 0, ilen = metas.length; i < ilen; ++i) timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
            return this._cache.data = this.normalize(timestamps)
        }
        getLabelTimestamps() {
            const timestamps = this._cache.labels || [];
            let i, ilen;
            if (timestamps.length) return timestamps;
            const labels = this.getLabels();
            for (i = 0, ilen = labels.length; i < ilen; ++i) timestamps.push(parse(this, labels[i]));
            return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps)
        }
        normalize(values) {
            return _arrayUnique(values.sort(sorter))
        }
    }

    function interpolate(table, val, reverse) {
        let prevSource, nextSource, prevTarget, nextTarget, lo = 0,
            hi = table.length - 1;
        reverse ? (val >= table[lo].pos && val <= table[hi].pos && ({
            lo: lo,
            hi: hi
        } = _lookupByKey(table, "pos", val)), ({
            pos: prevSource,
            time: prevTarget
        } = table[lo]), ({
            pos: nextSource,
            time: nextTarget
        } = table[hi])) : (val >= table[lo].time && val <= table[hi].time && ({
            lo: lo,
            hi: hi
        } = _lookupByKey(table, "time", val)), ({
            time: prevSource,
            pos: prevTarget
        } = table[lo]), ({
            time: nextSource,
            pos: nextTarget
        } = table[hi]));
        const span = nextSource - prevSource;
        return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget
    }
    chart_esm_TimeScale.id = "time", chart_esm_TimeScale.defaults = {
        bounds: "data",
        adapters: {},
        time: {
            parser: !1,
            unit: !1,
            round: !1,
            isoWeekday: !1,
            minUnit: "millisecond",
            displayFormats: {}
        },
        ticks: {
            source: "auto",
            major: {
                enabled: !1
            }
        }
    };
    class TimeSeriesScale extends chart_esm_TimeScale {
        constructor(props) {
            super(props), this._table = [], this._minPos = void 0, this._tableRange = void 0
        }
        initOffsets() {
            const timestamps = this._getTimestampsForTable(),
                table = this._table = this.buildLookupTable(timestamps);
            this._minPos = interpolate(table, this.min), this._tableRange = interpolate(table, this.max) - this._minPos, super.initOffsets(timestamps)
        }
        buildLookupTable(timestamps) {
            const {
                min: min,
                max: max
            } = this, items = [], table = [];
            let i, ilen, prev, curr, next;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) curr = timestamps[i], curr >= min && curr <= max && items.push(curr);
            if (items.length < 2) return [{
                time: min,
                pos: 0
            }, {
                time: max,
                pos: 1
            }];
            for (i = 0, ilen = items.length; i < ilen; ++i) next = items[i + 1], prev = items[i - 1], curr = items[i], Math.round((next + prev) / 2) !== curr && table.push({
                time: curr,
                pos: i / (ilen - 1)
            });
            return table
        }
        _getTimestampsForTable() {
            let timestamps = this._cache.all || [];
            if (timestamps.length) return timestamps;
            const data = this.getDataTimestamps(),
                label = this.getLabelTimestamps();
            return timestamps = data.length && label.length ? this.normalize(data.concat(label)) : data.length ? data : label, timestamps = this._cache.all = timestamps, timestamps
        }
        getDecimalForValue(value) {
            return (interpolate(this._table, value) - this._minPos) / this._tableRange
        }
        getValueForPixel(pixel) {
            const offsets = this._offsets,
                decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return interpolate(this._table, decimal * this._tableRange + this._minPos, !0)
        }
    }
    TimeSeriesScale.id = "timeseries", TimeSeriesScale.defaults = chart_esm_TimeScale.defaults;

    function ssr_window_esm_isObject(obj) {
        return null !== obj && "object" == typeof obj && "constructor" in obj && obj.constructor === Object
    }

    function extend(target = {}, src = {}) {
        Object.keys(src).forEach(key => {
            void 0 === target[key] ? target[key] = src[key] : ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0 && extend(target[key], src[key])
        })
    }
    chart_esm_Chart.register(chart_esm_ArcElement, PieController, plugin_tooltip), document.querySelectorAll(".tokenomic__chart-el").forEach((function (chart) {
        var colors = chart.dataset.colors.split(","),
            labels = chart.dataset.labels.split(","),
            percents = chart.dataset.percents.split(",");
        new chart_esm_Chart(chart, {
            type: "pie",
            data: {
                labels: labels,
                datasets: [{
                    data: percents,
                    backgroundColor: colors,
                    borderColor: colors,
                    borderWidth: 1
                }]
            },
            options: {
                plugins: {
                    legend: {
                        display: !1
                    }
                }
            }
        })
    }));
    const ssrDocument = {
        body: {},
        addEventListener() { },
        removeEventListener() { },
        activeElement: {
            blur() { },
            nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() { }
        }),
        createElement: () => ({
            children: [],
            childNodes: [],
            style: {},
            setAttribute() { },
            getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };

    function ssr_window_esm_getDocument() {
        const doc = "undefined" != typeof document ? document : {};
        return extend(doc, ssrDocument), doc
    }
    const ssrWindow = {
        document: ssrDocument,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState() { },
            pushState() { },
            go() { },
            back() { }
        },
        CustomEvent: function () {
            return this
        },
        addEventListener() { },
        removeEventListener() { },
        getComputedStyle: () => ({
            getPropertyValue: () => ""
        }),
        Image() { },
        Date() { },
        screen: {},
        setTimeout() { },
        clearTimeout() { },
        matchMedia: () => ({}),
        requestAnimationFrame: callback => "undefined" == typeof setTimeout ? (callback(), null) : setTimeout(callback, 0),
        cancelAnimationFrame(id) {
            "undefined" != typeof setTimeout && clearTimeout(id)
        }
    };

    function getWindow() {
        const win = "undefined" != typeof window ? window : {};
        return extend(win, ssrWindow), win
    }
    class Dom7 extends Array {
        constructor(items) {
            super(...items || []),
                function (obj) {
                    const proto = obj.__proto__;
                    Object.defineProperty(obj, "__proto__", {
                        get: () => proto,
                        set(value) {
                            proto.__proto__ = value
                        }
                    })
                }(this)
        }
    }

    function arrayFlat(arr = []) {
        const res = [];
        return arr.forEach(el => {
            Array.isArray(el) ? res.push(...arrayFlat(el)) : res.push(el)
        }), res
    }

    function arrayFilter(arr, callback) {
        return Array.prototype.filter.call(arr, callback)
    }

    function $(selector, context) {
        const window = getWindow(),
            document = ssr_window_esm_getDocument();
        let arr = [];
        if (!context && selector instanceof Dom7) return selector;
        if (!selector) return new Dom7(arr);
        if ("string" == typeof selector) {
            const html = selector.trim();
            if (html.indexOf("<") >= 0 && html.indexOf(">") >= 0) {
                let toCreate = "div";
                0 === html.indexOf("<li") && (toCreate = "ul"), 0 === html.indexOf("<tr") && (toCreate = "tbody"), 0 !== html.indexOf("<td") && 0 !== html.indexOf("<th") || (toCreate = "tr"), 0 === html.indexOf("<tbody") && (toCreate = "table"), 0 === html.indexOf("<option") && (toCreate = "select");
                const tempParent = document.createElement(toCreate);
                tempParent.innerHTML = html;
                for (let i = 0; i < tempParent.childNodes.length; i += 1) arr.push(tempParent.childNodes[i])
            } else arr = function (selector, context) {
                if ("string" != typeof selector) return [selector];
                const a = [],
                    res = context.querySelectorAll(selector);
                for (let i = 0; i < res.length; i += 1) a.push(res[i]);
                return a
            }(selector.trim(), context || document)
        } else if (selector.nodeType || selector === window || selector === document) arr.push(selector);
        else if (Array.isArray(selector)) {
            if (selector instanceof Dom7) return selector;
            arr = selector
        }
        return new Dom7(function (arr) {
            const uniqueArray = [];
            for (let i = 0; i < arr.length; i += 1) - 1 === uniqueArray.indexOf(arr[i]) && uniqueArray.push(arr[i]);
            return uniqueArray
        }(arr))
    }
    $.fn = Dom7.prototype;
    const noTrigger = "resize scroll".split(" ");

    function shortcut(name) {
        return function (...args) {
            if (void 0 === args[0]) {
                for (let i = 0; i < this.length; i += 1) noTrigger.indexOf(name) < 0 && (name in this[i] ? this[i][name]() : $(this[i]).trigger(name));
                return this
            }
            return this.on(name, ...args)
        }
    }
    shortcut("click"), shortcut("blur"), shortcut("focus"), shortcut("focusin"), shortcut("focusout"), shortcut("keyup"), shortcut("keydown"), shortcut("keypress"), shortcut("submit"), shortcut("change"), shortcut("mousedown"), shortcut("mousemove"), shortcut("mouseup"), shortcut("mouseenter"), shortcut("mouseleave"), shortcut("mouseout"), shortcut("mouseover"), shortcut("touchstart"), shortcut("touchend"), shortcut("touchmove"), shortcut("resize"), shortcut("scroll");
    const Methods = {
        addClass: function (...classes) {
            const classNames = arrayFlat(classes.map(c => c.split(" ")));
            return this.forEach(el => {
                el.classList.add(...classNames)
            }), this
        },
        removeClass: function (...classes) {
            const classNames = arrayFlat(classes.map(c => c.split(" ")));
            return this.forEach(el => {
                el.classList.remove(...classNames)
            }), this
        },
        hasClass: function (...classes) {
            const classNames = arrayFlat(classes.map(c => c.split(" ")));
            return arrayFilter(this, el => classNames.filter(className => el.classList.contains(className)).length > 0).length > 0
        },
        toggleClass: function (...classes) {
            const classNames = arrayFlat(classes.map(c => c.split(" ")));
            this.forEach(el => {
                classNames.forEach(className => {
                    el.classList.toggle(className)
                })
            })
        },
        attr: function (attrs, value) {
            if (1 === arguments.length && "string" == typeof attrs) return this[0] ? this[0].getAttribute(attrs) : void 0;
            for (let i = 0; i < this.length; i += 1)
                if (2 === arguments.length) this[i].setAttribute(attrs, value);
                else
                    for (const attrName in attrs) this[i][attrName] = attrs[attrName], this[i].setAttribute(attrName, attrs[attrName]);
            return this
        },
        removeAttr: function (attr) {
            for (let i = 0; i < this.length; i += 1) this[i].removeAttribute(attr);
            return this
        },
        transform: function (transform) {
            for (let i = 0; i < this.length; i += 1) this[i].style.transform = transform;
            return this
        },
        transition: function (duration) {
            for (let i = 0; i < this.length; i += 1) this[i].style.transitionDuration = "string" != typeof duration ? duration + "ms" : duration;
            return this
        },
        on: function (...args) {
            let [eventType, targetSelector, listener, capture] = args;

            function handleLiveEvent(e) {
                const target = e.target;
                if (!target) return;
                const eventData = e.target.dom7EventData || [];
                if (eventData.indexOf(e) < 0 && eventData.unshift(e), $(target).is(targetSelector)) listener.apply(target, eventData);
                else {
                    const parents = $(target).parents();
                    for (let k = 0; k < parents.length; k += 1) $(parents[k]).is(targetSelector) && listener.apply(parents[k], eventData)
                }
            }

            function handleEvent(e) {
                const eventData = e && e.target && e.target.dom7EventData || [];
                eventData.indexOf(e) < 0 && eventData.unshift(e), listener.apply(this, eventData)
            }
            "function" == typeof args[1] && ([eventType, listener, capture] = args, targetSelector = void 0), capture || (capture = !1);
            const events = eventType.split(" ");
            let j;
            for (let i = 0; i < this.length; i += 1) {
                const el = this[i];
                if (targetSelector)
                    for (j = 0; j < events.length; j += 1) {
                        const event = events[j];
                        el.dom7LiveListeners || (el.dom7LiveListeners = {}), el.dom7LiveListeners[event] || (el.dom7LiveListeners[event] = []), el.dom7LiveListeners[event].push({
                            listener: listener,
                            proxyListener: handleLiveEvent
                        }), el.addEventListener(event, handleLiveEvent, capture)
                    } else
                    for (j = 0; j < events.length; j += 1) {
                        const event = events[j];
                        el.dom7Listeners || (el.dom7Listeners = {}), el.dom7Listeners[event] || (el.dom7Listeners[event] = []), el.dom7Listeners[event].push({
                            listener: listener,
                            proxyListener: handleEvent
                        }), el.addEventListener(event, handleEvent, capture)
                    }
            }
            return this
        },
        off: function (...args) {
            let [eventType, targetSelector, listener, capture] = args;
            "function" == typeof args[1] && ([eventType, listener, capture] = args, targetSelector = void 0), capture || (capture = !1);
            const events = eventType.split(" ");
            for (let i = 0; i < events.length; i += 1) {
                const event = events[i];
                for (let j = 0; j < this.length; j += 1) {
                    const el = this[j];
                    let handlers;
                    if (!targetSelector && el.dom7Listeners ? handlers = el.dom7Listeners[event] : targetSelector && el.dom7LiveListeners && (handlers = el.dom7LiveListeners[event]), handlers && handlers.length)
                        for (let k = handlers.length - 1; k >= 0; k -= 1) {
                            const handler = handlers[k];
                            listener && handler.listener === listener || listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener ? (el.removeEventListener(event, handler.proxyListener, capture), handlers.splice(k, 1)) : listener || (el.removeEventListener(event, handler.proxyListener, capture), handlers.splice(k, 1))
                        }
                }
            }
            return this
        },
        trigger: function (...args) {
            const window = getWindow(),
                events = args[0].split(" "),
                eventData = args[1];
            for (let i = 0; i < events.length; i += 1) {
                const event = events[i];
                for (let j = 0; j < this.length; j += 1) {
                    const el = this[j];
                    if (window.CustomEvent) {
                        const evt = new window.CustomEvent(event, {
                            detail: eventData,
                            bubbles: !0,
                            cancelable: !0
                        });
                        el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0), el.dispatchEvent(evt), el.dom7EventData = [], delete el.dom7EventData
                    }
                }
            }
            return this
        },
        transitionEnd: function (callback) {
            const dom = this;
            return callback && dom.on("transitionend", (function fireCallBack(e) {
                e.target === this && (callback.call(this, e), dom.off("transitionend", fireCallBack))
            })), this
        },
        outerWidth: function (includeMargins) {
            if (this.length > 0) {
                if (includeMargins) {
                    const styles = this.styles();
                    return this[0].offsetWidth + parseFloat(styles.getPropertyValue("margin-right")) + parseFloat(styles.getPropertyValue("margin-left"))
                }
                return this[0].offsetWidth
            }
            return null
        },
        outerHeight: function (includeMargins) {
            if (this.length > 0) {
                if (includeMargins) {
                    const styles = this.styles();
                    return this[0].offsetHeight + parseFloat(styles.getPropertyValue("margin-top")) + parseFloat(styles.getPropertyValue("margin-bottom"))
                }
                return this[0].offsetHeight
            }
            return null
        },
        styles: function () {
            const window = getWindow();
            return this[0] ? window.getComputedStyle(this[0], null) : {}
        },
        offset: function () {
            if (this.length > 0) {
                const window = getWindow(),
                    document = ssr_window_esm_getDocument(),
                    el = this[0],
                    box = el.getBoundingClientRect(),
                    body = document.body,
                    clientTop = el.clientTop || body.clientTop || 0,
                    clientLeft = el.clientLeft || body.clientLeft || 0,
                    scrollTop = el === window ? window.scrollY : el.scrollTop,
                    scrollLeft = el === window ? window.scrollX : el.scrollLeft;
                return {
                    top: box.top + scrollTop - clientTop,
                    left: box.left + scrollLeft - clientLeft
                }
            }
            return null
        },
        css: function (props, value) {
            const window = getWindow();
            let i;
            if (1 === arguments.length) {
                if ("string" != typeof props) {
                    for (i = 0; i < this.length; i += 1)
                        for (const prop in props) this[i].style[prop] = props[prop];
                    return this
                }
                if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props)
            }
            if (2 === arguments.length && "string" == typeof props) {
                for (i = 0; i < this.length; i += 1) this[i].style[props] = value;
                return this
            }
            return this
        },
        each: function (callback) {
            return callback ? (this.forEach((el, index) => {
                callback.apply(el, [el, index])
            }), this) : this
        },
        html: function (html) {
            if (void 0 === html) return this[0] ? this[0].innerHTML : null;
            for (let i = 0; i < this.length; i += 1) this[i].innerHTML = html;
            return this
        },
        text: function (text) {
            if (void 0 === text) return this[0] ? this[0].textContent.trim() : null;
            for (let i = 0; i < this.length; i += 1) this[i].textContent = text;
            return this
        },
        is: function (selector) {
            const window = getWindow(),
                document = ssr_window_esm_getDocument(),
                el = this[0];
            let compareWith, i;
            if (!el || void 0 === selector) return !1;
            if ("string" == typeof selector) {
                if (el.matches) return el.matches(selector);
                if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
                if (el.msMatchesSelector) return el.msMatchesSelector(selector);
                for (compareWith = $(selector), i = 0; i < compareWith.length; i += 1)
                    if (compareWith[i] === el) return !0;
                return !1
            }
            if (selector === document) return el === document;
            if (selector === window) return el === window;
            if (selector.nodeType || selector instanceof Dom7) {
                for (compareWith = selector.nodeType ? [selector] : selector, i = 0; i < compareWith.length; i += 1)
                    if (compareWith[i] === el) return !0;
                return !1
            }
            return !1
        },
        index: function () {
            let i, child = this[0];
            if (child) {
                for (i = 0; null !== (child = child.previousSibling);) 1 === child.nodeType && (i += 1);
                return i
            }
        },
        eq: function (index) {
            if (void 0 === index) return this;
            const length = this.length;
            if (index > length - 1) return $([]);
            if (index < 0) {
                const returnIndex = length + index;
                return $(returnIndex < 0 ? [] : [this[returnIndex]])
            }
            return $([this[index]])
        },
        append: function (...els) {
            let newChild;
            const document = ssr_window_esm_getDocument();
            for (let k = 0; k < els.length; k += 1) {
                newChild = els[k];
                for (let i = 0; i < this.length; i += 1)
                    if ("string" == typeof newChild) {
                        const tempDiv = document.createElement("div");
                        for (tempDiv.innerHTML = newChild; tempDiv.firstChild;) this[i].appendChild(tempDiv.firstChild)
                    } else if (newChild instanceof Dom7)
                        for (let j = 0; j < newChild.length; j += 1) this[i].appendChild(newChild[j]);
                    else this[i].appendChild(newChild)
            }
            return this
        },
        prepend: function (newChild) {
            const document = ssr_window_esm_getDocument();
            let i, j;
            for (i = 0; i < this.length; i += 1)
                if ("string" == typeof newChild) {
                    const tempDiv = document.createElement("div");
                    for (tempDiv.innerHTML = newChild, j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0])
                } else if (newChild instanceof Dom7)
                    for (j = 0; j < newChild.length; j += 1) this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                else this[i].insertBefore(newChild, this[i].childNodes[0]);
            return this
        },
        next: function (selector) {
            return this.length > 0 ? selector ? this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector) ? $([this[0].nextElementSibling]) : $([]) : this[0].nextElementSibling ? $([this[0].nextElementSibling]) : $([]) : $([])
        },
        nextAll: function (selector) {
            const nextEls = [];
            let el = this[0];
            if (!el) return $([]);
            for (; el.nextElementSibling;) {
                const next = el.nextElementSibling;
                selector ? $(next).is(selector) && nextEls.push(next) : nextEls.push(next), el = next
            }
            return $(nextEls)
        },
        prev: function (selector) {
            if (this.length > 0) {
                const el = this[0];
                return selector ? el.previousElementSibling && $(el.previousElementSibling).is(selector) ? $([el.previousElementSibling]) : $([]) : el.previousElementSibling ? $([el.previousElementSibling]) : $([])
            }
            return $([])
        },
        prevAll: function (selector) {
            const prevEls = [];
            let el = this[0];
            if (!el) return $([]);
            for (; el.previousElementSibling;) {
                const prev = el.previousElementSibling;
                selector ? $(prev).is(selector) && prevEls.push(prev) : prevEls.push(prev), el = prev
            }
            return $(prevEls)
        },
        parent: function (selector) {
            const parents = [];
            for (let i = 0; i < this.length; i += 1) null !== this[i].parentNode && (selector ? $(this[i].parentNode).is(selector) && parents.push(this[i].parentNode) : parents.push(this[i].parentNode));
            return $(parents)
        },
        parents: function (selector) {
            const parents = [];
            for (let i = 0; i < this.length; i += 1) {
                let parent = this[i].parentNode;
                for (; parent;) selector ? $(parent).is(selector) && parents.push(parent) : parents.push(parent), parent = parent.parentNode
            }
            return $(parents)
        },
        closest: function (selector) {
            let closest = this;
            return void 0 === selector ? $([]) : (closest.is(selector) || (closest = closest.parents(selector).eq(0)), closest)
        },
        find: function (selector) {
            const foundElements = [];
            for (let i = 0; i < this.length; i += 1) {
                const found = this[i].querySelectorAll(selector);
                for (let j = 0; j < found.length; j += 1) foundElements.push(found[j])
            }
            return $(foundElements)
        },
        children: function (selector) {
            const children = [];
            for (let i = 0; i < this.length; i += 1) {
                const childNodes = this[i].children;
                for (let j = 0; j < childNodes.length; j += 1) selector && !$(childNodes[j]).is(selector) || children.push(childNodes[j])
            }
            return $(children)
        },
        filter: function (callback) {
            return $(arrayFilter(this, callback))
        },
        remove: function () {
            for (let i = 0; i < this.length; i += 1) this[i].parentNode && this[i].parentNode.removeChild(this[i]);
            return this
        }
    };
    Object.keys(Methods).forEach(methodName => {
        Object.defineProperty($.fn, methodName, {
            value: Methods[methodName],
            writable: !0
        })
    });
    var dom = $;

    function nextTick(callback, delay = 0) {
        return setTimeout(callback, delay)
    }

    function now() {
        return Date.now()
    }

    function getTranslate(el, axis = "x") {
        const window = getWindow();
        let matrix, curTransform, transformMatrix;
        const curStyle = function (el) {
            const window = getWindow();
            let style;
            return window.getComputedStyle && (style = window.getComputedStyle(el, null)), !style && el.currentStyle && (style = el.currentStyle), style || (style = el.style), style
        }(el);
        return window.WebKitCSSMatrix ? (curTransform = curStyle.transform || curStyle.webkitTransform, curTransform.split(",").length > 6 && (curTransform = curTransform.split(", ").map(a => a.replace(",", ".")).join(", ")), transformMatrix = new window.WebKitCSSMatrix("none" === curTransform ? "" : curTransform)) : (transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), matrix = transformMatrix.toString().split(",")), "x" === axis && (curTransform = window.WebKitCSSMatrix ? transformMatrix.m41 : 16 === matrix.length ? parseFloat(matrix[12]) : parseFloat(matrix[4])), "y" === axis && (curTransform = window.WebKitCSSMatrix ? transformMatrix.m42 : 16 === matrix.length ? parseFloat(matrix[13]) : parseFloat(matrix[5])), curTransform || 0
    }

    function utils_isObject(o) {
        return "object" == typeof o && null !== o && o.constructor && "Object" === Object.prototype.toString.call(o).slice(8, -1)
    }

    function utils_extend(...args) {
        const to = Object(args[0]),
            noExtend = ["__proto__", "constructor", "prototype"];
        for (let i = 1; i < args.length; i += 1) {
            const nextSource = args[i];
            if (null != nextSource && (node = nextSource, !("undefined" != typeof window && void 0 !== window.HTMLElement ? node instanceof HTMLElement : node && (1 === node.nodeType || 11 === node.nodeType)))) {
                const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
                for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                    const nextKey = keysArray[nextIndex],
                        desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                    void 0 !== desc && desc.enumerable && (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey]) ? nextSource[nextKey].__swiper__ ? to[nextKey] = nextSource[nextKey] : utils_extend(to[nextKey], nextSource[nextKey]) : !utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey]) ? (to[nextKey] = {}, nextSource[nextKey].__swiper__ ? to[nextKey] = nextSource[nextKey] : utils_extend(to[nextKey], nextSource[nextKey])) : to[nextKey] = nextSource[nextKey])
                }
            }
        }
        var node;
        return to
    }

    function setCSSProperty(el, varName, varValue) {
        el.style.setProperty(varName, varValue)
    }

    function animateCSSModeScroll({
        swiper: swiper,
        targetPosition: targetPosition,
        side: side
    }) {
        const window = getWindow(),
            startPosition = -swiper.translate;
        let time, startTime = null;
        const duration = swiper.params.speed;
        swiper.wrapperEl.style.scrollSnapType = "none", window.cancelAnimationFrame(swiper.cssModeFrameID);
        const dir = targetPosition > startPosition ? "next" : "prev",
            isOutOfBound = (current, target) => "next" === dir && current >= target || "prev" === dir && current <= target,
            animate = () => {
                time = (new Date).getTime(), null === startTime && (startTime = time);
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0),
                    easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition) && (currentPosition = targetPosition), swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                }), isOutOfBound(currentPosition, targetPosition)) return swiper.wrapperEl.style.overflow = "hidden", swiper.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                    swiper.wrapperEl.style.overflow = "", swiper.wrapperEl.scrollTo({
                        [side]: currentPosition
                    })
                }), void window.cancelAnimationFrame(swiper.cssModeFrameID);
                swiper.cssModeFrameID = window.requestAnimationFrame(animate)
            };
        animate()
    }
    let get_support_support, deviceCached, get_browser_browser;

    function getSupport() {
        return get_support_support || (get_support_support = function () {
            const window = getWindow(),
                document = ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch),
                passiveListener: function () {
                    let supportsPassive = !1;
                    try {
                        const opts = Object.defineProperty({}, "passive", {
                            get() {
                                supportsPassive = !0
                            }
                        });
                        window.addEventListener("testPassiveListener", null, opts)
                    } catch (e) { }
                    return supportsPassive
                }(),
                gestures: "ongesturestart" in window
            }
        }()), get_support_support
    }

    function getDevice(overrides = {}) {
        return deviceCached || (deviceCached = function ({
            userAgent: userAgent
        } = {}) {
            const support = getSupport(),
                window = getWindow(),
                platform = window.navigator.platform,
                ua = userAgent || window.navigator.userAgent,
                device = {
                    ios: !1,
                    android: !1
                },
                screenWidth = window.screen.width,
                screenHeight = window.screen.height,
                android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/),
                iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                windows = "Win32" === platform;
            let macos = "MacIntel" === platform;
            return !ipad && macos && support.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${screenWidth}x${screenHeight}`) >= 0 && (ipad = ua.match(/(Version)\/([\d.]+)/), ipad || (ipad = [0, 1, "13_0_0"]), macos = !1), android && !windows && (device.os = "android", device.android = !0), (ipad || iphone || ipod) && (device.os = "ios", device.ios = !0), device
        }(overrides)), deviceCached
    }

    function getBrowser() {
        return get_browser_browser || (get_browser_browser = function () {
            const window = getWindow();
            return {
                isSafari: function () {
                    const ua = window.navigator.userAgent.toLowerCase();
                    return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0
                }(),
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
            }
        }()), get_browser_browser
    }

    function transitionEmit({
        swiper: swiper,
        runCallbacks: runCallbacks,
        direction: direction,
        step: step
    }) {
        const {
            activeIndex: activeIndex,
            previousIndex: previousIndex
        } = swiper;
        let dir = direction;
        if (dir || (dir = activeIndex > previousIndex ? "next" : activeIndex < previousIndex ? "prev" : "reset"), swiper.emit("transition" + step), runCallbacks && activeIndex !== previousIndex) {
            if ("reset" === dir) return void swiper.emit("slideResetTransition" + step);
            swiper.emit("slideChangeTransition" + step), "next" === dir ? swiper.emit("slideNextTransition" + step) : swiper.emit("slidePrevTransition" + step)
        }
    }

    function onTouchStart_onTouchStart(event) {
        const swiper = this,
            document = ssr_window_esm_getDocument(),
            window = getWindow(),
            data = swiper.touchEventsData,
            {
                params: params,
                touches: touches,
                enabled: enabled
            } = swiper;
        if (!enabled) return;
        if (swiper.animating && params.preventInteractionOnTransition) return;
        !swiper.animating && params.cssMode && params.loop && swiper.loopFix();
        let e = event;
        e.originalEvent && (e = e.originalEvent);
        let $targetEl = dom(e.target);
        if ("wrapper" === params.touchEventsTarget && !$targetEl.closest(swiper.wrapperEl).length) return;
        if (data.isTouchEvent = "touchstart" === e.type, !data.isTouchEvent && "which" in e && 3 === e.which) return;
        if (!data.isTouchEvent && "button" in e && e.button > 0) return;
        if (data.isTouched && data.isMoved) return;
        !!params.noSwipingClass && "" !== params.noSwipingClass && e.target && e.target.shadowRoot && event.path && event.path[0] && ($targetEl = dom(event.path[0]));
        const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass,
            isTargetShadow = !(!e.target || !e.target.shadowRoot);
        if (params.noSwiping && (isTargetShadow ? function (selector, base = this) {
            return function __closestFrom(el) {
                return el && el !== ssr_window_esm_getDocument() && el !== getWindow() ? (el.assignedSlot && (el = el.assignedSlot), el.closest(selector) || __closestFrom(el.getRootNode().host)) : null
            }(base)
        }(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) return void (swiper.allowClick = !0);
        if (params.swipeHandler && !$targetEl.closest(params.swipeHandler)[0]) return;
        touches.currentX = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, touches.currentY = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY;
        const startX = touches.currentX,
            startY = touches.currentY,
            edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection,
            edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
        if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
            if ("prevent" !== edgeSwipeDetection) return;
            event.preventDefault()
        }
        if (Object.assign(data, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), touches.startX = startX, touches.startY = startY, data.touchStartTime = now(), swiper.allowClick = !0, swiper.updateSize(), swiper.swipeDirection = void 0, params.threshold > 0 && (data.allowThresholdMove = !1), "touchstart" !== e.type) {
            let preventDefault = !0;
            $targetEl.is(data.focusableElements) && (preventDefault = !1), document.activeElement && dom(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0] && document.activeElement.blur();
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            !params.touchStartForcePreventDefault && !shouldPreventDefault || $targetEl[0].isContentEditable || e.preventDefault()
        }
        swiper.emit("touchStart", e)
    }

    function onTouchMove_onTouchMove(event) {
        const document = ssr_window_esm_getDocument(),
            swiper = this,
            data = swiper.touchEventsData,
            {
                params: params,
                touches: touches,
                rtlTranslate: rtl,
                enabled: enabled
            } = swiper;
        if (!enabled) return;
        let e = event;
        if (e.originalEvent && (e = e.originalEvent), !data.isTouched) return void (data.startMoving && data.isScrolling && swiper.emit("touchMoveOpposite", e));
        if (data.isTouchEvent && "touchmove" !== e.type) return;
        const targetTouch = "touchmove" === e.type && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]),
            pageX = "touchmove" === e.type ? targetTouch.pageX : e.pageX,
            pageY = "touchmove" === e.type ? targetTouch.pageY : e.pageY;
        if (e.preventedByNestedSwiper) return touches.startX = pageX, void (touches.startY = pageY);
        if (!swiper.allowTouchMove) return swiper.allowClick = !1, void (data.isTouched && (Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
        }), data.touchStartTime = now()));
        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop)
            if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) return data.isTouched = !1, void (data.isMoved = !1)
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
        if (data.isTouchEvent && document.activeElement && e.target === document.activeElement && dom(e.target).is(data.focusableElements)) return data.isMoved = !0, void (swiper.allowClick = !1);
        if (data.allowTouchCallbacks && swiper.emit("touchMove", e), e.targetTouches && e.targetTouches.length > 1) return;
        touches.currentX = pageX, touches.currentY = pageY;
        const diffX = touches.currentX - touches.startX,
            diffY = touches.currentY - touches.startY;
        if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
        if (void 0 === data.isScrolling) {
            let touchAngle;
            swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX ? data.isScrolling = !1 : diffX * diffX + diffY * diffY >= 25 && (touchAngle = 180 * Math.atan2(Math.abs(diffY), Math.abs(diffX)) / Math.PI, data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle)
        }
        if (data.isScrolling && swiper.emit("touchMoveOpposite", e), void 0 === data.startMoving && (touches.currentX === touches.startX && touches.currentY === touches.startY || (data.startMoving = !0)), data.isScrolling) return void (data.isTouched = !1);
        if (!data.startMoving) return;
        swiper.allowClick = !1, !params.cssMode && e.cancelable && e.preventDefault(), params.touchMoveStopPropagation && !params.nested && e.stopPropagation(), data.isMoved || (params.loop && !params.cssMode && swiper.loopFix(), data.startTranslate = swiper.getTranslate(), swiper.setTransition(0), swiper.animating && swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend"), data.allowMomentumBounce = !1, !params.grabCursor || !0 !== swiper.allowSlideNext && !0 !== swiper.allowSlidePrev || swiper.setGrabCursor(!0), swiper.emit("sliderFirstMove", e)), swiper.emit("sliderMove", e), data.isMoved = !0;
        let diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff, diff *= params.touchRatio, rtl && (diff = -diff), swiper.swipeDirection = diff > 0 ? "prev" : "next", data.currentTranslate = diff + data.startTranslate;
        let disableParentSwiper = !0,
            resistanceRatio = params.resistanceRatio;
        if (params.touchReleaseOnEdges && (resistanceRatio = 0), diff > 0 && data.currentTranslate > swiper.minTranslate() ? (disableParentSwiper = !1, params.resistance && (data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio)) : diff < 0 && data.currentTranslate < swiper.maxTranslate() && (disableParentSwiper = !1, params.resistance && (data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio)), disableParentSwiper && (e.preventedByNestedSwiper = !0), !swiper.allowSlideNext && "next" === swiper.swipeDirection && data.currentTranslate < data.startTranslate && (data.currentTranslate = data.startTranslate), !swiper.allowSlidePrev && "prev" === swiper.swipeDirection && data.currentTranslate > data.startTranslate && (data.currentTranslate = data.startTranslate), swiper.allowSlidePrev || swiper.allowSlideNext || (data.currentTranslate = data.startTranslate), params.threshold > 0) {
            if (!(Math.abs(diff) > params.threshold || data.allowThresholdMove)) return void (data.currentTranslate = data.startTranslate);
            if (!data.allowThresholdMove) return data.allowThresholdMove = !0, touches.startX = touches.currentX, touches.startY = touches.currentY, data.currentTranslate = data.startTranslate, void (touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY)
        }
        params.followFinger && !params.cssMode && ((params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) && (swiper.updateActiveIndex(), swiper.updateSlidesClasses()), swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.freeMode.onTouchMove(), swiper.updateProgress(data.currentTranslate), swiper.setTranslate(data.currentTranslate))
    }

    function onTouchEnd_onTouchEnd(event) {
        const swiper = this,
            data = swiper.touchEventsData,
            {
                params: params,
                touches: touches,
                rtlTranslate: rtl,
                slidesGrid: slidesGrid,
                enabled: enabled
            } = swiper;
        if (!enabled) return;
        let e = event;
        if (e.originalEvent && (e = e.originalEvent), data.allowTouchCallbacks && swiper.emit("touchEnd", e), data.allowTouchCallbacks = !1, !data.isTouched) return data.isMoved && params.grabCursor && swiper.setGrabCursor(!1), data.isMoved = !1, void (data.startMoving = !1);
        params.grabCursor && data.isMoved && data.isTouched && (!0 === swiper.allowSlideNext || !0 === swiper.allowSlidePrev) && swiper.setGrabCursor(!1);
        const touchEndTime = now(),
            timeDiff = touchEndTime - data.touchStartTime;
        if (swiper.allowClick && (swiper.updateClickedSlide(e), swiper.emit("tap click", e), timeDiff < 300 && touchEndTime - data.lastClickTime < 300 && swiper.emit("doubleTap doubleClick", e)), data.lastClickTime = now(), nextTick(() => {
            swiper.destroyed || (swiper.allowClick = !0)
        }), !data.isTouched || !data.isMoved || !swiper.swipeDirection || 0 === touches.diff || data.currentTranslate === data.startTranslate) return data.isTouched = !1, data.isMoved = !1, void (data.startMoving = !1);
        let currentPos;
        if (data.isTouched = !1, data.isMoved = !1, data.startMoving = !1, currentPos = params.followFinger ? rtl ? swiper.translate : -swiper.translate : -data.currentTranslate, params.cssMode) return;
        if (swiper.params.freeMode && params.freeMode.enabled) return void swiper.freeMode.onTouchEnd({
            currentPos: currentPos
        });
        let stopIndex = 0,
            groupSize = swiper.slidesSizesGrid[0];
        for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
            const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            void 0 !== slidesGrid[i + increment] ? currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment] && (stopIndex = i, groupSize = slidesGrid[i + increment] - slidesGrid[i]) : currentPos >= slidesGrid[i] && (stopIndex = i, groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2])
        }
        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize,
            increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (timeDiff > params.longSwipesMs) {
            if (!params.longSwipes) return void swiper.slideTo(swiper.activeIndex);
            "next" === swiper.swipeDirection && (ratio >= params.longSwipesRatio ? swiper.slideTo(stopIndex + increment) : swiper.slideTo(stopIndex)), "prev" === swiper.swipeDirection && (ratio > 1 - params.longSwipesRatio ? swiper.slideTo(stopIndex + increment) : swiper.slideTo(stopIndex))
        } else {
            if (!params.shortSwipes) return void swiper.slideTo(swiper.activeIndex);
            swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl) ? e.target === swiper.navigation.nextEl ? swiper.slideTo(stopIndex + increment) : swiper.slideTo(stopIndex) : ("next" === swiper.swipeDirection && swiper.slideTo(stopIndex + increment), "prev" === swiper.swipeDirection && swiper.slideTo(stopIndex))
        }
    }

    function onResize() {
        const swiper = this,
            {
                params: params,
                el: el
            } = swiper;
        if (el && 0 === el.offsetWidth) return;
        params.breakpoints && swiper.setBreakpoint();
        const {
            allowSlideNext: allowSlideNext,
            allowSlidePrev: allowSlidePrev,
            snapGrid: snapGrid
        } = swiper;
        swiper.allowSlideNext = !0, swiper.allowSlidePrev = !0, swiper.updateSize(), swiper.updateSlides(), swiper.updateSlidesClasses(), ("auto" === params.slidesPerView || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides ? swiper.slideTo(swiper.slides.length - 1, 0, !1, !0) : swiper.slideTo(swiper.activeIndex, 0, !1, !0), swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused && swiper.autoplay.run(), swiper.allowSlidePrev = allowSlidePrev, swiper.allowSlideNext = allowSlideNext, swiper.params.watchOverflow && snapGrid !== swiper.snapGrid && swiper.checkOverflow()
    }

    function onClick_onClick(e) {
        const swiper = this;
        swiper.enabled && (swiper.allowClick || (swiper.params.preventClicks && e.preventDefault(), swiper.params.preventClicksPropagation && swiper.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
    }

    function onScroll() {
        const swiper = this,
            {
                wrapperEl: wrapperEl,
                rtlTranslate: rtlTranslate,
                enabled: enabled
            } = swiper;
        if (!enabled) return;
        let newProgress;
        swiper.previousTranslate = swiper.translate, swiper.isHorizontal() ? swiper.translate = -wrapperEl.scrollLeft : swiper.translate = -wrapperEl.scrollTop, -0 === swiper.translate && (swiper.translate = 0), swiper.updateActiveIndex(), swiper.updateSlidesClasses();
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        newProgress = 0 === translatesDiff ? 0 : (swiper.translate - swiper.minTranslate()) / translatesDiff, newProgress !== swiper.progress && swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate), swiper.emit("setTranslate", swiper.translate, !1)
    }
    let dummyEventAttached = !1;

    function dummyEventListener() { }
    const events_events = (swiper, method) => {
        const document = ssr_window_esm_getDocument(),
            {
                params: params,
                touchEvents: touchEvents,
                el: el,
                wrapperEl: wrapperEl,
                device: device,
                support: support
            } = swiper,
            capture = !!params.nested,
            domMethod = "on" === method ? "addEventListener" : "removeEventListener",
            swiperMethod = method;
        if (support.touch) {
            const passiveListener = !("touchstart" !== touchEvents.start || !support.passiveListener || !params.passiveListeners) && {
                passive: !0,
                capture: !1
            };
            el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener), el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
                passive: !1,
                capture: capture
            } : capture), el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener), touchEvents.cancel && el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener)
        } else el[domMethod](touchEvents.start, swiper.onTouchStart, !1), document[domMethod](touchEvents.move, swiper.onTouchMove, capture), document[domMethod](touchEvents.end, swiper.onTouchEnd, !1);
        (params.preventClicks || params.preventClicksPropagation) && el[domMethod]("click", swiper.onClick, !0), params.cssMode && wrapperEl[domMethod]("scroll", swiper.onScroll), params.updateOnWindowResize ? swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : swiper[swiperMethod]("observerUpdate", onResize, !0)
    };
    const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
    var core_defaults = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: !1,
        loopPreventsSlide: !0,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

    function moduleExtendParams(params, allModulesParams) {
        return function (obj = {}) {
            const moduleParamName = Object.keys(obj)[0],
                moduleParams = obj[moduleParamName];
            "object" == typeof moduleParams && null !== moduleParams ? (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && !0 === params[moduleParamName] && (params[moduleParamName] = {
                auto: !0
            }), moduleParamName in params && "enabled" in moduleParams ? (!0 === params[moduleParamName] && (params[moduleParamName] = {
                enabled: !0
            }), "object" != typeof params[moduleParamName] || "enabled" in params[moduleParamName] || (params[moduleParamName].enabled = !0), params[moduleParamName] || (params[moduleParamName] = {
                enabled: !1
            }), utils_extend(allModulesParams, obj)) : utils_extend(allModulesParams, obj)) : utils_extend(allModulesParams, obj)
        }
    }
    const prototypes = {
        eventsEmitter: {
            on(events, handler, priority) {
                const self = this;
                if ("function" != typeof handler) return self;
                const method = priority ? "unshift" : "push";
                return events.split(" ").forEach(event => {
                    self.eventsListeners[event] || (self.eventsListeners[event] = []), self.eventsListeners[event][method](handler)
                }), self
            },
            once(events, handler, priority) {
                const self = this;
                if ("function" != typeof handler) return self;

                function onceHandler(...args) {
                    self.off(events, onceHandler), onceHandler.__emitterProxy && delete onceHandler.__emitterProxy, handler.apply(self, args)
                }
                return onceHandler.__emitterProxy = handler, self.on(events, onceHandler, priority)
            },
            onAny(handler, priority) {
                const self = this;
                if ("function" != typeof handler) return self;
                const method = priority ? "unshift" : "push";
                return self.eventsAnyListeners.indexOf(handler) < 0 && self.eventsAnyListeners[method](handler), self
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                return index >= 0 && self.eventsAnyListeners.splice(index, 1), self
            },
            off(events, handler) {
                const self = this;
                return self.eventsListeners ? (events.split(" ").forEach(event => {
                    void 0 === handler ? self.eventsListeners[event] = [] : self.eventsListeners[event] && self.eventsListeners[event].forEach((eventHandler, index) => {
                        (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) && self.eventsListeners[event].splice(index, 1)
                    })
                }), self) : self
            },
            emit(...args) {
                const self = this;
                if (!self.eventsListeners) return self;
                let events, data, context;
                "string" == typeof args[0] || Array.isArray(args[0]) ? (events = args[0], data = args.slice(1, args.length), context = self) : (events = args[0].events, data = args[0].data, context = args[0].context || self), data.unshift(context);
                return (Array.isArray(events) ? events : events.split(" ")).forEach(event => {
                    self.eventsAnyListeners && self.eventsAnyListeners.length && self.eventsAnyListeners.forEach(eventHandler => {
                        eventHandler.apply(context, [event, ...data])
                    }), self.eventsListeners && self.eventsListeners[event] && self.eventsListeners[event].forEach(eventHandler => {
                        eventHandler.apply(context, data)
                    })
                }), self
            }
        },
        update: {
            updateSize: function () {
                const swiper = this;
                let width, height;
                const $el = swiper.$el;
                width = void 0 !== swiper.params.width && null !== swiper.params.width ? swiper.params.width : $el[0].clientWidth, height = void 0 !== swiper.params.height && null !== swiper.params.height ? swiper.params.height : $el[0].clientHeight, 0 === width && swiper.isHorizontal() || 0 === height && swiper.isVertical() || (width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10), height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10), Number.isNaN(width) && (width = 0), Number.isNaN(height) && (height = 0), Object.assign(swiper, {
                    width: width,
                    height: height,
                    size: swiper.isHorizontal() ? width : height
                }))
            },
            updateSlides: function () {
                const swiper = this;

                function getDirectionLabel(property) {
                    return swiper.isHorizontal() ? property : {
                        width: "height",
                        "margin-top": "margin-left",
                        "margin-bottom ": "margin-right",
                        "margin-left": "margin-top",
                        "margin-right": "margin-bottom",
                        "padding-left": "padding-top",
                        "padding-right": "padding-bottom",
                        marginRight: "marginBottom"
                    }[property]
                }

                function getDirectionPropertyValue(node, label) {
                    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0)
                }
                const params = swiper.params,
                    {
                        $wrapperEl: $wrapperEl,
                        size: swiperSize,
                        rtlTranslate: rtl,
                        wrongRTL: wrongRTL
                    } = swiper,
                    isVirtual = swiper.virtual && params.virtual.enabled,
                    previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length,
                    slides = $wrapperEl.children("." + swiper.params.slideClass),
                    slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
                let snapGrid = [];
                const slidesGrid = [],
                    slidesSizesGrid = [];
                let offsetBefore = params.slidesOffsetBefore;
                "function" == typeof offsetBefore && (offsetBefore = params.slidesOffsetBefore.call(swiper));
                let offsetAfter = params.slidesOffsetAfter;
                "function" == typeof offsetAfter && (offsetAfter = params.slidesOffsetAfter.call(swiper));
                const previousSnapGridLength = swiper.snapGrid.length,
                    previousSlidesGridLength = swiper.slidesGrid.length;
                let spaceBetween = params.spaceBetween,
                    slidePosition = -offsetBefore,
                    prevSlideSize = 0,
                    index = 0;
                if (void 0 === swiperSize) return;
                "string" == typeof spaceBetween && spaceBetween.indexOf("%") >= 0 && (spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize), swiper.virtualSize = -spaceBetween, rtl ? slides.css({
                    marginLeft: "",
                    marginBottom: "",
                    marginTop: ""
                }) : slides.css({
                    marginRight: "",
                    marginBottom: "",
                    marginTop: ""
                }), params.centeredSlides && params.cssMode && (setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", ""), setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", ""));
                const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
                let slideSize;
                gridEnabled && swiper.grid.initSlides(slidesLength);
                const shouldResetSlideSize = "auto" === params.slidesPerView && params.breakpoints && Object.keys(params.breakpoints).filter(key => void 0 !== params.breakpoints[key].slidesPerView).length > 0;
                for (let i = 0; i < slidesLength; i += 1) {
                    slideSize = 0;
                    const slide = slides.eq(i);
                    if (gridEnabled && swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel), "none" !== slide.css("display")) {
                        if ("auto" === params.slidesPerView) {
                            shouldResetSlideSize && (slides[i].style[getDirectionLabel("width")] = "");
                            const slideStyles = getComputedStyle(slide[0]),
                                currentTransform = slide[0].style.transform,
                                currentWebKitTransform = slide[0].style.webkitTransform;
                            if (currentTransform && (slide[0].style.transform = "none"), currentWebKitTransform && (slide[0].style.webkitTransform = "none"), params.roundLengths) slideSize = swiper.isHorizontal() ? slide.outerWidth(!0) : slide.outerHeight(!0);
                            else {
                                const width = getDirectionPropertyValue(slideStyles, "width"),
                                    paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left"),
                                    paddingRight = getDirectionPropertyValue(slideStyles, "padding-right"),
                                    marginLeft = getDirectionPropertyValue(slideStyles, "margin-left"),
                                    marginRight = getDirectionPropertyValue(slideStyles, "margin-right"),
                                    boxSizing = slideStyles.getPropertyValue("box-sizing");
                                if (boxSizing && "border-box" === boxSizing) slideSize = width + marginLeft + marginRight;
                                else {
                                    const {
                                        clientWidth: clientWidth,
                                        offsetWidth: offsetWidth
                                    } = slide[0];
                                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth)
                                }
                            }
                            currentTransform && (slide[0].style.transform = currentTransform), currentWebKitTransform && (slide[0].style.webkitTransform = currentWebKitTransform), params.roundLengths && (slideSize = Math.floor(slideSize))
                        } else slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView, params.roundLengths && (slideSize = Math.floor(slideSize)), slides[i] && (slides[i].style[getDirectionLabel("width")] = slideSize + "px");
                        slides[i] && (slides[i].swiperSlideSize = slideSize), slidesSizesGrid.push(slideSize), params.centeredSlides ? (slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween, 0 === prevSlideSize && 0 !== i && (slidePosition = slidePosition - swiperSize / 2 - spaceBetween), 0 === i && (slidePosition = slidePosition - swiperSize / 2 - spaceBetween), Math.abs(slidePosition) < .001 && (slidePosition = 0), params.roundLengths && (slidePosition = Math.floor(slidePosition)), index % params.slidesPerGroup == 0 && snapGrid.push(slidePosition), slidesGrid.push(slidePosition)) : (params.roundLengths && (slidePosition = Math.floor(slidePosition)), (index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup == 0 && snapGrid.push(slidePosition), slidesGrid.push(slidePosition), slidePosition = slidePosition + slideSize + spaceBetween), swiper.virtualSize += slideSize + spaceBetween, prevSlideSize = slideSize, index += 1
                    }
                }
                if (swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter, rtl && wrongRTL && ("slide" === params.effect || "coverflow" === params.effect) && $wrapperEl.css({
                    width: swiper.virtualSize + params.spaceBetween + "px"
                }), params.setWrapperSize && $wrapperEl.css({
                    [getDirectionLabel("width")]: swiper.virtualSize + params.spaceBetween + "px"
                }), gridEnabled && swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel), !params.centeredSlides) {
                    const newSlidesGrid = [];
                    for (let i = 0; i < snapGrid.length; i += 1) {
                        let slidesGridItem = snapGrid[i];
                        params.roundLengths && (slidesGridItem = Math.floor(slidesGridItem)), snapGrid[i] <= swiper.virtualSize - swiperSize && newSlidesGrid.push(slidesGridItem)
                    }
                    snapGrid = newSlidesGrid, Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1 && snapGrid.push(swiper.virtualSize - swiperSize)
                }
                if (0 === snapGrid.length && (snapGrid = [0]), 0 !== params.spaceBetween) {
                    const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
                    slides.filter((_, slideIndex) => !params.cssMode || slideIndex !== slides.length - 1).css({
                        [key]: spaceBetween + "px"
                    })
                }
                if (params.centeredSlides && params.centeredSlidesBounds) {
                    let allSlidesSize = 0;
                    slidesSizesGrid.forEach(slideSizeValue => {
                        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0)
                    }), allSlidesSize -= params.spaceBetween;
                    const maxSnap = allSlidesSize - swiperSize;
                    snapGrid = snapGrid.map(snap => snap < 0 ? -offsetBefore : snap > maxSnap ? maxSnap + offsetAfter : snap)
                }
                if (params.centerInsufficientSlides) {
                    let allSlidesSize = 0;
                    if (slidesSizesGrid.forEach(slideSizeValue => {
                        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0)
                    }), allSlidesSize -= params.spaceBetween, allSlidesSize < swiperSize) {
                        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                        snapGrid.forEach((snap, snapIndex) => {
                            snapGrid[snapIndex] = snap - allSlidesOffset
                        }), slidesGrid.forEach((snap, snapIndex) => {
                            slidesGrid[snapIndex] = snap + allSlidesOffset
                        })
                    }
                }
                if (Object.assign(swiper, {
                    slides: slides,
                    snapGrid: snapGrid,
                    slidesGrid: slidesGrid,
                    slidesSizesGrid: slidesSizesGrid
                }), params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", -snapGrid[0] + "px"), setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2 + "px");
                    const addToSnapGrid = -swiper.snapGrid[0],
                        addToSlidesGrid = -swiper.slidesGrid[0];
                    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid), swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid)
                }
                slidesLength !== previousSlidesLength && swiper.emit("slidesLengthChange"), snapGrid.length !== previousSnapGridLength && (swiper.params.watchOverflow && swiper.checkOverflow(), swiper.emit("snapGridLengthChange")), slidesGrid.length !== previousSlidesGridLength && swiper.emit("slidesGridLengthChange"), params.watchSlidesProgress && swiper.updateSlidesOffset()
            },
            updateAutoHeight: function (speed) {
                const swiper = this,
                    activeSlides = [],
                    isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                let i, newHeight = 0;
                "number" == typeof speed ? swiper.setTransition(speed) : !0 === speed && swiper.setTransition(swiper.params.speed);
                const getSlideByIndex = index => isVirtual ? swiper.slides.filter(el => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index)[0] : swiper.slides.eq(index)[0];
                if ("auto" !== swiper.params.slidesPerView && swiper.params.slidesPerView > 1)
                    if (swiper.params.centeredSlides) swiper.visibleSlides.each(slide => {
                        activeSlides.push(slide)
                    });
                    else
                        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                            const index = swiper.activeIndex + i;
                            if (index > swiper.slides.length && !isVirtual) break;
                            activeSlides.push(getSlideByIndex(index))
                        } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
                for (i = 0; i < activeSlides.length; i += 1)
                    if (void 0 !== activeSlides[i]) {
                        const height = activeSlides[i].offsetHeight;
                        newHeight = height > newHeight ? height : newHeight
                    } newHeight && swiper.$wrapperEl.css("height", newHeight + "px")
            },
            updateSlidesOffset: function () {
                const swiper = this,
                    slides = swiper.slides;
                for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop
            },
            updateSlidesProgress: function (translate = this && this.translate || 0) {
                const swiper = this,
                    params = swiper.params,
                    {
                        slides: slides,
                        rtlTranslate: rtl,
                        snapGrid: snapGrid
                    } = swiper;
                if (0 === slides.length) return;
                void 0 === slides[0].swiperSlideOffset && swiper.updateSlidesOffset();
                let offsetCenter = -translate;
                rtl && (offsetCenter = translate), slides.removeClass(params.slideVisibleClass), swiper.visibleSlidesIndexes = [], swiper.visibleSlides = [];
                for (let i = 0; i < slides.length; i += 1) {
                    const slide = slides[i];
                    let slideOffset = slide.swiperSlideOffset;
                    params.cssMode && params.centeredSlides && (slideOffset -= slides[0].swiperSlideOffset);
                    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween),
                        originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween),
                        slideBefore = -(offsetCenter - slideOffset),
                        slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                    (slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size) && (swiper.visibleSlides.push(slide), swiper.visibleSlidesIndexes.push(i), slides.eq(i).addClass(params.slideVisibleClass)), slide.progress = rtl ? -slideProgress : slideProgress, slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress
                }
                swiper.visibleSlides = dom(swiper.visibleSlides)
            },
            updateProgress: function (translate) {
                const swiper = this;
                if (void 0 === translate) {
                    const multiplier = swiper.rtlTranslate ? -1 : 1;
                    translate = swiper && swiper.translate && swiper.translate * multiplier || 0
                }
                const params = swiper.params,
                    translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
                let {
                    progress: progress,
                    isBeginning: isBeginning,
                    isEnd: isEnd
                } = swiper;
                const wasBeginning = isBeginning,
                    wasEnd = isEnd;
                0 === translatesDiff ? (progress = 0, isBeginning = !0, isEnd = !0) : (progress = (translate - swiper.minTranslate()) / translatesDiff, isBeginning = progress <= 0, isEnd = progress >= 1), Object.assign(swiper, {
                    progress: progress,
                    isBeginning: isBeginning,
                    isEnd: isEnd
                }), (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) && swiper.updateSlidesProgress(translate), isBeginning && !wasBeginning && swiper.emit("reachBeginning toEdge"), isEnd && !wasEnd && swiper.emit("reachEnd toEdge"), (wasBeginning && !isBeginning || wasEnd && !isEnd) && swiper.emit("fromEdge"), swiper.emit("progress", progress)
            },
            updateSlidesClasses: function () {
                const swiper = this,
                    {
                        slides: slides,
                        params: params,
                        $wrapperEl: $wrapperEl,
                        activeIndex: activeIndex,
                        realIndex: realIndex
                    } = swiper,
                    isVirtual = swiper.virtual && params.virtual.enabled;
                let activeSlide;
                slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`), activeSlide = isVirtual ? swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`) : slides.eq(activeIndex), activeSlide.addClass(params.slideActiveClass), params.loop && (activeSlide.hasClass(params.slideDuplicateClass) ? $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass) : $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass));
                let nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);
                params.loop && 0 === nextSlide.length && (nextSlide = slides.eq(0), nextSlide.addClass(params.slideNextClass));
                let prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);
                params.loop && 0 === prevSlide.length && (prevSlide = slides.eq(-1), prevSlide.addClass(params.slidePrevClass)), params.loop && (nextSlide.hasClass(params.slideDuplicateClass) ? $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass) : $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass), prevSlide.hasClass(params.slideDuplicateClass) ? $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass) : $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass)), swiper.emitSlidesClasses()
            },
            updateActiveIndex: function (newActiveIndex) {
                const swiper = this,
                    translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate,
                    {
                        slidesGrid: slidesGrid,
                        snapGrid: snapGrid,
                        params: params,
                        activeIndex: previousIndex,
                        realIndex: previousRealIndex,
                        snapIndex: previousSnapIndex
                    } = swiper;
                let snapIndex, activeIndex = newActiveIndex;
                if (void 0 === activeIndex) {
                    for (let i = 0; i < slidesGrid.length; i += 1) void 0 !== slidesGrid[i + 1] ? translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2 ? activeIndex = i : translate >= slidesGrid[i] && translate < slidesGrid[i + 1] && (activeIndex = i + 1) : translate >= slidesGrid[i] && (activeIndex = i);
                    params.normalizeSlideIndex && (activeIndex < 0 || void 0 === activeIndex) && (activeIndex = 0)
                }
                if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate);
                else {
                    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup)
                }
                if (snapIndex >= snapGrid.length && (snapIndex = snapGrid.length - 1), activeIndex === previousIndex) return void (snapIndex !== previousSnapIndex && (swiper.snapIndex = snapIndex, swiper.emit("snapIndexChange")));
                const realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
                Object.assign(swiper, {
                    snapIndex: snapIndex,
                    realIndex: realIndex,
                    previousIndex: previousIndex,
                    activeIndex: activeIndex
                }), swiper.emit("activeIndexChange"), swiper.emit("snapIndexChange"), previousRealIndex !== realIndex && swiper.emit("realIndexChange"), (swiper.initialized || swiper.params.runCallbacksOnInit) && swiper.emit("slideChange")
            },
            updateClickedSlide: function (e) {
                const swiper = this,
                    params = swiper.params,
                    slide = dom(e.target).closest("." + params.slideClass)[0];
                let slideIndex, slideFound = !1;
                if (slide)
                    for (let i = 0; i < swiper.slides.length; i += 1)
                        if (swiper.slides[i] === slide) {
                            slideFound = !0, slideIndex = i;
                            break
                        } if (!slide || !slideFound) return swiper.clickedSlide = void 0, void (swiper.clickedIndex = void 0);
                swiper.clickedSlide = slide, swiper.virtual && swiper.params.virtual.enabled ? swiper.clickedIndex = parseInt(dom(slide).attr("data-swiper-slide-index"), 10) : swiper.clickedIndex = slideIndex, params.slideToClickedSlide && void 0 !== swiper.clickedIndex && swiper.clickedIndex !== swiper.activeIndex && swiper.slideToClickedSlide()
            }
        },
        translate: {
            getTranslate: function (axis = (this.isHorizontal() ? "x" : "y")) {
                const {
                    params: params,
                    rtlTranslate: rtl,
                    translate: translate,
                    $wrapperEl: $wrapperEl
                } = this;
                if (params.virtualTranslate) return rtl ? -translate : translate;
                if (params.cssMode) return translate;
                let currentTranslate = getTranslate($wrapperEl[0], axis);
                return rtl && (currentTranslate = -currentTranslate), currentTranslate || 0
            },
            setTranslate: function (translate, byController) {
                const swiper = this,
                    {
                        rtlTranslate: rtl,
                        params: params,
                        $wrapperEl: $wrapperEl,
                        wrapperEl: wrapperEl,
                        progress: progress
                    } = swiper;
                let newProgress, x = 0,
                    y = 0;
                swiper.isHorizontal() ? x = rtl ? -translate : translate : y = translate, params.roundLengths && (x = Math.floor(x), y = Math.floor(y)), params.cssMode ? wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y : params.virtualTranslate || $wrapperEl.transform(`translate3d(${x}px, ${y}px, 0px)`), swiper.previousTranslate = swiper.translate, swiper.translate = swiper.isHorizontal() ? x : y;
                const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
                newProgress = 0 === translatesDiff ? 0 : (translate - swiper.minTranslate()) / translatesDiff, newProgress !== progress && swiper.updateProgress(translate), swiper.emit("setTranslate", swiper.translate, byController)
            },
            minTranslate: function () {
                return -this.snapGrid[0]
            },
            maxTranslate: function () {
                return -this.snapGrid[this.snapGrid.length - 1]
            },
            translateTo: function (translate = 0, speed = this.params.speed, runCallbacks = !0, translateBounds = !0, internal) {
                const swiper = this,
                    {
                        params: params,
                        wrapperEl: wrapperEl
                    } = swiper;
                if (swiper.animating && params.preventInteractionOnTransition) return !1;
                const minTranslate = swiper.minTranslate(),
                    maxTranslate = swiper.maxTranslate();
                let newTranslate;
                if (newTranslate = translateBounds && translate > minTranslate ? minTranslate : translateBounds && translate < maxTranslate ? maxTranslate : translate, swiper.updateProgress(newTranslate), params.cssMode) {
                    const isH = swiper.isHorizontal();
                    if (0 === speed) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
                    else {
                        if (!swiper.support.smoothScroll) return animateCSSModeScroll({
                            swiper: swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        }), !0;
                        wrapperEl.scrollTo({
                            [isH ? "left" : "top"]: -newTranslate,
                            behavior: "smooth"
                        })
                    }
                    return !0
                }
                return 0 === speed ? (swiper.setTransition(0), swiper.setTranslate(newTranslate), runCallbacks && (swiper.emit("beforeTransitionStart", speed, internal), swiper.emit("transitionEnd"))) : (swiper.setTransition(speed), swiper.setTranslate(newTranslate), runCallbacks && (swiper.emit("beforeTransitionStart", speed, internal), swiper.emit("transitionStart")), swiper.animating || (swiper.animating = !0, swiper.onTranslateToWrapperTransitionEnd || (swiper.onTranslateToWrapperTransitionEnd = function (e) {
                    swiper && !swiper.destroyed && e.target === this && (swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd), swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd), swiper.onTranslateToWrapperTransitionEnd = null, delete swiper.onTranslateToWrapperTransitionEnd, runCallbacks && swiper.emit("transitionEnd"))
                }), swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd), swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd))), !0
            }
        },
        transition: {
            setTransition: function (duration, byController) {
                const swiper = this;
                swiper.params.cssMode || swiper.$wrapperEl.transition(duration), swiper.emit("setTransition", duration, byController)
            },
            transitionStart: function (runCallbacks = !0, direction) {
                const swiper = this,
                    {
                        params: params
                    } = swiper;
                params.cssMode || (params.autoHeight && swiper.updateAutoHeight(), transitionEmit({
                    swiper: swiper,
                    runCallbacks: runCallbacks,
                    direction: direction,
                    step: "Start"
                }))
            },
            transitionEnd: function (runCallbacks = !0, direction) {
                const {
                    params: params
                } = this;
                this.animating = !1, params.cssMode || (this.setTransition(0), transitionEmit({
                    swiper: this,
                    runCallbacks: runCallbacks,
                    direction: direction,
                    step: "End"
                }))
            }
        },
        slide: {
            slideTo: function (index = 0, speed = this.params.speed, runCallbacks = !0, internal, initial) {
                if ("number" != typeof index && "string" != typeof index) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
                if ("string" == typeof index) {
                    const indexAsNumber = parseInt(index, 10);
                    if (!isFinite(indexAsNumber)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
                    index = indexAsNumber
                }
                const swiper = this;
                let slideIndex = index;
                slideIndex < 0 && (slideIndex = 0);
                const {
                    params: params,
                    snapGrid: snapGrid,
                    slidesGrid: slidesGrid,
                    previousIndex: previousIndex,
                    activeIndex: activeIndex,
                    rtlTranslate: rtl,
                    wrapperEl: wrapperEl,
                    enabled: enabled
                } = swiper;
                if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return !1;
                const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
                let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
                snapIndex >= snapGrid.length && (snapIndex = snapGrid.length - 1), (activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks && swiper.emit("beforeSlideChangeStart");
                const translate = -snapGrid[snapIndex];
                if (swiper.updateProgress(translate), params.normalizeSlideIndex)
                    for (let i = 0; i < slidesGrid.length; i += 1) {
                        const normalizedTranslate = -Math.floor(100 * translate),
                            normalizedGrid = Math.floor(100 * slidesGrid[i]),
                            normalizedGridNext = Math.floor(100 * slidesGrid[i + 1]);
                        void 0 !== slidesGrid[i + 1] ? normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2 ? slideIndex = i : normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext && (slideIndex = i + 1) : normalizedTranslate >= normalizedGrid && (slideIndex = i)
                    }
                if (swiper.initialized && slideIndex !== activeIndex) {
                    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return !1;
                    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate() && (activeIndex || 0) !== slideIndex) return !1
                }
                let direction;
                if (direction = slideIndex > activeIndex ? "next" : slideIndex < activeIndex ? "prev" : "reset", rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) return swiper.updateActiveIndex(slideIndex), params.autoHeight && swiper.updateAutoHeight(), swiper.updateSlidesClasses(), "slide" !== params.effect && swiper.setTranslate(translate), "reset" !== direction && (swiper.transitionStart(runCallbacks, direction), swiper.transitionEnd(runCallbacks, direction)), !1;
                if (params.cssMode) {
                    const isH = swiper.isHorizontal(),
                        t = rtl ? translate : -translate;
                    if (0 === speed) {
                        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                        isVirtual && (swiper.wrapperEl.style.scrollSnapType = "none", swiper._immediateVirtual = !0), wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t, isVirtual && requestAnimationFrame(() => {
                            swiper.wrapperEl.style.scrollSnapType = "", swiper._swiperImmediateVirtual = !1
                        })
                    } else {
                        if (!swiper.support.smoothScroll) return animateCSSModeScroll({
                            swiper: swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        }), !0;
                        wrapperEl.scrollTo({
                            [isH ? "left" : "top"]: t,
                            behavior: "smooth"
                        })
                    }
                    return !0
                }
                return 0 === speed ? (swiper.setTransition(0), swiper.setTranslate(translate), swiper.updateActiveIndex(slideIndex), swiper.updateSlidesClasses(), swiper.emit("beforeTransitionStart", speed, internal), swiper.transitionStart(runCallbacks, direction), swiper.transitionEnd(runCallbacks, direction)) : (swiper.setTransition(speed), swiper.setTranslate(translate), swiper.updateActiveIndex(slideIndex), swiper.updateSlidesClasses(), swiper.emit("beforeTransitionStart", speed, internal), swiper.transitionStart(runCallbacks, direction), swiper.animating || (swiper.animating = !0, swiper.onSlideToWrapperTransitionEnd || (swiper.onSlideToWrapperTransitionEnd = function (e) {
                    swiper && !swiper.destroyed && e.target === this && (swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd), swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd), swiper.onSlideToWrapperTransitionEnd = null, delete swiper.onSlideToWrapperTransitionEnd, swiper.transitionEnd(runCallbacks, direction))
                }), swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd), swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd))), !0
            },
            slideToLoop: function (index = 0, speed = this.params.speed, runCallbacks = !0, internal) {
                const swiper = this;
                let newIndex = index;
                return swiper.params.loop && (newIndex += swiper.loopedSlides), swiper.slideTo(newIndex, speed, runCallbacks, internal)
            },
            slideNext: function (speed = this.params.speed, runCallbacks = !0, internal) {
                const swiper = this,
                    {
                        animating: animating,
                        enabled: enabled,
                        params: params
                    } = swiper;
                if (!enabled) return swiper;
                let perGroup = params.slidesPerGroup;
                "auto" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto && (perGroup = Math.max(swiper.slidesPerViewDynamic("current", !0), 1));
                const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
                if (params.loop) {
                    if (animating && params.loopPreventsSlide) return !1;
                    swiper.loopFix(), swiper._clientLeft = swiper.$wrapperEl[0].clientLeft
                }
                return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal)
            },
            slidePrev: function (speed = this.params.speed, runCallbacks = !0, internal) {
                const swiper = this,
                    {
                        params: params,
                        animating: animating,
                        snapGrid: snapGrid,
                        slidesGrid: slidesGrid,
                        rtlTranslate: rtlTranslate,
                        enabled: enabled
                    } = swiper;
                if (!enabled) return swiper;
                if (params.loop) {
                    if (animating && params.loopPreventsSlide) return !1;
                    swiper.loopFix(), swiper._clientLeft = swiper.$wrapperEl[0].clientLeft
                }

                function normalize(val) {
                    return val < 0 ? -Math.floor(Math.abs(val)) : Math.floor(val)
                }
                const normalizedTranslate = normalize(rtlTranslate ? swiper.translate : -swiper.translate),
                    normalizedSnapGrid = snapGrid.map(val => normalize(val));
                let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
                if (void 0 === prevSnap && params.cssMode) {
                    let prevSnapIndex;
                    snapGrid.forEach((snap, snapIndex) => {
                        normalizedTranslate >= snap && (prevSnapIndex = snapIndex)
                    }), void 0 !== prevSnapIndex && (prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex])
                }
                let prevIndex = 0;
                return void 0 !== prevSnap && (prevIndex = slidesGrid.indexOf(prevSnap), prevIndex < 0 && (prevIndex = swiper.activeIndex - 1), "auto" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto && (prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", !0) + 1, prevIndex = Math.max(prevIndex, 0))), swiper.slideTo(prevIndex, speed, runCallbacks, internal)
            },
            slideReset: function (speed = this.params.speed, runCallbacks = !0, internal) {
                return this.slideTo(this.activeIndex, speed, runCallbacks, internal)
            },
            slideToClosest: function (speed = this.params.speed, runCallbacks = !0, internal, threshold = .5) {
                const swiper = this;
                let index = swiper.activeIndex;
                const skip = Math.min(swiper.params.slidesPerGroupSkip, index),
                    snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup),
                    translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
                if (translate >= swiper.snapGrid[snapIndex]) {
                    const currentSnap = swiper.snapGrid[snapIndex];
                    translate - currentSnap > (swiper.snapGrid[snapIndex + 1] - currentSnap) * threshold && (index += swiper.params.slidesPerGroup)
                } else {
                    const prevSnap = swiper.snapGrid[snapIndex - 1];
                    translate - prevSnap <= (swiper.snapGrid[snapIndex] - prevSnap) * threshold && (index -= swiper.params.slidesPerGroup)
                }
                return index = Math.max(index, 0), index = Math.min(index, swiper.slidesGrid.length - 1), swiper.slideTo(index, speed, runCallbacks, internal)
            },
            slideToClickedSlide: function () {
                const swiper = this,
                    {
                        params: params,
                        $wrapperEl: $wrapperEl
                    } = swiper,
                    slidesPerView = "auto" === params.slidesPerView ? swiper.slidesPerViewDynamic() : params.slidesPerView;
                let realIndex, slideToIndex = swiper.clickedIndex;
                if (params.loop) {
                    if (swiper.animating) return;
                    realIndex = parseInt(dom(swiper.clickedSlide).attr("data-swiper-slide-index"), 10), params.centeredSlides ? slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2 ? (swiper.loopFix(), slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index(), nextTick(() => {
                        swiper.slideTo(slideToIndex)
                    })) : swiper.slideTo(slideToIndex) : slideToIndex > swiper.slides.length - slidesPerView ? (swiper.loopFix(), slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index(), nextTick(() => {
                        swiper.slideTo(slideToIndex)
                    })) : swiper.slideTo(slideToIndex)
                } else swiper.slideTo(slideToIndex)
            }
        },
        loop: {
            loopCreate: function () {
                const swiper = this,
                    document = ssr_window_esm_getDocument(),
                    {
                        params: params,
                        $wrapperEl: $wrapperEl
                    } = swiper,
                    $selector = dom($wrapperEl.children()[0].parentNode);
                $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
                let slides = $selector.children("." + params.slideClass);
                if (params.loopFillGroupWithBlank) {
                    const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
                    if (blankSlidesNum !== params.slidesPerGroup) {
                        for (let i = 0; i < blankSlidesNum; i += 1) {
                            const blankNode = dom(document.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
                            $selector.append(blankNode)
                        }
                        slides = $selector.children("." + params.slideClass)
                    }
                }
                "auto" !== params.slidesPerView || params.loopedSlides || (params.loopedSlides = slides.length), swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10)), swiper.loopedSlides += params.loopAdditionalSlides, swiper.loopedSlides > slides.length && (swiper.loopedSlides = slides.length);
                const prependSlides = [],
                    appendSlides = [];
                slides.each((el, index) => {
                    const slide = dom(el);
                    index < swiper.loopedSlides && appendSlides.push(el), index < slides.length && index >= slides.length - swiper.loopedSlides && prependSlides.push(el), slide.attr("data-swiper-slide-index", index)
                });
                for (let i = 0; i < appendSlides.length; i += 1) $selector.append(dom(appendSlides[i].cloneNode(!0)).addClass(params.slideDuplicateClass));
                for (let i = prependSlides.length - 1; i >= 0; i -= 1) $selector.prepend(dom(prependSlides[i].cloneNode(!0)).addClass(params.slideDuplicateClass))
            },
            loopFix: function () {
                const swiper = this;
                swiper.emit("beforeLoopFix");
                const {
                    activeIndex: activeIndex,
                    slides: slides,
                    loopedSlides: loopedSlides,
                    allowSlidePrev: allowSlidePrev,
                    allowSlideNext: allowSlideNext,
                    snapGrid: snapGrid,
                    rtlTranslate: rtl
                } = swiper;
                let newIndex;
                swiper.allowSlidePrev = !0, swiper.allowSlideNext = !0;
                const diff = -snapGrid[activeIndex] - swiper.getTranslate();
                if (activeIndex < loopedSlides) {
                    newIndex = slides.length - 3 * loopedSlides + activeIndex, newIndex += loopedSlides;
                    swiper.slideTo(newIndex, 0, !1, !0) && 0 !== diff && swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff)
                } else if (activeIndex >= slides.length - loopedSlides) {
                    newIndex = -slides.length + activeIndex + loopedSlides, newIndex += loopedSlides;
                    swiper.slideTo(newIndex, 0, !1, !0) && 0 !== diff && swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff)
                }
                swiper.allowSlidePrev = allowSlidePrev, swiper.allowSlideNext = allowSlideNext, swiper.emit("loopFix")
            },
            loopDestroy: function () {
                const {
                    $wrapperEl: $wrapperEl,
                    params: params,
                    slides: slides
                } = this;
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove(), slides.removeAttr("data-swiper-slide-index")
            }
        },
        grabCursor: {
            setGrabCursor: function (moving) {
                if (this.support.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked || this.params.cssMode) return;
                const el = "container" === this.params.touchEventsTarget ? this.el : this.wrapperEl;
                el.style.cursor = "move", el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab", el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab", el.style.cursor = moving ? "grabbing" : "grab"
            },
            unsetGrabCursor: function () {
                this.support.touch || this.params.watchOverflow && this.isLocked || this.params.cssMode || (this["container" === this.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
            }
        },
        events: {
            attachEvents: function () {
                const swiper = this,
                    document = ssr_window_esm_getDocument(),
                    {
                        params: params,
                        support: support
                    } = swiper;
                swiper.onTouchStart = onTouchStart_onTouchStart.bind(swiper), swiper.onTouchMove = onTouchMove_onTouchMove.bind(swiper), swiper.onTouchEnd = onTouchEnd_onTouchEnd.bind(swiper), params.cssMode && (swiper.onScroll = onScroll.bind(swiper)), swiper.onClick = onClick_onClick.bind(swiper), support.touch && !dummyEventAttached && (document.addEventListener("touchstart", dummyEventListener), dummyEventAttached = !0), events_events(swiper, "on")
            },
            detachEvents: function () {
                events_events(this, "off")
            }
        },
        breakpoints: {
            setBreakpoint: function () {
                const swiper = this,
                    {
                        activeIndex: activeIndex,
                        initialized: initialized,
                        loopedSlides: loopedSlides = 0,
                        params: params,
                        $el: $el
                    } = swiper,
                    breakpoints = params.breakpoints;
                if (!breakpoints || breakpoints && 0 === Object.keys(breakpoints).length) return;
                const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
                if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
                const breakpointParams = (breakpoint in breakpoints ? breakpoints[breakpoint] : void 0) || swiper.originalParams,
                    wasMultiRow = isGridEnabled(swiper, params),
                    isMultiRow = isGridEnabled(swiper, breakpointParams),
                    wasEnabled = params.enabled;
                wasMultiRow && !isMultiRow ? ($el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`), swiper.emitContainerClasses()) : !wasMultiRow && isMultiRow && ($el.addClass(params.containerModifierClass + "grid"), (breakpointParams.grid.fill && "column" === breakpointParams.grid.fill || !breakpointParams.grid.fill && "column" === params.grid.fill) && $el.addClass(params.containerModifierClass + "grid-column"), swiper.emitContainerClasses());
                const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction,
                    needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
                directionChanged && initialized && swiper.changeDirection(), utils_extend(swiper.params, breakpointParams);
                const isEnabled = swiper.params.enabled;
                Object.assign(swiper, {
                    allowTouchMove: swiper.params.allowTouchMove,
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev
                }), wasEnabled && !isEnabled ? swiper.disable() : !wasEnabled && isEnabled && swiper.enable(), swiper.currentBreakpoint = breakpoint, swiper.emit("_beforeBreakpoint", breakpointParams), needsReLoop && initialized && (swiper.loopDestroy(), swiper.loopCreate(), swiper.updateSlides(), swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, !1)), swiper.emit("breakpoint", breakpointParams)
            },
            getBreakpoint: function (breakpoints, base = "window", containerEl) {
                if (!breakpoints || "container" === base && !containerEl) return;
                let breakpoint = !1;
                const window = getWindow(),
                    currentHeight = "window" === base ? window.innerHeight : containerEl.clientHeight,
                    points = Object.keys(breakpoints).map(point => {
                        if ("string" == typeof point && 0 === point.indexOf("@")) {
                            const minRatio = parseFloat(point.substr(1));
                            return {
                                value: currentHeight * minRatio,
                                point: point
                            }
                        }
                        return {
                            value: point,
                            point: point
                        }
                    });
                points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
                for (let i = 0; i < points.length; i += 1) {
                    const {
                        point: point,
                        value: value
                    } = points[i];
                    "window" === base ? window.matchMedia(`(min-width: ${value}px)`).matches && (breakpoint = point) : value <= containerEl.clientWidth && (breakpoint = point)
                }
                return breakpoint || "max"
            }
        },
        checkOverflow: {
            checkOverflow: function () {
                const swiper = this,
                    {
                        isLocked: wasLocked,
                        params: params
                    } = swiper,
                    {
                        slidesOffsetBefore: slidesOffsetBefore
                    } = params;
                if (slidesOffsetBefore) {
                    const lastSlideIndex = swiper.slides.length - 1,
                        lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + 2 * slidesOffsetBefore;
                    swiper.isLocked = swiper.size > lastSlideRightEdge
                } else swiper.isLocked = 1 === swiper.snapGrid.length;
                !0 === params.allowSlideNext && (swiper.allowSlideNext = !swiper.isLocked), !0 === params.allowSlidePrev && (swiper.allowSlidePrev = !swiper.isLocked), wasLocked && wasLocked !== swiper.isLocked && (swiper.isEnd = !1), wasLocked !== swiper.isLocked && swiper.emit(swiper.isLocked ? "lock" : "unlock")
            }
        },
        classes: {
            addClasses: function () {
                const {
                    classNames: classNames,
                    params: params,
                    rtl: rtl,
                    $el: $el,
                    device: device,
                    support: support
                } = this, suffixes = function (entries, prefix) {
                    const resultClasses = [];
                    return entries.forEach(item => {
                        "object" == typeof item ? Object.keys(item).forEach(classNames => {
                            item[classNames] && resultClasses.push(prefix + classNames)
                        }) : "string" == typeof item && resultClasses.push(prefix + item)
                    }), resultClasses
                }(["initialized", params.direction, {
                    "pointer-events": !support.touch
                }, {
                        "free-mode": this.params.freeMode && params.freeMode.enabled
                    }, {
                        autoheight: params.autoHeight
                    }, {
                        rtl: rtl
                    }, {
                        grid: params.grid && params.grid.rows > 1
                    }, {
                        "grid-column": params.grid && params.grid.rows > 1 && "column" === params.grid.fill
                    }, {
                        android: device.android
                    }, {
                        ios: device.ios
                    }, {
                        "css-mode": params.cssMode
                    }, {
                        centered: params.cssMode && params.centeredSlides
                    }], params.containerModifierClass);
                classNames.push(...suffixes), $el.addClass([...classNames].join(" ")), this.emitContainerClasses()
            },
            removeClasses: function () {
                const {
                    $el: $el,
                    classNames: classNames
                } = this;
                $el.removeClass(classNames.join(" ")), this.emitContainerClasses()
            }
        },
        images: {
            loadImage: function (imageEl, src, srcset, sizes, checkForComplete, callback) {
                const window = getWindow();
                let image;

                function onReady() {
                    callback && callback()
                }
                dom(imageEl).parent("picture")[0] || imageEl.complete && checkForComplete ? onReady() : src ? (image = new window.Image, image.onload = onReady, image.onerror = onReady, sizes && (image.sizes = sizes), srcset && (image.srcset = srcset), src && (image.src = src)) : onReady()
            },
            preloadImages: function () {
                const swiper = this;

                function onReady() {
                    null != swiper && swiper && !swiper.destroyed && (void 0 !== swiper.imagesLoaded && (swiper.imagesLoaded += 1), swiper.imagesLoaded === swiper.imagesToLoad.length && (swiper.params.updateOnImagesReady && swiper.update(), swiper.emit("imagesReady")))
                }
                swiper.imagesToLoad = swiper.$el.find("img");
                for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
                    const imageEl = swiper.imagesToLoad[i];
                    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), !0, onReady)
                }
            }
        }
    },
        extendedDefaults = {};
    class core_Swiper {
        constructor(...args) {
            let el, params;
            if (1 === args.length && args[0].constructor && "Object" === Object.prototype.toString.call(args[0]).slice(8, -1) ? params = args[0] : [el, params] = args, params || (params = {}), params = utils_extend({}, params), el && !params.el && (params.el = el), params.el && dom(params.el).length > 1) {
                const swipers = [];
                return dom(params.el).each(containerEl => {
                    const newParams = utils_extend({}, params, {
                        el: containerEl
                    });
                    swipers.push(new core_Swiper(newParams))
                }), swipers
            }
            const swiper = this;
            swiper.__swiper__ = !0, swiper.support = getSupport(), swiper.device = getDevice({
                userAgent: params.userAgent
            }), swiper.browser = getBrowser(), swiper.eventsListeners = {}, swiper.eventsAnyListeners = [], swiper.modules = [...swiper.__modules__], params.modules && Array.isArray(params.modules) && swiper.modules.push(...params.modules);
            const allModulesParams = {};
            swiper.modules.forEach(mod => {
                mod({
                    swiper: swiper,
                    extendParams: moduleExtendParams(params, allModulesParams),
                    on: swiper.on.bind(swiper),
                    once: swiper.once.bind(swiper),
                    off: swiper.off.bind(swiper),
                    emit: swiper.emit.bind(swiper)
                })
            });
            const swiperParams = utils_extend({}, core_defaults, allModulesParams);
            return swiper.params = utils_extend({}, swiperParams, extendedDefaults, params), swiper.originalParams = utils_extend({}, swiper.params), swiper.passedParams = utils_extend({}, params), swiper.params && swiper.params.on && Object.keys(swiper.params.on).forEach(eventName => {
                swiper.on(eventName, swiper.params.on[eventName])
            }), swiper.params && swiper.params.onAny && swiper.onAny(swiper.params.onAny), swiper.$ = dom, Object.assign(swiper, {
                enabled: swiper.params.enabled,
                el: el,
                classNames: [],
                slides: dom(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === swiper.params.direction,
                isVertical: () => "vertical" === swiper.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,
                touchEvents: function () {
                    const touch = ["touchstart", "touchmove", "touchend", "touchcancel"],
                        desktop = ["pointerdown", "pointermove", "pointerup"];
                    return swiper.touchEventsTouch = {
                        start: touch[0],
                        move: touch[1],
                        end: touch[2],
                        cancel: touch[3]
                    }, swiper.touchEventsDesktop = {
                        start: desktop[0],
                        move: desktop[1],
                        end: desktop[2]
                    }, swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop
                }(),
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: swiper.params.focusableElements,
                    lastClickTime: now(),
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    isTouchEvent: void 0,
                    startMoving: void 0
                },
                allowClick: !0,
                allowTouchMove: swiper.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            }), swiper.emit("_swiper"), swiper.params.init && swiper.init(), swiper
        }
        enable() {
            const swiper = this;
            swiper.enabled || (swiper.enabled = !0, swiper.params.grabCursor && swiper.setGrabCursor(), swiper.emit("enable"))
        }
        disable() {
            const swiper = this;
            swiper.enabled && (swiper.enabled = !1, swiper.params.grabCursor && swiper.unsetGrabCursor(), swiper.emit("disable"))
        }
        setProgress(progress, speed) {
            progress = Math.min(Math.max(progress, 0), 1);
            const min = this.minTranslate(),
                current = (this.maxTranslate() - min) * progress + min;
            this.translateTo(current, void 0 === speed ? 0 : speed), this.updateActiveIndex(), this.updateSlidesClasses()
        }
        emitContainerClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const cls = swiper.el.className.split(" ").filter(className => 0 === className.indexOf("swiper") || 0 === className.indexOf(swiper.params.containerModifierClass));
            swiper.emit("_containerClasses", cls.join(" "))
        }
        getSlideClasses(slideEl) {
            const swiper = this;
            return slideEl.className.split(" ").filter(className => 0 === className.indexOf("swiper-slide") || 0 === className.indexOf(swiper.params.slideClass)).join(" ")
        }
        emitSlidesClasses() {
            const swiper = this;
            if (!swiper.params._emitClasses || !swiper.el) return;
            const updates = [];
            swiper.slides.each(slideEl => {
                const classNames = swiper.getSlideClasses(slideEl);
                updates.push({
                    slideEl: slideEl,
                    classNames: classNames
                }), swiper.emit("_slideClass", slideEl, classNames)
            }), swiper.emit("_slideClasses", updates)
        }
        slidesPerViewDynamic(view = "current", exact = !1) {
            const {
                params: params,
                slides: slides,
                slidesGrid: slidesGrid,
                slidesSizesGrid: slidesSizesGrid,
                size: swiperSize,
                activeIndex: activeIndex
            } = this;
            let spv = 1;
            if (params.centeredSlides) {
                let breakLoop, slideSize = slides[activeIndex].swiperSlideSize;
                for (let i = activeIndex + 1; i < slides.length; i += 1) slides[i] && !breakLoop && (slideSize += slides[i].swiperSlideSize, spv += 1, slideSize > swiperSize && (breakLoop = !0));
                for (let i = activeIndex - 1; i >= 0; i -= 1) slides[i] && !breakLoop && (slideSize += slides[i].swiperSlideSize, spv += 1, slideSize > swiperSize && (breakLoop = !0))
            } else if ("current" === view)
                for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    (exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) && (spv += 1)
                } else
                for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    slidesGrid[activeIndex] - slidesGrid[i] < swiperSize && (spv += 1)
                }
            return spv
        }
        update() {
            const swiper = this;
            if (!swiper || swiper.destroyed) return;
            const {
                snapGrid: snapGrid,
                params: params
            } = swiper;

            function setTranslate() {
                const translateValue = swiper.rtlTranslate ? -1 * swiper.translate : swiper.translate,
                    newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                swiper.setTranslate(newTranslate), swiper.updateActiveIndex(), swiper.updateSlidesClasses()
            }
            let translated;
            params.breakpoints && swiper.setBreakpoint(), swiper.updateSize(), swiper.updateSlides(), swiper.updateProgress(), swiper.updateSlidesClasses(), swiper.params.freeMode && swiper.params.freeMode.enabled ? (setTranslate(), swiper.params.autoHeight && swiper.updateAutoHeight()) : (translated = ("auto" === swiper.params.slidesPerView || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides ? swiper.slideTo(swiper.slides.length - 1, 0, !1, !0) : swiper.slideTo(swiper.activeIndex, 0, !1, !0), translated || setTranslate()), params.watchOverflow && snapGrid !== swiper.snapGrid && swiper.checkOverflow(), swiper.emit("update")
        }
        changeDirection(newDirection, needUpdate = !0) {
            const swiper = this,
                currentDirection = swiper.params.direction;
            return newDirection || (newDirection = "horizontal" === currentDirection ? "vertical" : "horizontal"), newDirection === currentDirection || "horizontal" !== newDirection && "vertical" !== newDirection || (swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`), swiper.emitContainerClasses(), swiper.params.direction = newDirection, swiper.slides.each(slideEl => {
                "vertical" === newDirection ? slideEl.style.width = "" : slideEl.style.height = ""
            }), swiper.emit("changeDirection"), needUpdate && swiper.update()), swiper
        }
        mount(el) {
            const swiper = this;
            if (swiper.mounted) return !0;
            const $el = dom(el || swiper.params.el);
            if (!(el = $el[0])) return !1;
            el.swiper = swiper;
            const getWrapperSelector = () => "." + (swiper.params.wrapperClass || "").trim().split(" ").join(".");
            let $wrapperEl = (() => {
                if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                    const res = dom(el.shadowRoot.querySelector(getWrapperSelector()));
                    return res.children = options => $el.children(options), res
                }
                return $el.children(getWrapperSelector())
            })();
            if (0 === $wrapperEl.length && swiper.params.createElements) {
                const wrapper = ssr_window_esm_getDocument().createElement("div");
                $wrapperEl = dom(wrapper), wrapper.className = swiper.params.wrapperClass, $el.append(wrapper), $el.children("." + swiper.params.slideClass).each(slideEl => {
                    $wrapperEl.append(slideEl)
                })
            }
            return Object.assign(swiper, {
                $el: $el,
                el: el,
                $wrapperEl: $wrapperEl,
                wrapperEl: $wrapperEl[0],
                mounted: !0,
                rtl: "rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction"),
                rtlTranslate: "horizontal" === swiper.params.direction && ("rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction")),
                wrongRTL: "-webkit-box" === $wrapperEl.css("display")
            }), !0
        }
        init(el) {
            const swiper = this;
            if (swiper.initialized) return swiper;
            return !1 === swiper.mount(el) || (swiper.emit("beforeInit"), swiper.params.breakpoints && swiper.setBreakpoint(), swiper.addClasses(), swiper.params.loop && swiper.loopCreate(), swiper.updateSize(), swiper.updateSlides(), swiper.params.watchOverflow && swiper.checkOverflow(), swiper.params.grabCursor && swiper.enabled && swiper.setGrabCursor(), swiper.params.preloadImages && swiper.preloadImages(), swiper.params.loop ? swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, !1, !0) : swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, !1, !0), swiper.attachEvents(), swiper.initialized = !0, swiper.emit("init"), swiper.emit("afterInit")), swiper
        }
        destroy(deleteInstance = !0, cleanStyles = !0) {
            const swiper = this,
                {
                    params: params,
                    $el: $el,
                    $wrapperEl: $wrapperEl,
                    slides: slides
                } = swiper;
            return void 0 === swiper.params || swiper.destroyed || (swiper.emit("beforeDestroy"), swiper.initialized = !1, swiper.detachEvents(), params.loop && swiper.loopDestroy(), cleanStyles && (swiper.removeClasses(), $el.removeAttr("style"), $wrapperEl.removeAttr("style"), slides && slides.length && slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), swiper.emit("destroy"), Object.keys(swiper.eventsListeners).forEach(eventName => {
                swiper.off(eventName)
            }), !1 !== deleteInstance && (swiper.$el[0].swiper = null, function (obj) {
                const object = obj;
                Object.keys(object).forEach(key => {
                    try {
                        object[key] = null
                    } catch (e) { }
                    try {
                        delete object[key]
                    } catch (e) { }
                })
            }(swiper)), swiper.destroyed = !0), null
        }
        static extendDefaults(newDefaults) {
            utils_extend(extendedDefaults, newDefaults)
        }
        static get extendedDefaults() {
            return extendedDefaults
        }
        static get defaults() {
            return core_defaults
        }
        static installModule(mod) {
            core_Swiper.prototype.__modules__ || (core_Swiper.prototype.__modules__ = []);
            const modules = core_Swiper.prototype.__modules__;
            "function" == typeof mod && modules.indexOf(mod) < 0 && modules.push(mod)
        }
        static use(module) {
            return Array.isArray(module) ? (module.forEach(m => core_Swiper.installModule(m)), core_Swiper) : (core_Swiper.installModule(module), core_Swiper)
        }
    }
    Object.keys(prototypes).forEach(prototypeGroup => {
        Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
            core_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod]
        })
    }), core_Swiper.use([function ({
        swiper: swiper,
        on: on,
        emit: emit
    }) {
        const window = getWindow();
        let observer = null;
        const resizeHandler = () => {
            swiper && !swiper.destroyed && swiper.initialized && (emit("beforeResize"), emit("resize"))
        },
            orientationChangeHandler = () => {
                swiper && !swiper.destroyed && swiper.initialized && emit("orientationchange")
            };
        on("init", () => {
            swiper.params.resizeObserver && void 0 !== window.ResizeObserver ? swiper && !swiper.destroyed && swiper.initialized && (observer = new ResizeObserver(entries => {
                const {
                    width: width,
                    height: height
                } = swiper;
                let newWidth = width,
                    newHeight = height;
                entries.forEach(({
                    contentBoxSize: contentBoxSize,
                    contentRect: contentRect,
                    target: target
                }) => {
                    target && target !== swiper.el || (newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize, newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize)
                }), newWidth === width && newHeight === height || resizeHandler()
            }), observer.observe(swiper.el)) : (window.addEventListener("resize", resizeHandler), window.addEventListener("orientationchange", orientationChangeHandler))
        }), on("destroy", () => {
            observer && observer.unobserve && swiper.el && (observer.unobserve(swiper.el), observer = null), window.removeEventListener("resize", resizeHandler), window.removeEventListener("orientationchange", orientationChangeHandler)
        })
    }, function ({
        swiper: swiper,
        extendParams: extendParams,
        on: on,
        emit: emit
    }) {
        const observers = [],
            window = getWindow(),
            attach = (target, options = {}) => {
                const observer = new (window.MutationObserver || window.WebkitMutationObserver)(mutations => {
                    if (1 === mutations.length) return void emit("observerUpdate", mutations[0]);
                    const observerUpdate = function () {
                        emit("observerUpdate", mutations[0])
                    };
                    window.requestAnimationFrame ? window.requestAnimationFrame(observerUpdate) : window.setTimeout(observerUpdate, 0)
                });
                observer.observe(target, {
                    attributes: void 0 === options.attributes || options.attributes,
                    childList: void 0 === options.childList || options.childList,
                    characterData: void 0 === options.characterData || options.characterData
                }), observers.push(observer)
            };
        extendParams({
            observer: !1,
            observeParents: !1,
            observeSlideChildren: !1
        }), on("init", () => {
            if (swiper.params.observer) {
                if (swiper.params.observeParents) {
                    const containerParents = swiper.$el.parents();
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i])
                }
                attach(swiper.$el[0], {
                    childList: swiper.params.observeSlideChildren
                }), attach(swiper.$wrapperEl[0], {
                    attributes: !1
                })
            }
        }), on("destroy", () => {
            observers.forEach(observer => {
                observer.disconnect()
            }), observers.splice(0, observers.length)
        })
    }]);
    var core = core_Swiper;

    function Autoplay({
        swiper: swiper,
        extendParams: extendParams,
        on: on,
        emit: emit
    }) {
        let timeout;

        function run() {
            const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
            let delay = swiper.params.autoplay.delay;
            $activeSlideEl.attr("data-swiper-autoplay") && (delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper.params.autoplay.delay), clearTimeout(timeout), timeout = nextTick(() => {
                let autoplayResult;
                swiper.params.autoplay.reverseDirection ? swiper.params.loop ? (swiper.loopFix(), autoplayResult = swiper.slidePrev(swiper.params.speed, !0, !0), emit("autoplay")) : swiper.isBeginning ? swiper.params.autoplay.stopOnLastSlide ? stop() : (autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, !0, !0), emit("autoplay")) : (autoplayResult = swiper.slidePrev(swiper.params.speed, !0, !0), emit("autoplay")) : swiper.params.loop ? (swiper.loopFix(), autoplayResult = swiper.slideNext(swiper.params.speed, !0, !0), emit("autoplay")) : swiper.isEnd ? swiper.params.autoplay.stopOnLastSlide ? stop() : (autoplayResult = swiper.slideTo(0, swiper.params.speed, !0, !0), emit("autoplay")) : (autoplayResult = swiper.slideNext(swiper.params.speed, !0, !0), emit("autoplay")), (swiper.params.cssMode && swiper.autoplay.running || !1 === autoplayResult) && run()
            }, delay)
        }

        function start() {
            return void 0 === timeout && (!swiper.autoplay.running && (swiper.autoplay.running = !0, emit("autoplayStart"), run(), !0))
        }

        function stop() {
            return !!swiper.autoplay.running && (void 0 !== timeout && (timeout && (clearTimeout(timeout), timeout = void 0), swiper.autoplay.running = !1, emit("autoplayStop"), !0))
        }

        function pause(speed) {
            swiper.autoplay.running && (swiper.autoplay.paused || (timeout && clearTimeout(timeout), swiper.autoplay.paused = !0, 0 !== speed && swiper.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach(event => {
                swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd)
            }) : (swiper.autoplay.paused = !1, run())))
        }

        function onVisibilityChange() {
            const document = ssr_window_esm_getDocument();
            "hidden" === document.visibilityState && swiper.autoplay.running && pause(), "visible" === document.visibilityState && swiper.autoplay.paused && (run(), swiper.autoplay.paused = !1)
        }

        function onTransitionEnd(e) {
            swiper && !swiper.destroyed && swiper.$wrapperEl && e.target === swiper.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach(event => {
                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd)
            }), swiper.autoplay.paused = !1, swiper.autoplay.running ? run() : stop())
        }

        function onMouseEnter() {
            swiper.params.autoplay.disableOnInteraction ? stop() : pause(), ["transitionend", "webkitTransitionEnd"].forEach(event => {
                swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd)
            })
        }

        function onMouseLeave() {
            swiper.params.autoplay.disableOnInteraction || (swiper.autoplay.paused = !1, run())
        }
        swiper.autoplay = {
            running: !1,
            paused: !1
        }, extendParams({
            autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1
            }
        }), on("init", () => {
            if (swiper.params.autoplay.enabled) {
                start();
                ssr_window_esm_getDocument().addEventListener("visibilitychange", onVisibilityChange), swiper.params.autoplay.pauseOnMouseEnter && (swiper.$el.on("mouseenter", onMouseEnter), swiper.$el.on("mouseleave", onMouseLeave))
            }
        }), on("beforeTransitionStart", (_s, speed, internal) => {
            swiper.autoplay.running && (internal || !swiper.params.autoplay.disableOnInteraction ? swiper.autoplay.pause(speed) : stop())
        }), on("sliderFirstMove", () => {
            swiper.autoplay.running && (swiper.params.autoplay.disableOnInteraction ? stop() : pause())
        }), on("touchEnd", () => {
            swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction && run()
        }), on("destroy", () => {
            swiper.$el.off("mouseenter", onMouseEnter), swiper.$el.off("mouseleave", onMouseLeave), swiper.autoplay.running && stop();
            ssr_window_esm_getDocument().removeEventListener("visibilitychange", onVisibilityChange)
        }), Object.assign(swiper.autoplay, {
            pause: pause,
            run: run,
            start: start,
            stop: stop
        })
    }

    function createElement(className, tagName, appendToEl) {
        const el = document.createElement(tagName || "div");
        return className && (el.className = className), appendToEl && appendToEl.appendChild(el), el
    }

    function setWidthHeight(el, w, h) {
        el.style.width = "number" == typeof w ? w + "px" : w, el.style.height = "number" == typeof h ? h + "px" : h
    }
    new core(".slider--customer", {
        modules: [Autoplay],
        slidesPerView: 2.6,
        spaceBetween: 35,
        speed: 800,
        centerInsufficientSlides: !0,
        autoplay: {
            delay: 3e3,
            pauseOnMouseEnter: !0
        },
        breakpoints: {
            768: {
                slidesPerView: 3,
                spaceBetween: 0
            },
            992: {
                slidesPerView: 4,
                spaceBetween: 0
            },
            1200: {
                slidesPerView: 5,
                spaceBetween: 0
            }
        }
    }), new core(".slider--blockchains", {
        modules: [Autoplay],
        slidesPerView: 2.6,
        spaceBetween: 35,
        speed: 800,
        centerInsufficientSlides: !0,
        autoplay: {
            delay: 3e3,
            pauseOnMouseEnter: !0
        },
        breakpoints: {
            768: {
                slidesPerView: 3,
                spaceBetween: 0
            },
            992: {
                slidesPerView: 4,
                spaceBetween: 0
            },
            1200: {
                slidesPerView: 5,
                spaceBetween: 0
            }
        }
    }), new core(".slider--partners", {
        modules: [Autoplay],
        slidesPerView: 2.6,
        spaceBetween: 35,
        speed: 800,
        centerInsufficientSlides: !0,
        autoplay: {
            delay: 3e3,
            pauseOnMouseEnter: !0
        },
        breakpoints: {
            768: {
                slidesPerView: 3,
                spaceBetween: 0
            },
            992: {
                slidesPerView: 4,
                spaceBetween: 0
            },
            1200: {
                slidesPerView: 5,
                spaceBetween: 0
            }
        }
    });
    const LOAD_STATE_IDLE = "idle",
        LOAD_STATE_LOADING = "loading",
        LOAD_STATE_LOADED = "loaded",
        LOAD_STATE_ERROR = "error";

    function getElementsFromOption(option, legacySelector, parent = document) {
        let elements = [];
        if (option instanceof Element) elements = [option];
        else if (option instanceof NodeList || Array.isArray(option)) elements = Array.from(option);
        else {
            const selector = "string" == typeof option ? option : legacySelector;
            selector && (elements = Array.from(parent.querySelectorAll(selector)))
        }
        return elements
    }

    function dynamicImportModule(module) {
        return "string" == typeof module ? import(module) : module
    }
    class PhotoSwipeEvent {
        constructor(type, details) {
            this.type = type, details && Object.assign(this, details)
        }
        preventDefault() {
            this.defaultPrevented = !0
        }
    }
    class Content {
        constructor(itemData, instance) {
            this.options = instance.options, this.instance = instance, this.data = itemData, this.width = Number(this.data.w) || Number(this.data.width) || 0, this.height = Number(this.data.h) || Number(this.data.height) || 0, this.isAttached = !1, this.state = LOAD_STATE_IDLE
        }
        setSlide(slide) {
            this.slide = slide, this.pswp = slide.pswp
        }
        load() {
            this.element || (this.element = createElement("pswp__content"), this.element.style.position = "absolute", this.element.style.left = 0, this.element.style.top = 0, this.element.innerHTML = this.data.html || "")
        }
        isZoomable() {
            return !1
        }
        usePlaceholder() {
            return !1
        }
        activate() { }
        deactivate() { }
        setDisplayedSize(width, height) {
            this.element && setWidthHeight(this.element, width, height)
        }
        onLoaded() {
            this.state = LOAD_STATE_LOADED, this.slide && this.pswp.dispatch("loadComplete", {
                slide: this.slide
            })
        }
        keepPlaceholder() {
            return this.state === LOAD_STATE_LOADING
        }
        onError() {
            this.state = LOAD_STATE_ERROR, this.slide && (this.pswp.dispatch("loadComplete", {
                slide: this.slide,
                isError: !0
            }), this.pswp.dispatch("loadError", {
                slide: this.slide
            }))
        }
        getErrorElement() {
            return !1
        }
        remove() {
            this.isAttached = !1, this.element && this.element.parentNode && this.element.remove()
        }
        appendTo(container) {
            this.isAttached = !0, this.element && !this.element.parentNode && container.appendChild(this.element)
        }
        destroy() { }
    }
    class ImageContent extends Content {
        load() {
            if (this.element) return;
            const imageSrc = this.data.src;
            imageSrc && (this.element = createElement("pswp__img", "img"), this.data.srcset && (this.element.srcset = this.data.srcset), this.element.src = imageSrc, this.element.alt = this.data.alt || "", this.state = LOAD_STATE_LOADING, this.element.complete ? this.onLoaded() : (this.element.onload = () => {
                this.onLoaded()
            }, this.element.onerror = () => {
                this.onError()
            }))
        }
        setDisplayedSize(width, height) {
            const image = this.element;
            image && (setWidthHeight(image, width, "auto"), image.srcset && (!image.dataset.largestUsedSize || width > image.dataset.largestUsedSize) && (image.sizes = width + "px", image.dataset.largestUsedSize = width), this.slide && this.pswp.dispatch("imageSizeChange", {
                slide: this.slide,
                width: width,
                height: height
            }))
        }
        isZoomable() {
            return this.state !== LOAD_STATE_ERROR
        }
        usePlaceholder() {
            return !0
        }
        lazyLoad() {
            this.load()
        }
        destroy() {
            this.element && (this.element.onload = null, this.element.onerror = null, this.element = null)
        }
        appendTo(container) {
            this.isAttached = !0, this.slide && !this.slide.isActive && "decode" in this.element ? (this.isDecoding = !0, requestAnimationFrame(() => {
                this.element && this.element.decode().then(() => {
                    this.isDecoding = !1, requestAnimationFrame(() => {
                        this.appendImageTo(container)
                    })
                }).catch(() => { })
            })) : this.appendImageTo(container)
        }
        activate() {
            this.slide && this.slide.container && this.isDecoding && this.appendImageTo(this.slide.container)
        }
        getErrorElement() {
            const el = createElement("pswp__error-msg-container");
            el.innerHTML = this.options.errorMsg;
            const linkEl = el.querySelector("a");
            return linkEl && (linkEl.href = this.data.src), el
        }
        appendImageTo(container) {
            this.element && !this.element.parentNode && this.isAttached && container.appendChild(this.element)
        }
    }

    function parsePaddingOption(prop, options, viewportSize) {
        let paddingValue;
        if (options.paddingFn) paddingValue = options.paddingFn(viewportSize)[prop];
        else if (options.padding) paddingValue = options.padding[prop];
        else {
            const legacyPropName = "padding" + prop[0].toUpperCase() + prop.slice(1);
            options[legacyPropName] && (paddingValue = options[legacyPropName])
        }
        return paddingValue || 0
    }
    class ZoomLevel {
        constructor(options, itemData, index, pswp) {
            this.pswp = pswp, this.options = options, this.itemData = itemData, this.index = index
        }
        update(maxWidth, maxHeight, panAreaSize) {
            this.elementSize = {
                x: maxWidth,
                y: maxHeight
            }, this.panAreaSize = panAreaSize;
            const hRatio = this.panAreaSize.x / this.elementSize.x,
                vRatio = this.panAreaSize.y / this.elementSize.y;
            this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio), this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio), this.vFill = Math.min(1, vRatio), this.initial = this._getInitial(), this.secondary = this._getSecondary(), this.max = Math.max(this.initial, this.secondary, this._getMax()), this.min = Math.min(this.fit, this.initial, this.secondary), this.pswp && this.pswp.dispatch("zoomLevelsUpdate", {
                zoomLevels: this,
                slideData: this.itemData
            })
        }
        _parseZoomLevelOption(optionPrefix) {
            const optionValue = this.options[optionPrefix + "ZoomLevel"];
            if (optionValue) return "function" == typeof optionValue ? optionValue(this) : "fill" === optionValue ? this.fill : "fit" === optionValue ? this.fit : Number(optionValue)
        }
        _getSecondary() {
            let currZoomLevel = this._parseZoomLevelOption("secondary");
            return currZoomLevel || (currZoomLevel = Math.min(1, 3 * this.fit), currZoomLevel * this.elementSize.x > 4e3 && (currZoomLevel = 4e3 / this.elementSize.x), currZoomLevel)
        }
        _getInitial() {
            return this._parseZoomLevelOption("initial") || this.fit
        }
        _getMax() {
            const currZoomLevel = this._parseZoomLevelOption("max");
            return currZoomLevel || Math.max(1, 4 * this.fit)
        }
    }

    function lazyLoadData(itemData, instance, index) {
        const content = instance.createContentFromData(itemData);
        if (!content || !content.lazyLoad) return;
        content.key = function (itemData, index) {
            return itemData && itemData.src ? itemData.src + "_" + index : index
        }(itemData, index);
        const {
            options: options
        } = instance, viewportSize = instance.viewportSize || function (options, pswp) {
            if (options.getViewportSizeFn) {
                const newViewportSize = options.getViewportSizeFn(options, pswp);
                if (newViewportSize) return newViewportSize
            }
            return {
                x: document.documentElement.clientWidth,
                y: window.innerHeight
            }
        }(options), panAreaSize = function (options, viewportSize) {
            return {
                x: viewportSize.x - parsePaddingOption("left", options, viewportSize) - parsePaddingOption("right", options, viewportSize),
                y: viewportSize.y - parsePaddingOption("top", options, viewportSize) - parsePaddingOption("bottom", options, viewportSize)
            }
        }(options, viewportSize), zoomLevel = new ZoomLevel(options, itemData, -1);
        return zoomLevel.update(content.width, content.height, panAreaSize), content.lazyLoad(), content.setDisplayedSize(Math.ceil(content.width * zoomLevel.initial), Math.ceil(content.height * zoomLevel.initial)), content
    }

    function photoswipe_esm_createElement(className, tagName, appendToEl) {
        const el = document.createElement(tagName || "div");
        return className && (el.className = className), appendToEl && appendToEl.appendChild(el), el
    }

    function equalizePoints(p1, p2) {
        return p1.x = p2.x, p1.y = p2.y, void 0 !== p2.id && (p1.id = p2.id), p1
    }

    function roundPoint(p) {
        p.x = Math.round(p.x), p.y = Math.round(p.y)
    }

    function getDistanceBetween(p1, p2) {
        const x = Math.abs(p1.x - p2.x),
            y = Math.abs(p1.y - p2.y);
        return Math.sqrt(x * x + y * y)
    }

    function pointsEqual(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y
    }

    function clamp(val, min, max) {
        return Math.min(Math.max(val, min), max)
    }

    function toTransformString(x, y, scale) {
        let propValue = "translate3d(" + x + "px," + (y || 0) + "px,0)";
        return void 0 !== scale && (propValue += " scale3d(" + scale + "," + scale + ",1)"), propValue
    }

    function photoswipe_esm_setTransform(el, x, y, scale) {
        el.style.transform = toTransformString(x, y, scale)
    }

    function setTransitionStyle(el, prop, duration, ease) {
        el.style.transition = prop ? prop + " " + duration + "ms " + (ease || "cubic-bezier(.4,0,.22,1)") : "none"
    }

    function photoswipe_esm_setWidthHeight(el, w, h) {
        el.style.width = "number" == typeof w ? w + "px" : w, el.style.height = "number" == typeof h ? h + "px" : h
    }
    const photoswipe_esm_LOAD_STATE_IDLE = "idle",
        photoswipe_esm_LOAD_STATE_LOADING = "loading",
        photoswipe_esm_LOAD_STATE_LOADED = "loaded",
        photoswipe_esm_LOAD_STATE_ERROR = "error";
    let supportsPassive = !1;
    try {
        window.addEventListener("test", null, Object.defineProperty({}, "passive", {
            get: () => {
                supportsPassive = !0
            }
        }))
    } catch (e) { }
    class DOMEvents {
        constructor() {
            this._pool = []
        }
        add(target, type, listener, passive) {
            this._toggleListener(target, type, listener, passive)
        }
        remove(target, type, listener, passive) {
            this._toggleListener(target, type, listener, passive, !0)
        }
        removeAll() {
            this._pool.forEach(poolItem => {
                this._toggleListener(poolItem.target, poolItem.type, poolItem.listener, poolItem.passive, !0, !0)
            }), this._pool = []
        }
        _toggleListener(target, type, listener, passive, unbind, skipPool) {
            if (!target) return;
            const methodName = (unbind ? "remove" : "add") + "EventListener";
            (type = type.split(" ")).forEach(eType => {
                if (eType) {
                    skipPool || (unbind ? this._pool = this._pool.filter(poolItem => poolItem.type !== eType || poolItem.listener !== listener || poolItem.target !== target) : this._pool.push({
                        target: target,
                        type: eType,
                        listener: listener,
                        passive: passive
                    }));
                    const eventOptions = !!supportsPassive && {
                        passive: passive || !1
                    };
                    target[methodName](eType, listener, eventOptions)
                }
            })
        }
    }

    function photoswipe_esm_getViewportSize(options, pswp) {
        if (options.getViewportSizeFn) {
            const newViewportSize = options.getViewportSizeFn(options, pswp);
            if (newViewportSize) return newViewportSize
        }
        return {
            x: document.documentElement.clientWidth,
            y: window.innerHeight
        }
    }

    function photoswipe_esm_parsePaddingOption(prop, options, viewportSize) {
        let paddingValue;
        if (options.paddingFn) paddingValue = options.paddingFn(viewportSize)[prop];
        else if (options.padding) paddingValue = options.padding[prop];
        else {
            const legacyPropName = "padding" + prop[0].toUpperCase() + prop.slice(1);
            options[legacyPropName] && (paddingValue = options[legacyPropName])
        }
        return paddingValue || 0
    }

    function photoswipe_esm_getPanAreaSize(options, viewportSize) {
        return {
            x: viewportSize.x - photoswipe_esm_parsePaddingOption("left", options, viewportSize) - photoswipe_esm_parsePaddingOption("right", options, viewportSize),
            y: viewportSize.y - photoswipe_esm_parsePaddingOption("top", options, viewportSize) - photoswipe_esm_parsePaddingOption("bottom", options, viewportSize)
        }
    }
    class PanBounds {
        constructor(slide) {
            this.slide = slide, this.currZoomLevel = 1, this.center = {}, this.max = {}, this.min = {}, this.reset()
        }
        update(currZoomLevel) {
            this.currZoomLevel = currZoomLevel, this.slide.width ? (this._updateAxis("x"), this._updateAxis("y"), this.slide.pswp.dispatch("calcBounds", {
                slide: this.slide
            })) : this.reset()
        }
        _updateAxis(axis) {
            const {
                pswp: pswp
            } = this.slide, elSize = this.slide["x" === axis ? "width" : "height"] * this.currZoomLevel, padding = photoswipe_esm_parsePaddingOption("x" === axis ? "left" : "top", pswp.options, pswp.viewportSize), panAreaSize = this.slide.panAreaSize[axis];
            this.center[axis] = Math.round((panAreaSize - elSize) / 2) + padding, this.max[axis] = elSize > panAreaSize ? Math.round(panAreaSize - elSize) + padding : this.center[axis], this.min[axis] = elSize > panAreaSize ? padding : this.center[axis]
        }
        reset() {
            this.center.x = 0, this.center.y = 0, this.max.x = 0, this.max.y = 0, this.min.x = 0, this.min.y = 0
        }
        correctPan(axis, panOffset) {
            return clamp(panOffset, this.max[axis], this.min[axis])
        }
    }
    class photoswipe_esm_ZoomLevel {
        constructor(options, itemData, index, pswp) {
            this.pswp = pswp, this.options = options, this.itemData = itemData, this.index = index
        }
        update(maxWidth, maxHeight, panAreaSize) {
            this.elementSize = {
                x: maxWidth,
                y: maxHeight
            }, this.panAreaSize = panAreaSize;
            const hRatio = this.panAreaSize.x / this.elementSize.x,
                vRatio = this.panAreaSize.y / this.elementSize.y;
            this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio), this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio), this.vFill = Math.min(1, vRatio), this.initial = this._getInitial(), this.secondary = this._getSecondary(), this.max = Math.max(this.initial, this.secondary, this._getMax()), this.min = Math.min(this.fit, this.initial, this.secondary), this.pswp && this.pswp.dispatch("zoomLevelsUpdate", {
                zoomLevels: this,
                slideData: this.itemData
            })
        }
        _parseZoomLevelOption(optionPrefix) {
            const optionValue = this.options[optionPrefix + "ZoomLevel"];
            if (optionValue) return "function" == typeof optionValue ? optionValue(this) : "fill" === optionValue ? this.fill : "fit" === optionValue ? this.fit : Number(optionValue)
        }
        _getSecondary() {
            let currZoomLevel = this._parseZoomLevelOption("secondary");
            return currZoomLevel || (currZoomLevel = Math.min(1, 3 * this.fit), currZoomLevel * this.elementSize.x > 4e3 && (currZoomLevel = 4e3 / this.elementSize.x), currZoomLevel)
        }
        _getInitial() {
            return this._parseZoomLevelOption("initial") || this.fit
        }
        _getMax() {
            const currZoomLevel = this._parseZoomLevelOption("max");
            return currZoomLevel || Math.max(1, 4 * this.fit)
        }
    }
    class Placeholder {
        constructor(imageSrc, container) {
            this.element = photoswipe_esm_createElement("pswp__img pswp__img--placeholder", imageSrc ? "img" : "", container), imageSrc && (this.element.decoding = "async", this.element.alt = "", this.element.src = imageSrc, this.element.setAttribute("role", "presentation")), this.element.setAttribute("aria-hiden", "true")
        }
        setDisplayedSize(width, height) {
            this.element && ("IMG" === this.element.tagName ? (photoswipe_esm_setWidthHeight(this.element, 250, "auto"), this.element.style.transformOrigin = "0 0", this.element.style.transform = toTransformString(0, 0, width / 250)) : photoswipe_esm_setWidthHeight(this.element, width, height))
        }
        destroy() {
            this.element.parentNode && this.element.remove(), this.element = null
        }
    }
    class Slide {
        constructor(data, index, pswp) {
            this.data = data, this.index = index, this.pswp = pswp, this.isActive = index === pswp.currIndex, this.currentResolution = 0, this.panAreaSize = {}, this.isFirstSlide = this.isActive && !pswp.opener.isOpen, this.zoomLevels = new photoswipe_esm_ZoomLevel(pswp.options, data, index, pswp), this.pswp.dispatch("gettingData", {
                slide: this,
                data: this.data,
                index: index
            }), this.pan = {
                x: 0,
                y: 0
            }, this.content = this.pswp.contentLoader.getContentBySlide(this), this.currZoomLevel = 1, this.width = this.content.width, this.height = this.content.height, this.bounds = new PanBounds(this), this.prevDisplayedWidth = -1, this.prevDisplayedHeight = -1, this.pswp.dispatch("slideInit", {
                slide: this
            })
        }
        setIsActive(isActive) {
            isActive && !this.isActive ? this.activate() : !isActive && this.isActive && this.deactivate()
        }
        append(holderElement) {
            this.holderElement = holderElement, this.data ? (this.calculateSize(), this.container = photoswipe_esm_createElement("pswp__zoom-wrap"), this.container.transformOrigin = "0 0", this.load(), this.appendHeavy(), this.updateContentSize(), this.holderElement.innerHTML = "", this.holderElement.appendChild(this.container), this.zoomAndPanToInitial(), this.pswp.dispatch("firstZoomPan", {
                slide: this
            }), this.applyCurrentZoomPan(), this.pswp.dispatch("afterSetContent", {
                slide: this
            }), this.isActive && this.activate()) : this.holderElement.innerHTML = ""
        }
        removePlaceholder() {
            this.placeholder && this.content && !this.content.keepPlaceholder() && setTimeout(() => {
                this.placeholder && (this.placeholder.destroy(), this.placeholder = null)
            }, 500)
        }
        load() {
            if (this.usePlaceholder() && !this.placeholder) {
                const placeholderSrc = this.pswp.applyFilters("placeholderSrc", !(!this.data.msrc || !this.isFirstSlide) && this.data.msrc, this);
                this.placeholder = new Placeholder(placeholderSrc, this.container)
            }
            this.content.load(), this.pswp.dispatch("slideLoad", {
                slide: this
            })
        }
        appendHeavy() {
            const {
                pswp: pswp
            } = this;
            !this.heavyAppended && pswp.opener.isOpen && !pswp.mainScroll.isShifted() && (this.isActive, 1) && (this.pswp.dispatch("appendHeavy", {
                slide: this
            }).defaultPrevented || (this.heavyAppended = !0, this.content.state === photoswipe_esm_LOAD_STATE_ERROR ? this.displayError() : (this.content.appendTo(this.container), this.placeholder && this.content.state === photoswipe_esm_LOAD_STATE_LOADED && this.removePlaceholder()), this.pswp.dispatch("appendHeavyContent", {
                slide: this
            })))
        }
        setSlideHTML(html) {
            const {
                container: container
            } = this;
            html.tagName ? container.appendChild(html) : container.innerHTML = html
        }
        displayError() {
            const errorElement = this.content.getErrorElement();
            errorElement.style.position = "absolute", errorElement.style.left = 0, errorElement.style.top = 0, this.activeErrorElement = errorElement, this.setSlideHTML(errorElement), this.updateContentSize(!0)
        }
        activate() {
            this.isActive = !0, this.appendHeavy(), this.content.activate(), this.pswp.dispatch("slideActivate", {
                slide: this
            })
        }
        deactivate() {
            this.isActive = !1, this.content.deactivate(), this.currentResolution = 0, this.zoomAndPanToInitial(), this.applyCurrentZoomPan(), this.updateContentSize(), this.pswp.dispatch("slideDeactivate", {
                slide: this
            })
        }
        destroy() {
            this.content.remove(), this.pswp.dispatch("slideDestroy", {
                slide: this
            })
        }
        resize() {
            this.currZoomLevel !== this.zoomLevels.initial && this.isActive ? (this.calculateSize(), this.bounds.update(this.currZoomLevel), this.panTo(this.pan.x, this.pan.y)) : (this.calculateSize(), this.currentResolution = 0, this.zoomAndPanToInitial(), this.applyCurrentZoomPan(), this.updateContentSize())
        }
        updateContentSize(force) {
            const scaleMultiplier = this.currentResolution || this.zoomLevels.initial;
            if (!scaleMultiplier) return;
            const width = Math.round(this.width * scaleMultiplier) || this.pswp.viewportSize.x,
                height = Math.round(this.height * scaleMultiplier) || this.pswp.viewportSize.y;
            (this.sizeChanged(width, height) || force) && (this.placeholder && this.placeholder.setDisplayedSize(width, height), this.activeErrorElement && photoswipe_esm_setWidthHeight(this.activeErrorElement, width, height), this.content.setDisplayedSize(width, height))
        }
        sizeChanged(width, height) {
            return (width !== this.prevDisplayedWidth || height !== this.prevDisplayedHeight) && (this.prevDisplayedWidth = width, this.prevDisplayedHeight = height, !0)
        }
        getPlaceholderElement() {
            if (this.placeholder) return this.placeholder.element
        }
        zoomTo(destZoomLevel, centerPoint, transitionDuration, ignoreBounds) {
            const {
                pswp: pswp
            } = this;
            if (!this.isZoomable() || pswp.mainScroll.isShifted()) return;
            pswp.dispatch("beforeZoomTo", {
                destZoomLevel: destZoomLevel,
                centerPoint: centerPoint,
                transitionDuration: transitionDuration
            }), pswp.animations.stopAllPan();
            const prevZoomLevel = this.currZoomLevel;
            ignoreBounds || (destZoomLevel = clamp(destZoomLevel, this.zoomLevels.min, this.zoomLevels.max)), this.setZoomLevel(destZoomLevel), this.pan.x = this.calculateZoomToPanOffset("x", centerPoint, prevZoomLevel), this.pan.y = this.calculateZoomToPanOffset("y", centerPoint, prevZoomLevel), roundPoint(this.pan);
            const finishTransition = () => {
                this._setResolution(destZoomLevel), this.applyCurrentZoomPan()
            };
            transitionDuration ? pswp.animations.startTransition({
                isPan: !0,
                name: "zoomTo",
                target: this.container,
                transform: this.getCurrentTransform(),
                onComplete: finishTransition,
                duration: transitionDuration,
                easing: pswp.options.easing
            }) : finishTransition()
        }
        toggleZoom(centerPoint) {
            this.zoomTo(this.currZoomLevel === this.zoomLevels.initial ? this.zoomLevels.secondary : this.zoomLevels.initial, centerPoint, this.pswp.options.zoomAnimationDuration)
        }
        setZoomLevel(currZoomLevel) {
            this.currZoomLevel = currZoomLevel, this.bounds.update(this.currZoomLevel)
        }
        calculateZoomToPanOffset(axis, point, prevZoomLevel) {
            if (0 === this.bounds.max[axis] - this.bounds.min[axis]) return this.bounds.center[axis];
            point || (point = this.pswp.getViewportCenterPoint());
            const zoomFactor = this.currZoomLevel / prevZoomLevel;
            return this.bounds.correctPan(axis, (this.pan[axis] - point[axis]) * zoomFactor + point[axis])
        }
        panTo(panX, panY) {
            this.pan.x = this.bounds.correctPan("x", panX), this.pan.y = this.bounds.correctPan("y", panY), this.applyCurrentZoomPan()
        }
        isPannable() {
            return this.width && this.currZoomLevel > this.zoomLevels.fit
        }
        isZoomable() {
            return this.width && this.content.isZoomable()
        }
        usePlaceholder() {
            return this.content.usePlaceholder()
        }
        applyCurrentZoomPan() {
            this._applyZoomTransform(this.pan.x, this.pan.y, this.currZoomLevel), this === this.pswp.currSlide && this.pswp.dispatch("zoomPanUpdate", {
                slide: this
            })
        }
        zoomAndPanToInitial() {
            this.currZoomLevel = this.zoomLevels.initial, this.bounds.update(this.currZoomLevel), equalizePoints(this.pan, this.bounds.center), this.pswp.dispatch("initialZoomPan", {
                slide: this
            })
        }
        _applyZoomTransform(x, y, zoom) {
            zoom /= this.currentResolution || this.zoomLevels.initial, photoswipe_esm_setTransform(this.container, x, y, zoom)
        }
        calculateSize() {
            const {
                pswp: pswp
            } = this;
            equalizePoints(this.panAreaSize, photoswipe_esm_getPanAreaSize(pswp.options, pswp.viewportSize)), this.zoomLevels.update(this.width, this.height, this.panAreaSize), pswp.dispatch("calcSlideSize", {
                slide: this
            })
        }
        getCurrentTransform() {
            const scale = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);
            return toTransformString(this.pan.x, this.pan.y, scale)
        }
        _setResolution(newResolution) {
            newResolution !== this.currentResolution && (this.currentResolution = newResolution, this.updateContentSize(), this.pswp.dispatch("resolutionChanged"))
        }
    }
    class DragHandler {
        constructor(gestures) {
            this.gestures = gestures, this.pswp = gestures.pswp, this.startPan = {}
        }
        start() {
            equalizePoints(this.startPan, this.pswp.currSlide.pan), this.pswp.animations.stopAll()
        }
        change() {
            const {
                p1: p1,
                prevP1: prevP1,
                dragAxis: dragAxis,
                pswp: pswp
            } = this.gestures, {
                currSlide: currSlide
            } = pswp;
            if ("y" === dragAxis && pswp.options.closeOnVerticalDrag && currSlide.currZoomLevel <= currSlide.zoomLevels.fit && !this.gestures.isMultitouch) {
                const panY = currSlide.pan.y + (p1.y - prevP1.y);
                if (!pswp.dispatch("verticalDrag", {
                    panY: panY
                }).defaultPrevented) {
                    this._setPanWithFriction("y", panY, .6);
                    const bgOpacity = 1 - Math.abs(this._getVerticalDragRatio(currSlide.pan.y));
                    pswp.applyBgOpacity(bgOpacity), currSlide.applyCurrentZoomPan()
                }
            } else {
                this._panOrMoveMainScroll("x") || (this._panOrMoveMainScroll("y"), roundPoint(currSlide.pan), currSlide.applyCurrentZoomPan())
            }
        }
        end() {
            const {
                pswp: pswp,
                velocity: velocity
            } = this.gestures, {
                mainScroll: mainScroll
            } = pswp;
            let indexDiff = 0;
            if (pswp.animations.stopAll(), mainScroll.isShifted()) {
                const currentSlideVisibilityRatio = (mainScroll.x - mainScroll.getCurrSlideX()) / pswp.viewportSize.x;
                velocity.x < -.5 && currentSlideVisibilityRatio < 0 || velocity.x < .1 && currentSlideVisibilityRatio < -.5 ? (indexDiff = 1, velocity.x = Math.min(velocity.x, 0)) : (velocity.x > .5 && currentSlideVisibilityRatio > 0 || velocity.x > -.1 && currentSlideVisibilityRatio > .5) && (indexDiff = -1, velocity.x = Math.max(velocity.x, 0)), mainScroll.moveIndexBy(indexDiff, !0, velocity.x)
            }
            pswp.currSlide.currZoomLevel > pswp.currSlide.zoomLevels.max && this.pswp.options.limitMaxZoom || this.gestures.isMultitouch ? this.gestures.zoomLevels.correctZoomPan(!0) : (this._finishPanGestureForAxis("x"), this._finishPanGestureForAxis("y"))
        }
        _finishPanGestureForAxis(axis) {
            const {
                pswp: pswp
            } = this, {
                currSlide: currSlide
            } = pswp, {
                velocity: velocity
            } = this.gestures, {
                pan: pan,
                bounds: bounds
            } = currSlide, panPos = pan[axis], restoreBgOpacity = pswp.bgOpacity < 1 && "y" === axis, projectedPosition = panPos + function (initialVelocity, decelerationRate) {
                return initialVelocity * decelerationRate / (1 - decelerationRate)
            }(velocity[axis], .995);
            if (restoreBgOpacity) {
                const vDragRatio = this._getVerticalDragRatio(panPos),
                    projectedVDragRatio = this._getVerticalDragRatio(projectedPosition);
                if (vDragRatio < 0 && projectedVDragRatio < -.4 || vDragRatio > 0 && projectedVDragRatio > .4) return void pswp.close()
            }
            const correctedPanPosition = bounds.correctPan(axis, projectedPosition);
            if (panPos === correctedPanPosition) return;
            const dampingRatio = correctedPanPosition === projectedPosition ? 1 : .82,
                initialBgOpacity = pswp.bgOpacity,
                totalPanDist = correctedPanPosition - panPos;
            pswp.animations.startSpring({
                name: "panGesture" + axis,
                isPan: !0,
                start: panPos,
                end: correctedPanPosition,
                velocity: velocity[axis],
                dampingRatio: dampingRatio,
                onUpdate: pos => {
                    if (restoreBgOpacity && pswp.bgOpacity < 1) {
                        const animationProgressRatio = 1 - (correctedPanPosition - pos) / totalPanDist;
                        pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * animationProgressRatio, 0, 1))
                    }
                    pan[axis] = Math.floor(pos), currSlide.applyCurrentZoomPan()
                }
            })
        }
        _panOrMoveMainScroll(axis) {
            const {
                p1: p1,
                pswp: pswp,
                dragAxis: dragAxis,
                prevP1: prevP1,
                isMultitouch: isMultitouch
            } = this.gestures, {
                currSlide: currSlide,
                mainScroll: mainScroll
            } = pswp, delta = p1[axis] - prevP1[axis], newMainScrollX = mainScroll.x + delta;
            if (!delta) return;
            if ("x" === axis && !currSlide.isPannable() && !isMultitouch) return mainScroll.moveTo(newMainScrollX, !0), !0;
            const {
                bounds: bounds
            } = currSlide, newPan = currSlide.pan[axis] + delta;
            if (pswp.options.allowPanToNext && "x" === dragAxis && "x" === axis && !isMultitouch) {
                const currSlideMainScrollX = mainScroll.getCurrSlideX(),
                    mainScrollShiftDiff = mainScroll.x - currSlideMainScrollX,
                    isLeftToRight = delta > 0,
                    isRightToLeft = !isLeftToRight;
                if (newPan > bounds.min[axis] && isLeftToRight) {
                    if (bounds.min[axis] <= this.startPan[axis]) return mainScroll.moveTo(newMainScrollX, !0), !0;
                    this._setPanWithFriction(axis, newPan)
                } else if (newPan < bounds.max[axis] && isRightToLeft) {
                    if (this.startPan[axis] <= bounds.max[axis]) return mainScroll.moveTo(newMainScrollX, !0), !0;
                    this._setPanWithFriction(axis, newPan)
                } else if (0 !== mainScrollShiftDiff) {
                    if (mainScrollShiftDiff > 0) return mainScroll.moveTo(Math.max(newMainScrollX, currSlideMainScrollX), !0), !0;
                    if (mainScrollShiftDiff < 0) return mainScroll.moveTo(Math.min(newMainScrollX, currSlideMainScrollX), !0), !0
                } else this._setPanWithFriction(axis, newPan)
            } else "y" === axis && (mainScroll.isShifted() || bounds.min.y === bounds.max.y) || this._setPanWithFriction(axis, newPan)
        }
        _getVerticalDragRatio(panY) {
            return (panY - this.pswp.currSlide.bounds.center.y) / (this.pswp.viewportSize.y / 3)
        }
        _setPanWithFriction(axis, potentialPan, customFriction) {
            const {
                pan: pan,
                bounds: bounds
            } = this.pswp.currSlide;
            if (bounds.correctPan(axis, potentialPan) !== potentialPan || customFriction) {
                const delta = Math.round(potentialPan - pan[axis]);
                pan[axis] += delta * (customFriction || .35)
            } else pan[axis] = potentialPan
        }
    }

    function getZoomPointsCenter(p, p1, p2) {
        return p.x = (p1.x + p2.x) / 2, p.y = (p1.y + p2.y) / 2, p
    }
    class ZoomHandler {
        constructor(gestures) {
            this.gestures = gestures, this.pswp = this.gestures.pswp, this._startPan = {}, this._startZoomPoint = {}, this._zoomPoint = {}
        }
        start() {
            this._startZoomLevel = this.pswp.currSlide.currZoomLevel, equalizePoints(this._startPan, this.pswp.currSlide.pan), this.pswp.animations.stopAllPan(), this._wasOverFitZoomLevel = !1
        }
        change() {
            const {
                p1: p1,
                startP1: startP1,
                p2: p2,
                startP2: startP2,
                pswp: pswp
            } = this.gestures, {
                currSlide: currSlide
            } = pswp, minZoomLevel = currSlide.zoomLevels.min, maxZoomLevel = currSlide.zoomLevels.max;
            if (!currSlide.isZoomable() || pswp.mainScroll.isShifted()) return;
            getZoomPointsCenter(this._startZoomPoint, startP1, startP2), getZoomPointsCenter(this._zoomPoint, p1, p2);
            let currZoomLevel = 1 / getDistanceBetween(startP1, startP2) * getDistanceBetween(p1, p2) * this._startZoomLevel;
            if (currZoomLevel > currSlide.zoomLevels.initial + currSlide.zoomLevels.initial / 15 && (this._wasOverFitZoomLevel = !0), currZoomLevel < minZoomLevel)
                if (pswp.options.pinchToClose && !this._wasOverFitZoomLevel && this._startZoomLevel <= currSlide.zoomLevels.initial) {
                    const bgOpacity = 1 - (minZoomLevel - currZoomLevel) / (minZoomLevel / 1.2);
                    pswp.dispatch("pinchClose", {
                        bgOpacity: bgOpacity
                    }).defaultPrevented || pswp.applyBgOpacity(bgOpacity)
                } else currZoomLevel = minZoomLevel - .15 * (minZoomLevel - currZoomLevel);
            else currZoomLevel > maxZoomLevel && (currZoomLevel = maxZoomLevel + .05 * (currZoomLevel - maxZoomLevel));
            currSlide.pan.x = this._calculatePanForZoomLevel("x", currZoomLevel), currSlide.pan.y = this._calculatePanForZoomLevel("y", currZoomLevel), currSlide.setZoomLevel(currZoomLevel), currSlide.applyCurrentZoomPan()
        }
        end() {
            const {
                pswp: pswp
            } = this, {
                currSlide: currSlide
            } = pswp;
            currSlide.currZoomLevel < currSlide.zoomLevels.initial && !this._wasOverFitZoomLevel && pswp.options.pinchToClose ? pswp.close() : this.correctZoomPan()
        }
        _calculatePanForZoomLevel(axis, currZoomLevel) {
            const zoomFactor = currZoomLevel / this._startZoomLevel;
            return this._zoomPoint[axis] - (this._startZoomPoint[axis] - this._startPan[axis]) * zoomFactor
        }
        correctZoomPan(ignoreGesture) {
            const {
                pswp: pswp
            } = this, {
                currSlide: currSlide
            } = pswp;
            if (!currSlide.isZoomable()) return;
            void 0 === this._zoomPoint.x && (ignoreGesture = !0);
            const prevZoomLevel = currSlide.currZoomLevel;
            let destinationZoomLevel, currZoomLevelNeedsChange = !0;
            prevZoomLevel < currSlide.zoomLevels.initial ? destinationZoomLevel = currSlide.zoomLevels.initial : prevZoomLevel > currSlide.zoomLevels.max ? destinationZoomLevel = currSlide.zoomLevels.max : (currZoomLevelNeedsChange = !1, destinationZoomLevel = prevZoomLevel);
            const initialBgOpacity = pswp.bgOpacity,
                restoreBgOpacity = pswp.bgOpacity < 1,
                initialPan = equalizePoints({}, currSlide.pan);
            let destinationPan = equalizePoints({}, initialPan);
            ignoreGesture && (this._zoomPoint.x = 0, this._zoomPoint.y = 0, this._startZoomPoint.x = 0, this._startZoomPoint.y = 0, this._startZoomLevel = prevZoomLevel, equalizePoints(this._startPan, initialPan)), currZoomLevelNeedsChange && (destinationPan = {
                x: this._calculatePanForZoomLevel("x", destinationZoomLevel),
                y: this._calculatePanForZoomLevel("y", destinationZoomLevel)
            }), currSlide.setZoomLevel(destinationZoomLevel), destinationPan = {
                x: currSlide.bounds.correctPan("x", destinationPan.x),
                y: currSlide.bounds.correctPan("y", destinationPan.y)
            }, currSlide.setZoomLevel(prevZoomLevel);
            let panNeedsChange = !0;
            if (pointsEqual(destinationPan, initialPan) && (panNeedsChange = !1), !panNeedsChange && !currZoomLevelNeedsChange && !restoreBgOpacity) return currSlide._setResolution(destinationZoomLevel), void currSlide.applyCurrentZoomPan();
            pswp.animations.stopAllPan(), pswp.animations.startSpring({
                isPan: !0,
                start: 0,
                end: 1e3,
                velocity: 0,
                dampingRatio: 1,
                naturalFrequency: 40,
                onUpdate: now => {
                    if (now /= 1e3, panNeedsChange || currZoomLevelNeedsChange) {
                        if (panNeedsChange && (currSlide.pan.x = initialPan.x + (destinationPan.x - initialPan.x) * now, currSlide.pan.y = initialPan.y + (destinationPan.y - initialPan.y) * now), currZoomLevelNeedsChange) {
                            const newZoomLevel = prevZoomLevel + (destinationZoomLevel - prevZoomLevel) * now;
                            currSlide.setZoomLevel(newZoomLevel)
                        }
                        currSlide.applyCurrentZoomPan()
                    }
                    restoreBgOpacity && pswp.bgOpacity < 1 && pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * now, 0, 1))
                },
                onComplete: () => {
                    currSlide._setResolution(destinationZoomLevel), currSlide.applyCurrentZoomPan()
                }
            })
        }
    }

    function didTapOnMainContent(event) {
        return !!event.target.closest(".pswp__container")
    }
    class TapHandler {
        constructor(gestures) {
            this.gestures = gestures
        }
        click(point, originalEvent) {
            const targetClassList = originalEvent.target.classList,
                isImageClick = targetClassList.contains("pswp__img"),
                isBackgroundClick = targetClassList.contains("pswp__item") || targetClassList.contains("pswp__zoom-wrap");
            isImageClick ? this._doClickOrTapAction("imageClick", point, originalEvent) : isBackgroundClick && this._doClickOrTapAction("bgClick", point, originalEvent)
        }
        tap(point, originalEvent) {
            didTapOnMainContent(originalEvent) && this._doClickOrTapAction("tap", point, originalEvent)
        }
        doubleTap(point, originalEvent) {
            didTapOnMainContent(originalEvent) && this._doClickOrTapAction("doubleTap", point, originalEvent)
        }
        _doClickOrTapAction(actionName, point, originalEvent) {
            const {
                pswp: pswp
            } = this.gestures, {
                currSlide: currSlide
            } = pswp, optionValue = pswp.options[actionName + "Action"];
            if (!pswp.dispatch(actionName + "Action", {
                point: point,
                originalEvent: originalEvent
            }).defaultPrevented)
                if ("function" != typeof optionValue) switch (optionValue) {
                    case "close":
                    case "next":
                        pswp[optionValue]();
                        break;
                    case "zoom":
                        currSlide.toggleZoom(point);
                        break;
                    case "zoom-or-close":
                        currSlide.isZoomable() && currSlide.zoomLevels.secondary !== currSlide.zoomLevels.initial ? currSlide.toggleZoom(point) : pswp.options.clickToCloseNonZoomable && pswp.close();
                        break;
                    case "toggle-controls":
                        this.gestures.pswp.template.classList.toggle("pswp--ui-visible")
                } else optionValue.call(pswp, point, originalEvent)
        }
    }
    class Gestures {
        constructor(pswp) {
            this.pswp = pswp, this.p1 = {}, this.p2 = {}, this.prevP1 = {}, this.prevP2 = {}, this.startP1 = {}, this.startP2 = {}, this.velocity = {}, this._lastStartP1 = {}, this._intervalP1 = {}, this._numActivePoints = 0, this._ongoingPointers = [], this._touchEventEnabled = "ontouchstart" in window, this._pointerEventEnabled = !!window.PointerEvent, this.supportsTouch = this._touchEventEnabled || this._pointerEventEnabled && navigator.maxTouchPoints > 1, this.supportsTouch || (pswp.options.allowPanToNext = !1), this.drag = new DragHandler(this), this.zoomLevels = new ZoomHandler(this), this.tapHandler = new TapHandler(this), pswp.on("bindEvents", () => {
                pswp.events.add(pswp.scrollWrap, "click", e => this._onClick(e)), this._pointerEventEnabled ? this._bindEvents("pointer", "down", "up", "cancel") : this._touchEventEnabled ? (this._bindEvents("touch", "start", "end", "cancel"), pswp.scrollWrap.ontouchmove = () => { }, pswp.scrollWrap.ontouchend = () => { }) : this._bindEvents("mouse", "down", "up")
            })
        }
        _bindEvents(pref, down, up, cancel) {
            const {
                pswp: pswp
            } = this, {
                events: events
            } = pswp, cancelEvent = cancel ? pref + cancel : "";
            events.add(pswp.scrollWrap, pref + down, this.onPointerDown.bind(this)), events.add(window, pref + "move", this.onPointerMove.bind(this)), events.add(window, pref + up, this.onPointerUp.bind(this)), cancelEvent && events.add(pswp.scrollWrap, cancelEvent, this.onPointerUp.bind(this))
        }
        onPointerDown(e) {
            let isMousePointer;
            if ("mousedown" !== e.type && "mouse" !== e.pointerType || (isMousePointer = !0), isMousePointer && e.button > 0) return;
            const {
                pswp: pswp
            } = this;
            pswp.opener.isOpen ? pswp.dispatch("pointerDown", {
                originalEvent: e
            }).defaultPrevented || (isMousePointer && (pswp.mouseDetected(), this._preventPointerEventBehaviour(e)), pswp.animations.stopAll(), this._updatePoints(e, "down"), this.pointerDown = !0, 1 === this._numActivePoints && (this.dragAxis = null, equalizePoints(this.startP1, this.p1)), this._numActivePoints > 1 ? (this._clearTapTimer(), this.isMultitouch = !0) : this.isMultitouch = !1) : e.preventDefault()
        }
        onPointerMove(e) {
            e.preventDefault(), this._numActivePoints && (this._updatePoints(e, "move"), this.pswp.dispatch("pointerMove", {
                originalEvent: e
            }).defaultPrevented || (1 !== this._numActivePoints || this.isDragging ? this._numActivePoints > 1 && !this.isZooming && (this._finishDrag(), this.isZooming = !0, this._updateStartPoints(), this.zoomLevels.start(), this._rafStopLoop(), this._rafRenderLoop()) : (this.dragAxis || this._calculateDragDirection(), this.dragAxis && !this.isDragging && (this.isZooming && (this.isZooming = !1, this.zoomLevels.end()), this.isDragging = !0, this._clearTapTimer(), this._updateStartPoints(), this._intervalTime = Date.now(), this._velocityCalculated = !1, equalizePoints(this._intervalP1, this.p1), this.velocity.x = 0, this.velocity.y = 0, this.drag.start(), this._rafStopLoop(), this._rafRenderLoop()))))
        }
        _finishDrag() {
            this.isDragging && (this.isDragging = !1, this._velocityCalculated || this._updateVelocity(!0), this.drag.end(), this.dragAxis = null)
        }
        onPointerUp(e) {
            this._numActivePoints && (this._updatePoints(e, "up"), this.pswp.dispatch("pointerUp", {
                originalEvent: e
            }).defaultPrevented || (0 === this._numActivePoints && (this.pointerDown = !1, this._rafStopLoop(), this.isDragging ? this._finishDrag() : this.isZooming || this.isMultitouch || this._finishTap(e)), this._numActivePoints < 2 && this.isZooming && (this.isZooming = !1, this.zoomLevels.end(), 1 === this._numActivePoints && (this.dragAxis = null, this._updateStartPoints()))))
        }
        _rafRenderLoop() {
            (this.isDragging || this.isZooming) && (this._updateVelocity(), this.isDragging ? pointsEqual(this.p1, this.prevP1) || this.drag.change() : pointsEqual(this.p1, this.prevP1) && pointsEqual(this.p2, this.prevP2) || this.zoomLevels.change(), this._updatePrevPoints(), this.raf = requestAnimationFrame(this._rafRenderLoop.bind(this)))
        }
        _updateVelocity(force) {
            const time = Date.now(),
                duration = time - this._intervalTime;
            duration < 50 && !force || (this.velocity.x = this._getVelocity("x", duration), this.velocity.y = this._getVelocity("y", duration), this._intervalTime = time, equalizePoints(this._intervalP1, this.p1), this._velocityCalculated = !0)
        }
        _finishTap(e) {
            const {
                mainScroll: mainScroll
            } = this.pswp;
            if (mainScroll.isShifted()) return void mainScroll.moveIndexBy(0, !0);
            if (e.type.indexOf("cancel") > 0) return;
            if ("mouseup" === e.type || "mouse" === e.pointerType) return void this.tapHandler.click(this.startP1, e);
            const tapDelay = this.pswp.options.doubleTapAction ? 300 : 0;
            this._tapTimer ? (this._clearTapTimer(), getDistanceBetween(this._lastStartP1, this.startP1) < 25 && this.tapHandler.doubleTap(this.startP1, e)) : (equalizePoints(this._lastStartP1, this.startP1), this._tapTimer = setTimeout(() => {
                this.tapHandler.tap(this.startP1, e), this._clearTapTimer()
            }, tapDelay))
        }
        _clearTapTimer() {
            this._tapTimer && (clearTimeout(this._tapTimer), this._tapTimer = null)
        }
        _getVelocity(axis, duration) {
            const displacement = this.p1[axis] - this._intervalP1[axis];
            return Math.abs(displacement) > 1 && duration > 5 ? displacement / duration : 0
        }
        _rafStopLoop() {
            this.raf && (cancelAnimationFrame(this.raf), this.raf = null)
        }
        _preventPointerEventBehaviour(e) {
            return e.preventDefault(), !0
        }
        _updatePoints(e, pointerType) {
            if (this._pointerEventEnabled) {
                const pointerIndex = this._ongoingPointers.findIndex(ongoingPoiner => ongoingPoiner.id === e.pointerId);
                "up" === pointerType && pointerIndex > -1 ? this._ongoingPointers.splice(pointerIndex, 1) : "down" === pointerType && -1 === pointerIndex ? this._ongoingPointers.push(this._convertEventPosToPoint(e, {})) : pointerIndex > -1 && this._convertEventPosToPoint(e, this._ongoingPointers[pointerIndex]), this._numActivePoints = this._ongoingPointers.length, this._numActivePoints > 0 && equalizePoints(this.p1, this._ongoingPointers[0]), this._numActivePoints > 1 && equalizePoints(this.p2, this._ongoingPointers[1])
            } else this._numActivePoints = 0, e.type.indexOf("touch") > -1 ? e.touches && e.touches.length > 0 && (this._convertEventPosToPoint(e.touches[0], this.p1), this._numActivePoints++, e.touches.length > 1 && (this._convertEventPosToPoint(e.touches[1], this.p2), this._numActivePoints++)) : (this._convertEventPosToPoint(e, this.p1), "up" === pointerType ? this._numActivePoints = 0 : this._numActivePoints++)
        }
        _updatePrevPoints() {
            equalizePoints(this.prevP1, this.p1), equalizePoints(this.prevP2, this.p2)
        }
        _updateStartPoints() {
            equalizePoints(this.startP1, this.p1), equalizePoints(this.startP2, this.p2), this._updatePrevPoints()
        }
        _calculateDragDirection() {
            if (this.pswp.mainScroll.isShifted()) this.dragAxis = "x";
            else {
                const diff = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y);
                if (0 !== diff) {
                    const axisToCheck = diff > 0 ? "x" : "y";
                    Math.abs(this.p1[axisToCheck] - this.startP1[axisToCheck]) >= 10 && (this.dragAxis = axisToCheck)
                }
            }
        }
        _convertEventPosToPoint(e, p) {
            return p.x = e.pageX - this.pswp.offset.x, p.y = e.pageY - this.pswp.offset.y, void 0 !== e.pointerId ? p.id = e.pointerId : void 0 !== e.identifier && (p.id = e.identifier), p
        }
        _onClick(e) {
            this.pswp.mainScroll.isShifted() && (e.preventDefault(), e.stopPropagation())
        }
    }
    class MainScroll {
        constructor(pswp) {
            this.pswp = pswp, this.x = 0, this.resetPosition()
        }
        resize(resizeSlides) {
            const {
                pswp: pswp
            } = this, newSlideWidth = Math.round(pswp.viewportSize.x + pswp.viewportSize.x * pswp.options.spacing), slideWidthChanged = newSlideWidth !== this.slideWidth;
            slideWidthChanged && (this.slideWidth = newSlideWidth, this.moveTo(this.getCurrSlideX())), this.itemHolders.forEach((itemHolder, index) => {
                slideWidthChanged && photoswipe_esm_setTransform(itemHolder.el, (index + this._containerShiftIndex) * this.slideWidth), resizeSlides && itemHolder.slide && itemHolder.slide.resize()
            })
        }
        resetPosition() {
            this._currPositionIndex = 0, this._prevPositionIndex = 0, this.slideWidth = 0, this._containerShiftIndex = -1
        }
        appendHolders() {
            this.itemHolders = [];
            for (let i = 0; i < 3; i++) {
                const el = photoswipe_esm_createElement("pswp__item", !1, this.pswp.container);
                el.style.display = 1 === i ? "block" : "none", this.itemHolders.push({
                    el: el
                })
            }
        }
        canBeSwiped() {
            return this.pswp.getNumItems() > 1
        }
        moveIndexBy(diff, animate, velocityX) {
            const {
                pswp: pswp
            } = this;
            let newIndex = pswp.potentialIndex + diff;
            pswp.options.loop ? newIndex = pswp.getLoopedIndex(newIndex) : (newIndex < 0 ? newIndex = 0 : newIndex >= pswp.getNumItems() && (newIndex = pswp.getNumItems() - 1), diff = newIndex - pswp.potentialIndex), pswp.potentialIndex = newIndex, this._currPositionIndex -= diff, pswp.animations.stopMainScroll();
            const destinationX = this.getCurrSlideX();
            if (animate ? (pswp.animations.startSpring({
                isMainScroll: !0,
                start: this.x,
                end: destinationX,
                velocity: velocityX || 0,
                naturalFrequency: 30,
                dampingRatio: 1,
                onUpdate: x => {
                    this.moveTo(x)
                },
                onComplete: () => {
                    this.updateCurrItem(), pswp.appendHeavy()
                }
            }), Math.abs(pswp.potentialIndex - pswp.currIndex) > 1 && this.updateCurrItem()) : (this.moveTo(destinationX), this.updateCurrItem()), diff) return !0
        }
        getCurrSlideX() {
            return this.slideWidth * this._currPositionIndex
        }
        isShifted() {
            return this.x !== this.getCurrSlideX()
        }
        updateCurrItem() {
            const {
                pswp: pswp
            } = this, positionDifference = this._prevPositionIndex - this._currPositionIndex;
            if (!positionDifference) return;
            this._prevPositionIndex = this._currPositionIndex, pswp.currIndex = pswp.potentialIndex;
            let tempHolder, diffAbs = Math.abs(positionDifference);
            diffAbs >= 3 && (this._containerShiftIndex += positionDifference + (positionDifference > 0 ? -3 : 3), diffAbs = 3);
            for (let i = 0; i < diffAbs; i++) positionDifference > 0 ? (tempHolder = this.itemHolders.shift(), this.itemHolders[2] = tempHolder, this._containerShiftIndex++, photoswipe_esm_setTransform(tempHolder.el, (this._containerShiftIndex + 2) * this.slideWidth), pswp.setContent(tempHolder, pswp.currIndex - diffAbs + i + 2)) : (tempHolder = this.itemHolders.pop(), this.itemHolders.unshift(tempHolder), this._containerShiftIndex--, photoswipe_esm_setTransform(tempHolder.el, this._containerShiftIndex * this.slideWidth), pswp.setContent(tempHolder, pswp.currIndex + diffAbs - i - 2));
            Math.abs(this._containerShiftIndex) > 50 && !this.isShifted() && (this.resetPosition(), this.resize()), pswp.animations.stopAllPan(), this.itemHolders.forEach((itemHolder, i) => {
                itemHolder.slide && itemHolder.slide.setIsActive(1 === i)
            }), pswp.currSlide = this.itemHolders[1].slide, pswp.contentLoader.updateLazy(positionDifference), pswp.currSlide.applyCurrentZoomPan(), pswp.dispatch("change")
        }
        moveTo(x, dragging) {
            let newSlideIndexOffset, delta;
            !this.pswp.options.loop && dragging && (newSlideIndexOffset = (this.slideWidth * this._currPositionIndex - x) / this.slideWidth, newSlideIndexOffset += this.pswp.currIndex, delta = Math.round(x - this.x), (newSlideIndexOffset < 0 && delta > 0 || newSlideIndexOffset >= this.pswp.getNumItems() - 1 && delta < 0) && (x = this.x + .35 * delta)), this.x = x, photoswipe_esm_setTransform(this.pswp.container, x), this.pswp.dispatch("moveMainScroll", {
                x: x,
                dragging: dragging
            })
        }
    }
    class photoswipe_esm_Keyboard {
        constructor(pswp) {
            this.pswp = pswp, pswp.on("bindEvents", () => {
                pswp.options.initialPointerPos || this._focusRoot(), pswp.events.add(document, "focusin", this._onFocusIn.bind(this)), pswp.events.add(document, "keydown", this._onKeyDown.bind(this))
            });
            const lastActiveElement = document.activeElement;
            pswp.on("destroy", () => {
                pswp.options.returnFocus && lastActiveElement && this._wasFocused && lastActiveElement.focus()
            })
        }
        _focusRoot() {
            this._wasFocused || (this.pswp.template.focus(), this._wasFocused = !0)
        }
        _onKeyDown(e) {
            const {
                pswp: pswp
            } = this;
            if (pswp.dispatch("keydown", {
                originalEvent: e
            }).defaultPrevented) return;
            if (function (e) {
                if (2 === e.which || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) return !0
            }(e)) return;
            let keydownAction, axis, isForward;
            switch (e.keyCode) {
                case 27:
                    pswp.options.escKey && (keydownAction = "close");
                    break;
                case 90:
                    keydownAction = "toggleZoom";
                    break;
                case 37:
                    axis = "x";
                    break;
                case 38:
                    axis = "y";
                    break;
                case 39:
                    axis = "x", isForward = !0;
                    break;
                case 40:
                    isForward = !0, axis = "y";
                    break;
                case 9:
                    this._focusRoot()
            }
            if (axis) {
                e.preventDefault();
                const {
                    currSlide: currSlide
                } = pswp;
                pswp.options.arrowKeys && "x" === axis && pswp.getNumItems() > 1 ? keydownAction = isForward ? "next" : "prev" : currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.fit && (currSlide.pan[axis] += isForward ? -80 : 80, currSlide.panTo(currSlide.pan.x, currSlide.pan.y))
            }
            keydownAction && (e.preventDefault(), pswp[keydownAction]())
        }
        _onFocusIn(e) {
            const {
                template: template
            } = this.pswp;
            document === e.target || template === e.target || template.contains(e.target) || template.focus()
        }
    }
    class CSSAnimation {
        constructor(props) {
            this.props = props;
            const {
                target: target,
                onComplete: onComplete,
                transform: transform
            } = props;
            let {
                duration: duration,
                easing: easing
            } = props;
            const prop = transform ? "transform" : "opacity",
                propValue = props[prop];
            this._target = target, this._onComplete = onComplete, duration = duration || 333, easing = easing || "cubic-bezier(.4,0,.22,1)", this._onTransitionEnd = this._onTransitionEnd.bind(this), this._firstFrameTimeout = setTimeout(() => {
                setTransitionStyle(target, prop, duration, easing), this._firstFrameTimeout = setTimeout(() => {
                    target.addEventListener("transitionend", this._onTransitionEnd, !1), target.addEventListener("transitioncancel", this._onTransitionEnd, !1), target.style[prop] = propValue
                }, 30)
            }, 0)
        }
        _onTransitionEnd(e) {
            e.target === this._target && this._finalizeAnimation()
        }
        _finalizeAnimation() {
            this._finished || (this._finished = !0, this.onFinish(), this._onComplete && this._onComplete())
        }
        destroy() {
            this._firstFrameTimeout && clearTimeout(this._firstFrameTimeout), setTransitionStyle(this._target), this._target.removeEventListener("transitionend", this._onTransitionEnd, !1), this._target.removeEventListener("transitioncancel", this._onTransitionEnd, !1), this._finished || this._finalizeAnimation()
        }
    }
    class SpringEaser {
        constructor(initialVelocity, dampingRatio, naturalFrequency) {
            this.velocity = 1e3 * initialVelocity, this._dampingRatio = dampingRatio || .75, this._naturalFrequency = naturalFrequency || 12, this._dampingRatio < 1 && (this._dampedFrequency = this._naturalFrequency * Math.sqrt(1 - this._dampingRatio * this._dampingRatio))
        }
        easeFrame(deltaPosition, deltaTime) {
            let coeff, displacement = 0;
            deltaTime /= 1e3;
            const naturalDumpingPow = Math.E ** (-this._dampingRatio * this._naturalFrequency * deltaTime);
            if (1 === this._dampingRatio) coeff = this.velocity + this._naturalFrequency * deltaPosition, displacement = (deltaPosition + coeff * deltaTime) * naturalDumpingPow, this.velocity = displacement * -this._naturalFrequency + coeff * naturalDumpingPow;
            else if (this._dampingRatio < 1) {
                coeff = 1 / this._dampedFrequency * (this._dampingRatio * this._naturalFrequency * deltaPosition + this.velocity);
                const dumpedFCos = Math.cos(this._dampedFrequency * deltaTime),
                    dumpedFSin = Math.sin(this._dampedFrequency * deltaTime);
                displacement = naturalDumpingPow * (deltaPosition * dumpedFCos + coeff * dumpedFSin), this.velocity = displacement * -this._naturalFrequency * this._dampingRatio + naturalDumpingPow * (-this._dampedFrequency * deltaPosition * dumpedFSin + this._dampedFrequency * coeff * dumpedFCos)
            }
            return displacement
        }
    }
    class SpringAnimation {
        constructor(props) {
            this.props = props;
            const {
                start: start,
                end: end,
                velocity: velocity,
                onUpdate: onUpdate,
                onComplete: onComplete,
                onFinish: onFinish,
                dampingRatio: dampingRatio,
                naturalFrequency: naturalFrequency
            } = props, easer = new SpringEaser(velocity, dampingRatio, naturalFrequency);
            let prevTime = Date.now(),
                deltaPosition = start - end;
            this._onFinish = onFinish;
            const animationLoop = () => {
                this._raf && (deltaPosition = easer.easeFrame(deltaPosition, Date.now() - prevTime), Math.abs(deltaPosition) < 1 && Math.abs(easer.velocity) < 50 ? (onUpdate(end), onComplete && onComplete(), this.onFinish()) : (prevTime = Date.now(), onUpdate(deltaPosition + end), this._raf = requestAnimationFrame(animationLoop)))
            };
            this._raf = requestAnimationFrame(animationLoop)
        }
        destroy() {
            this._raf >= 0 && cancelAnimationFrame(this._raf), this._raf = null
        }
    }
    class photoswipe_esm_Animations {
        constructor() {
            this.activeAnimations = []
        }
        startSpring(props) {
            this._start(props, !0)
        }
        startTransition(props) {
            this._start(props)
        }
        _start(props, isSpring) {
            let animation;
            return animation = isSpring ? new SpringAnimation(props) : new CSSAnimation(props), this.activeAnimations.push(animation), animation.onFinish = () => this.stop(animation), animation
        }
        stop(animation) {
            animation.destroy();
            const index = this.activeAnimations.indexOf(animation);
            index > -1 && this.activeAnimations.splice(index, 1)
        }
        stopAll() {
            this.activeAnimations.forEach(animation => {
                animation.destroy()
            }), this.activeAnimations = []
        }
        stopAllPan() {
            this.activeAnimations = this.activeAnimations.filter(animation => !animation.props.isPan || (animation.destroy(), !1))
        }
        stopMainScroll() {
            this.activeAnimations = this.activeAnimations.filter(animation => !animation.props.isMainScroll || (animation.destroy(), !1))
        }
        isPanRunning() {
            return this.activeAnimations.some(animation => animation.props.isPan)
        }
    }
    class ScrollWheel {
        constructor(pswp) {
            this.pswp = pswp, pswp.events.add(pswp.template, "wheel", this._onWheel.bind(this))
        }
        _onWheel(e) {
            e.preventDefault();
            const {
                currSlide: currSlide
            } = this.pswp;
            let {
                deltaX: deltaX,
                deltaY: deltaY
            } = e;
            if (currSlide && !this.pswp.dispatch("wheel", {
                originalEvent: e
            }).defaultPrevented)
                if (e.ctrlKey || this.pswp.options.wheelToZoom) {
                    if (currSlide.isZoomable()) {
                        let zoomFactor = -deltaY;
                        1 === e.deltaMode ? zoomFactor *= .05 : zoomFactor *= e.deltaMode ? 1 : .002, zoomFactor = 2 ** zoomFactor, this.pswp.options.getWheelZoomFactorFn && (zoomFactor = this.pswp.options.getWheelZoomFactorFn(e, this.pswp));
                        const destZoomLevel = currSlide.currZoomLevel * zoomFactor;
                        currSlide.zoomTo(destZoomLevel, {
                            x: e.clientX,
                            y: e.clientY
                        })
                    }
                } else currSlide.isPannable() && (1 === e.deltaMode && (deltaX *= 18, deltaY *= 18), currSlide.panTo(currSlide.pan.x - deltaX, currSlide.pan.y - deltaY))
        }
    }
    class UIElement {
        constructor(pswp, data) {
            const name = data.name || data.class;
            let elementHTML = data.html;
            if (!1 === pswp.options[name]) return;
            "string" == typeof pswp.options[name + "SVG"] && (elementHTML = pswp.options[name + "SVG"]), pswp.dispatch("uiElementCreate", {
                data: data
            });
            let element, className = "pswp__";
            data.isButton && (className += "button pswp__button--"), className += data.class || data.name, data.isButton ? (element = photoswipe_esm_createElement(className, "button"), element.type = "button", element.innerHTML = function (htmlData) {
                if ("string" == typeof htmlData) return htmlData;
                if (!htmlData || !htmlData.isCustomSVG) return "";
                const svgData = htmlData;
                let out = '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">';
                return out = out.split("%d").join(svgData.size || 32), svgData.outlineID && (out += '<use class="pswp__icn-shadow" xlink:href="#' + svgData.outlineID + '"/>'), out += svgData.inner, out += "</svg>", out
            }(elementHTML), "string" == typeof pswp.options[name + "Title"] ? element.title = pswp.options[name + "Title"] : data.title && (element.title = data.title)) : element = photoswipe_esm_createElement(className), data.onInit && data.onInit(element, pswp), data.onClick && (element.onclick = e => {
                "string" == typeof data.onClick ? pswp[data.onClick]() : data.onClick(e, element, pswp)
            });
            const appendTo = data.appendTo || "bar";
            let container;
            "bar" === appendTo ? (pswp.topBar || (pswp.topBar = photoswipe_esm_createElement("pswp__top-bar pswp__hide-on-close", !1, pswp.scrollWrap)), container = pswp.topBar) : (element.classList.add("pswp__hide-on-close"), container = "wrapper" === appendTo ? pswp.scrollWrap : pswp.template), container.appendChild(element)
        }
    }

    function initArrowButton(element, pswp, isNextButton) {
        element.classList.add("pswp__button--arrow"), pswp.on("change", () => {
            pswp.options.loop || (element.disabled = isNextButton ? !(pswp.currIndex < pswp.getNumItems() - 1) : !(pswp.currIndex > 0))
        })
    }
    const arrowPrev = {
        name: "arrowPrev",
        class: "arrow--prev",
        title: "Previous",
        order: 10,
        isButton: !0,
        appendTo: "wrapper",
        html: {
            isCustomSVG: !0,
            size: 60,
            inner: '<path d="M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z" id="pswp__icn-arrow"/>',
            outlineID: "pswp__icn-arrow"
        },
        onClick: "prev",
        onInit: initArrowButton
    },
        arrowNext = {
            name: "arrowNext",
            class: "arrow--next",
            title: "Next",
            order: 11,
            isButton: !0,
            appendTo: "wrapper",
            html: {
                isCustomSVG: !0,
                size: 60,
                inner: '<use xlink:href="#pswp__icn-arrow"/>',
                outlineID: "pswp__icn-arrow"
            },
            onClick: "next",
            onInit: (el, pswp) => {
                initArrowButton(el, pswp, !0)
            }
        },
        closeButton = {
            name: "close",
            title: "Close",
            order: 20,
            isButton: !0,
            html: {
                isCustomSVG: !0,
                inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>',
                outlineID: "pswp__icn-close"
            },
            onClick: "close"
        },
        zoomButton = {
            name: "zoom",
            title: "Zoom (z)",
            order: 10,
            isButton: !0,
            html: {
                isCustomSVG: !0,
                inner: '<path d="M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z" id="pswp__icn-zoom"/><path fill="currentColor" class="pswp__zoom-icn-bar-h" d="M11 16v-2h6v2z"/><path fill="currentColor" class="pswp__zoom-icn-bar-v" d="M13 12h2v6h-2z"/>',
                outlineID: "pswp__icn-zoom"
            },
            onClick: "toggleZoom"
        },
        loadingIndicator = {
            name: "preloader",
            appendTo: "wrapper",
            onInit: (indicatorElement, pswp) => {
                let isVisible, delayTimeout, hidingTimeout;
                const updateIndicatorPosition = () => {
                    isVisible && (indicatorElement.style.left = Math.round((pswp.viewportSize.x - 24) / 2) + "px", indicatorElement.style.top = Math.round((pswp.viewportSize.y - 24) / 2) + "px")
                },
                    toggleIndicatorClass = (className, add) => {
                        indicatorElement.classList[add ? "add" : "remove"]("pswp__preloader--" + className)
                    },
                    setIndicatorVisibility = visible => {
                        isVisible !== visible && (isVisible = visible, clearTimeout(hidingTimeout), toggleIndicatorClass("hiding", !visible), visible ? (updateIndicatorPosition(), toggleIndicatorClass("active", !0)) : hidingTimeout = setTimeout(() => {
                            toggleIndicatorClass("active", !1)
                        }, 350))
                    };
                pswp.on("change", () => {
                    pswp.currSlide.isLoading ? (clearTimeout(delayTimeout), delayTimeout = setTimeout(() => {
                        setIndicatorVisibility(pswp.currSlide.isLoading)
                    }, 1100)) : setIndicatorVisibility(!1)
                }), pswp.on("loadComplete", e => {
                    pswp.currSlide === e.slide && setIndicatorVisibility(!1)
                }), pswp.on("resize", updateIndicatorPosition)
            }
        },
        counterIndicator = {
            name: "counter",
            order: 5,
            onInit: (counterElement, pswp) => {
                pswp.on("change", () => {
                    counterElement.innerHTML = pswp.currIndex + 1 + pswp.options.indexIndicatorSep + pswp.getNumItems()
                })
            }
        };

    function setZoomedIn(el, isZoomedIn) {
        el.classList[isZoomedIn ? "add" : "remove"]("pswp--zoomed-in")
    }
    class UI {
        constructor(pswp) {
            this.pswp = pswp
        }
        init() {
            const {
                pswp: pswp
            } = this;
            this.isRegistered = !1, this.uiElementsData = [closeButton, arrowPrev, arrowNext, zoomButton, loadingIndicator, counterIndicator], pswp.dispatch("uiRegister"), this.uiElementsData.sort((a, b) => (a.order || 0) - (b.order || 0)), this.items = [], this.isRegistered = !0, this.uiElementsData.forEach(uiElementData => {
                this.registerElement(uiElementData)
            }), 1 === pswp.getNumItems() && pswp.template.classList.add("pswp--one-slide"), pswp.on("zoomPanUpdate", () => this._onZoomPanUpdate())
        }
        registerElement(elementData) {
            this.isRegistered ? this.items.push(new UIElement(this.pswp, elementData)) : this.uiElementsData.push(elementData)
        }
        _onZoomPanUpdate() {
            const {
                template: template,
                currSlide: currSlide,
                options: options
            } = this.pswp;
            let {
                currZoomLevel: currZoomLevel
            } = currSlide;
            if (this.pswp.opener.isClosing) return;
            if (this.pswp.opener.isOpen || (currZoomLevel = currSlide.zoomLevels.initial), currZoomLevel === this._lastUpdatedZoomLevel) return;
            this._lastUpdatedZoomLevel = currZoomLevel;
            const currZoomLevelDiff = currSlide.zoomLevels.initial - currSlide.zoomLevels.secondary;
            if (Math.abs(currZoomLevelDiff) < .01 || !currSlide.isZoomable()) return setZoomedIn(template, !1), void template.classList.remove("pswp--zoom-allowed");
            template.classList.add("pswp--zoom-allowed");
            const secondaryIsHigher = currZoomLevelDiff < 0;
            currZoomLevel === currSlide.zoomLevels.secondary ? setZoomedIn(template, secondaryIsHigher) : currZoomLevel > currSlide.zoomLevels.secondary ? setZoomedIn(template, !0) : setZoomedIn(template, !1), "zoom" !== options.imageClickAction && "zoom-or-close" !== options.imageClickAction || template.classList.add("pswp--click-to-zoom")
        }
    }
    class photoswipe_esm_PhotoSwipeEvent {
        constructor(type, details) {
            this.type = type, details && Object.assign(this, details)
        }
        preventDefault() {
            this.defaultPrevented = !0
        }
    }
    class photoswipe_esm_Content {
        constructor(itemData, instance) {
            this.options = instance.options, this.instance = instance, this.data = itemData, this.width = Number(this.data.w) || Number(this.data.width) || 0, this.height = Number(this.data.h) || Number(this.data.height) || 0, this.isAttached = !1, this.state = photoswipe_esm_LOAD_STATE_IDLE
        }
        setSlide(slide) {
            this.slide = slide, this.pswp = slide.pswp
        }
        load() {
            this.element || (this.element = photoswipe_esm_createElement("pswp__content"), this.element.style.position = "absolute", this.element.style.left = 0, this.element.style.top = 0, this.element.innerHTML = this.data.html || "")
        }
        isZoomable() {
            return !1
        }
        usePlaceholder() {
            return !1
        }
        activate() { }
        deactivate() { }
        setDisplayedSize(width, height) {
            this.element && photoswipe_esm_setWidthHeight(this.element, width, height)
        }
        onLoaded() {
            this.state = photoswipe_esm_LOAD_STATE_LOADED, this.slide && this.pswp.dispatch("loadComplete", {
                slide: this.slide
            })
        }
        keepPlaceholder() {
            return this.state === photoswipe_esm_LOAD_STATE_LOADING
        }
        onError() {
            this.state = photoswipe_esm_LOAD_STATE_ERROR, this.slide && (this.pswp.dispatch("loadComplete", {
                slide: this.slide,
                isError: !0
            }), this.pswp.dispatch("loadError", {
                slide: this.slide
            }))
        }
        getErrorElement() {
            return !1
        }
        remove() {
            this.isAttached = !1, this.element && this.element.parentNode && this.element.remove()
        }
        appendTo(container) {
            this.isAttached = !0, this.element && !this.element.parentNode && container.appendChild(this.element)
        }
        destroy() { }
    }
    class photoswipe_esm_ImageContent extends photoswipe_esm_Content {
        load() {
            if (this.element) return;
            const imageSrc = this.data.src;
            imageSrc && (this.element = photoswipe_esm_createElement("pswp__img", "img"), this.data.srcset && (this.element.srcset = this.data.srcset), this.element.src = imageSrc, this.element.alt = this.data.alt || "", this.state = photoswipe_esm_LOAD_STATE_LOADING, this.element.complete ? this.onLoaded() : (this.element.onload = () => {
                this.onLoaded()
            }, this.element.onerror = () => {
                this.onError()
            }))
        }
        setDisplayedSize(width, height) {
            const image = this.element;
            image && (photoswipe_esm_setWidthHeight(image, width, "auto"), image.srcset && (!image.dataset.largestUsedSize || width > image.dataset.largestUsedSize) && (image.sizes = width + "px", image.dataset.largestUsedSize = width), this.slide && this.pswp.dispatch("imageSizeChange", {
                slide: this.slide,
                width: width,
                height: height
            }))
        }
        isZoomable() {
            return this.state !== photoswipe_esm_LOAD_STATE_ERROR
        }
        usePlaceholder() {
            return !0
        }
        lazyLoad() {
            this.load()
        }
        destroy() {
            this.element && (this.element.onload = null, this.element.onerror = null, this.element = null)
        }
        appendTo(container) {
            this.isAttached = !0, this.slide && !this.slide.isActive && "decode" in this.element ? (this.isDecoding = !0, requestAnimationFrame(() => {
                this.element && this.element.decode().then(() => {
                    this.isDecoding = !1, requestAnimationFrame(() => {
                        this.appendImageTo(container)
                    })
                }).catch(() => { })
            })) : this.appendImageTo(container)
        }
        activate() {
            this.slide && this.slide.container && this.isDecoding && this.appendImageTo(this.slide.container)
        }
        getErrorElement() {
            const el = photoswipe_esm_createElement("pswp__error-msg-container");
            el.innerHTML = this.options.errorMsg;
            const linkEl = el.querySelector("a");
            return linkEl && (linkEl.href = this.data.src), el
        }
        appendImageTo(container) {
            this.element && !this.element.parentNode && this.isAttached && container.appendChild(this.element)
        }
    }
    class Opener {
        constructor(pswp) {
            this.pswp = pswp, this.isClosed = !0, this._prepareOpen = this._prepareOpen.bind(this), pswp.on("firstZoomPan", this._prepareOpen)
        }
        open() {
            this._prepareOpen(), this._start()
        }
        close() {
            if (this.isClosed || this.isClosing || this.isOpening) return !1;
            const slide = this.pswp.currSlide;
            return this.isOpen = !1, this.isOpening = !1, this.isClosing = !0, this._duration = this.pswp.options.hideAnimationDuration, slide && slide.currZoomLevel * slide.width >= 4e3 && (this._duration = 0), this._applyStartProps(), setTimeout(() => {
                this._start()
            }, this._croppedZoom ? 30 : 0), !0
        }
        _prepareOpen() {
            this.pswp.off("firstZoomPan", this._prepareOpen), this.isOpening || (this.isOpening = !0, this.isClosing = !1, this._duration = this.pswp.options.showAnimationDuration, this._applyStartProps())
        }
        _applyStartProps() {
            const {
                pswp: pswp
            } = this, slide = this.pswp.currSlide, {
                options: options
            } = pswp;
            if ("fade" === options.showHideAnimationType ? (options.showHideOpacity = !0, this._thumbBounds = !1) : "none" === options.showHideAnimationType ? (options.showHideOpacity = !1, this._duration = 0, this._thumbBounds = !1) : this.isOpening && pswp._initialThumbBounds ? this._thumbBounds = pswp._initialThumbBounds : this._thumbBounds = this.pswp.getThumbBounds(), this._placeholder = slide.getPlaceholderElement(), pswp.animations.stopAll(), this._useAnimation = this._duration > 50, this._animateZoom = Boolean(this._thumbBounds) && (!this.isClosing || !pswp.mainScroll.isShifted()), this._animateZoom ? this._animateRootOpacity = options.showHideOpacity : (this._animateRootOpacity = !0, this.isOpening && (slide.zoomAndPanToInitial(), slide.applyCurrentZoomPan())), this._animateBgOpacity = !this._animateRootOpacity, this._opacityElement = this._animateRootOpacity ? pswp.template : pswp.bg, !this._useAnimation) return this._duration = 0, this._animateZoom = !1, this._animateBgOpacity = !1, this._animateRootOpacity = !0, void (this.isOpening && (pswp.template.style.opacity = .003, pswp.applyBgOpacity(1)));
            this._animateZoom && this._thumbBounds.innerRect ? (this._croppedZoom = !0, this._cropContainer1 = this.pswp.container, this._cropContainer2 = this.pswp.currSlide.holderElement, pswp.container.style.overflow = "hidden", pswp.container.style.width = pswp.viewportSize.x + "px") : this._croppedZoom = !1, this.isOpening ? (this._animateBgOpacity && (pswp.bg.style.opacity = .003, pswp.template.style.opacity = 1), this._animateRootOpacity && (pswp.template.style.opacity = .003, pswp.applyBgOpacity(1)), this._animateZoom && (this._setClosedStateZoomPan(), this._placeholder && (this._placeholder.willChange = "transform", this._placeholder.style.opacity = .003))) : this.isClosing && (pswp.mainScroll.itemHolders[0].el.style.display = "none", pswp.mainScroll.itemHolders[2].el.style.display = "none", this._croppedZoom && 0 !== pswp.mainScroll.x && (pswp.mainScroll.resetPosition(), pswp.mainScroll.resize()))
        }
        _start() {
            this.isOpening && this._useAnimation && this._placeholder && "IMG" === this._placeholder.tagName ? new Promise(resolve => {
                let decoded = !1,
                    isDelaying = !0;
                var img;
                (img = this._placeholder, "decode" in img ? img.decode() : img.complete ? Promise.resolve(img) : new Promise((resolve, reject) => {
                    img.onload = () => resolve(img), img.onerror = reject
                })).finally(() => {
                    decoded = !0, isDelaying || resolve()
                }), setTimeout(() => {
                    isDelaying = !1, decoded && resolve()
                }, 50), setTimeout(resolve, 250)
            }).finally(() => this._initiate()) : this._initiate()
        }
        _initiate() {
            this.pswp.template.style.setProperty("--pswp-transition-duration", this._duration + "ms"), this.pswp.dispatch("initialZoom" + (this.isOpening ? "In" : "Out")), this.pswp.template.classList[this.isOpening ? "add" : "remove"]("pswp--ui-visible"), this.isOpening ? (this._placeholder && (this._placeholder.style.opacity = 1), this._animateToOpenState()) : this.isClosing && this._animateToClosedState(), this._useAnimation || this._onAnimationComplete()
        }
        _onAnimationComplete() {
            const {
                pswp: pswp
            } = this;
            this.isOpen = this.isOpening, this.isClosed = this.isClosing, this.isOpening = !1, this.isClosing = !1, pswp.dispatch("initialZoom" + (this.isOpen ? "InEnd" : "OutEnd")), this.isClosed ? pswp.destroy() : this.isOpen && (this._animateZoom && (pswp.container.style.overflow = "visible", pswp.container.style.width = "100%"), pswp.currSlide.applyCurrentZoomPan())
        }
        _animateToOpenState() {
            const {
                pswp: pswp
            } = this;
            this._animateZoom && (this._croppedZoom && (this._animateTo(this._cropContainer1, "transform", "translate3d(0,0,0)"), this._animateTo(this._cropContainer2, "transform", "none")), pswp.currSlide.zoomAndPanToInitial(), this._animateTo(pswp.currSlide.container, "transform", pswp.currSlide.getCurrentTransform())), this._animateBgOpacity && this._animateTo(pswp.bg, "opacity", pswp.options.bgOpacity), this._animateRootOpacity && this._animateTo(pswp.template, "opacity", 1)
        }
        _animateToClosedState() {
            const {
                pswp: pswp
            } = this;
            this._animateZoom && this._setClosedStateZoomPan(!0), this._animateBgOpacity && pswp.bgOpacity > .01 && this._animateTo(pswp.bg, "opacity", 0), this._animateRootOpacity && this._animateTo(pswp.template, "opacity", 0)
        }
        _setClosedStateZoomPan(animate) {
            const {
                pswp: pswp
            } = this, {
                innerRect: innerRect
            } = this._thumbBounds, {
                currSlide: currSlide,
                viewportSize: viewportSize
            } = pswp;
            if (this._croppedZoom) {
                const containerOnePanX = -viewportSize.x + (this._thumbBounds.x - innerRect.x) + innerRect.w,
                    containerOnePanY = -viewportSize.y + (this._thumbBounds.y - innerRect.y) + innerRect.h,
                    containerTwoPanX = viewportSize.x - innerRect.w,
                    containerTwoPanY = viewportSize.y - innerRect.h;
                animate ? (this._animateTo(this._cropContainer1, "transform", toTransformString(containerOnePanX, containerOnePanY)), this._animateTo(this._cropContainer2, "transform", toTransformString(containerTwoPanX, containerTwoPanY))) : (photoswipe_esm_setTransform(this._cropContainer1, containerOnePanX, containerOnePanY), photoswipe_esm_setTransform(this._cropContainer2, containerTwoPanX, containerTwoPanY))
            }
            equalizePoints(currSlide.pan, innerRect || this._thumbBounds), currSlide.currZoomLevel = this._thumbBounds.w / currSlide.width, animate ? this._animateTo(currSlide.container, "transform", currSlide.getCurrentTransform()) : currSlide.applyCurrentZoomPan()
        }
        _animateTo(target, prop, propValue) {
            if (!this._duration) return void (target.style[prop] = propValue);
            const {
                animations: animations
            } = this.pswp, animProps = {
                duration: this._duration,
                easing: this.pswp.options.easing,
                onComplete: () => {
                    animations.activeAnimations.length || this._onAnimationComplete()
                },
                target: target
            };
            animProps[prop] = propValue, animations.startTransition(animProps)
        }
    }

    function photoswipe_esm_getKey(itemData, index) {
        return itemData && itemData.src ? itemData.src + "_" + index : index
    }

    function photoswipe_esm_lazyLoadSlide(index, instance) {
        const itemData = instance.getItemData(index);
        if (!instance.dispatch("lazyLoadSlide", {
            index: index,
            itemData: itemData
        }).defaultPrevented) return function (itemData, instance, index) {
            const content = instance.createContentFromData(itemData);
            if (!content || !content.lazyLoad) return;
            content.key = photoswipe_esm_getKey(itemData, index);
            const {
                options: options
            } = instance, panAreaSize = photoswipe_esm_getPanAreaSize(options, instance.viewportSize || photoswipe_esm_getViewportSize(options)), zoomLevel = new photoswipe_esm_ZoomLevel(options, itemData, -1);
            return zoomLevel.update(content.width, content.height, panAreaSize), content.lazyLoad(), content.setDisplayedSize(Math.ceil(content.width * zoomLevel.initial), Math.ceil(content.height * zoomLevel.initial)), content
        }(itemData, instance, index)
    }
    class ContentLoader {
        constructor(pswp) {
            this.pswp = pswp, this.limit = Math.max(pswp.options.preload[0] + pswp.options.preload[1] + 1, 5), this._cachedItems = []
        }
        updateLazy(diff) {
            const {
                pswp: pswp
            } = this;
            if (pswp.dispatch("lazyLoad").defaultPrevented) return;
            const {
                preload: preload
            } = pswp.options, isForward = void 0 === diff || diff >= 0;
            let i;
            for (i = 0; i <= preload[1]; i++) this.loadSlideByIndex(pswp.currIndex + (isForward ? i : -i));
            for (i = 1; i <= preload[0]; i++) this.loadSlideByIndex(pswp.currIndex + (isForward ? -i : i))
        }
        loadSlideByIndex(index) {
            index = this.pswp.getLoopedIndex(index);
            const key = photoswipe_esm_getKey(this.pswp.getItemData(index), index);
            let content = this.getContentByKey(key);
            content || (content = photoswipe_esm_lazyLoadSlide(index, this.pswp), content.key = key, this.addToCache(content))
        }
        getContentBySlide(slide) {
            let content = this.getContentByKey(this.getKeyBySlide(slide));
            return content || (content = this.pswp.createContentFromData(slide.data), content.key = this.getKeyBySlide(slide), this.addToCache(content)), content.setSlide(slide), content
        }
        addToCache(content) {
            if (this.removeByKey(content.key), this._cachedItems.push(content), this._cachedItems.length > this.limit) {
                const indexToRemove = this._cachedItems.findIndex(item => !item.isAttached);
                if (-1 !== indexToRemove) {
                    this._cachedItems.splice(indexToRemove, 1)[0].destroy()
                }
            }
        }
        removeByKey(key) {
            const indexToRemove = this._cachedItems.findIndex(item => item.key === key); - 1 !== indexToRemove && this._cachedItems.splice(indexToRemove, 1)
        }
        getContentByKey(key) {
            return this._cachedItems.find(content => content.key === key)
        }
        getKeyBySlide(slide) {
            return photoswipe_esm_getKey(slide.data, slide.index)
        }
        destroy() {
            this._cachedItems.forEach(content => content.destroy()), this._cachedItems = null
        }
    }
    const photoswipe_esm_defaultOptions = {
        allowPanToNext: !0,
        spacing: .1,
        loop: !0,
        pinchToClose: !0,
        closeOnVerticalDrag: !0,
        hideAnimationDuration: 333,
        showAnimationDuration: 333,
        zoomAnimationDuration: 333,
        escKey: !0,
        arrowKeys: !0,
        returnFocus: !0,
        limitMaxZoom: !0,
        clickToCloseNonZoomable: !0,
        imageClickAction: "zoom-or-close",
        bgClickAction: "close",
        tapAction: "toggle-controls",
        doubleTapAction: "zoom",
        indexIndicatorSep: " / ",
        bgOpacity: .8,
        index: 0,
        errorMsg: '<div class="pswp__error-msg"><a href="" target="_blank">The image</a> could not be loaded.</div>',
        preload: [1, 2],
        easing: "cubic-bezier(.4,0,.22,1)"
    };
    var playlistVideo = document.querySelector(".trust__playlist-video"),
        playlistList = document.querySelector(".trust__playlist-list");

    function getBoundingClientRect(element, includeScale) {
        void 0 === includeScale && (includeScale = !1);
        var rect = element.getBoundingClientRect();
        return {
            width: rect.width / 1,
            height: rect.height / 1,
            top: rect.top / 1,
            right: rect.right / 1,
            bottom: rect.bottom / 1,
            left: rect.left / 1,
            x: rect.left / 1,
            y: rect.top / 1
        }
    }

    function getWindow_getWindow(node) {
        if (null == node) return window;
        if ("[object Window]" !== node.toString()) {
            var ownerDocument = node.ownerDocument;
            return ownerDocument && ownerDocument.defaultView || window
        }
        return node
    }

    function getWindowScroll(node) {
        var win = getWindow_getWindow(node);
        return {
            scrollLeft: win.pageXOffset,
            scrollTop: win.pageYOffset
        }
    }

    function isElement(node) {
        return node instanceof getWindow_getWindow(node).Element || node instanceof Element
    }

    function isHTMLElement(node) {
        return node instanceof getWindow_getWindow(node).HTMLElement || node instanceof HTMLElement
    }

    function isShadowRoot(node) {
        return "undefined" != typeof ShadowRoot && (node instanceof getWindow_getWindow(node).ShadowRoot || node instanceof ShadowRoot)
    }

    function getNodeName(element) {
        return element ? (element.nodeName || "").toLowerCase() : null
    }

    function getDocumentElement(element) {
        return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement
    }

    function getWindowScrollBarX(element) {
        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft
    }

    function getComputedStyle_getComputedStyle(element) {
        return getWindow_getWindow(element).getComputedStyle(element)
    }

    function isScrollParent(element) {
        var _getComputedStyle = getComputedStyle_getComputedStyle(element),
            overflow = _getComputedStyle.overflow,
            overflowX = _getComputedStyle.overflowX,
            overflowY = _getComputedStyle.overflowY;
        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)
    }

    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
        void 0 === isFixed && (isFixed = !1);
        var node, element, isOffsetParentAnElement = isHTMLElement(offsetParent),
            offsetParentIsScaled = isHTMLElement(offsetParent) && function (element) {
                var rect = element.getBoundingClientRect(),
                    scaleX = rect.width / element.offsetWidth || 1,
                    scaleY = rect.height / element.offsetHeight || 1;
                return 1 !== scaleX || 1 !== scaleY
            }(offsetParent),
            documentElement = getDocumentElement(offsetParent),
            rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled),
            scroll = {
                scrollLeft: 0,
                scrollTop: 0
            },
            offsets = {
                x: 0,
                y: 0
            };
        return (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && (("body" !== getNodeName(offsetParent) || isScrollParent(documentElement)) && (scroll = (node = offsetParent) !== getWindow_getWindow(node) && isHTMLElement(node) ? {
            scrollLeft: (element = node).scrollLeft,
            scrollTop: element.scrollTop
        } : getWindowScroll(node)), isHTMLElement(offsetParent) ? ((offsets = getBoundingClientRect(offsetParent, !0)).x += offsetParent.clientLeft, offsets.y += offsetParent.clientTop) : documentElement && (offsets.x = getWindowScrollBarX(documentElement))), {
            x: rect.left + scroll.scrollLeft - offsets.x,
            y: rect.top + scroll.scrollTop - offsets.y,
            width: rect.width,
            height: rect.height
        }
    }

    function getLayoutRect(element) {
        var clientRect = getBoundingClientRect(element),
            width = element.offsetWidth,
            height = element.offsetHeight;
        return Math.abs(clientRect.width - width) <= 1 && (width = clientRect.width), Math.abs(clientRect.height - height) <= 1 && (height = clientRect.height), {
            x: element.offsetLeft,
            y: element.offsetTop,
            width: width,
            height: height
        }
    }

    function getParentNode(element) {
        return "html" === getNodeName(element) ? element : element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element)
    }

    function listScrollParents(element, list) {
        var _element$ownerDocumen;
        void 0 === list && (list = []);
        var scrollParent = function getScrollParent(node) {
            return ["html", "body", "#document"].indexOf(getNodeName(node)) >= 0 ? node.ownerDocument.body : isHTMLElement(node) && isScrollParent(node) ? node : getScrollParent(getParentNode(node))
        }(element),
            isBody = scrollParent === (null == (_element$ownerDocumen = element.ownerDocument) ? void 0 : _element$ownerDocumen.body),
            win = getWindow_getWindow(scrollParent),
            target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent,
            updatedList = list.concat(target);
        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)))
    }

    function isTableElement(element) {
        return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0
    }

    function getTrueOffsetParent(element) {
        return isHTMLElement(element) && "fixed" !== getComputedStyle_getComputedStyle(element).position ? element.offsetParent : null
    }

    function getOffsetParent(element) {
        for (var window = getWindow_getWindow(element), offsetParent = getTrueOffsetParent(element); offsetParent && isTableElement(offsetParent) && "static" === getComputedStyle_getComputedStyle(offsetParent).position;) offsetParent = getTrueOffsetParent(offsetParent);
        return offsetParent && ("html" === getNodeName(offsetParent) || "body" === getNodeName(offsetParent) && "static" === getComputedStyle_getComputedStyle(offsetParent).position) ? window : offsetParent || function (element) {
            var isFirefox = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
            if (-1 !== navigator.userAgent.indexOf("Trident") && isHTMLElement(element) && "fixed" === getComputedStyle_getComputedStyle(element).position) return null;
            for (var currentNode = getParentNode(element); isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0;) {
                var css = getComputedStyle_getComputedStyle(currentNode);
                if ("none" !== css.transform || "none" !== css.perspective || "paint" === css.contain || -1 !== ["transform", "perspective"].indexOf(css.willChange) || isFirefox && "filter" === css.willChange || isFirefox && css.filter && "none" !== css.filter) return currentNode;
                currentNode = currentNode.parentNode
            }
            return null
        }(element) || window
    }
    playlistList && playlistList.querySelectorAll(".trust__playlist-item").forEach((function (item) {
        var videoSrc = item.dataset.video;
        item.addEventListener("click", (function () {
            playlistVideo.setAttribute("src", videoSrc), playlistVideo.play()
        }))
    })), new class extends class extends class {
        constructor() {
            this._listeners = {}, this._filters = {}
        }
        addFilter(name, fn, priority = 100) {
            this._filters[name] || (this._filters[name] = []), this._filters[name].push({
                fn: fn,
                priority: priority
            }), this._filters[name].sort((f1, f2) => f1.priority - f2.priority), this.pswp && this.pswp.addFilter(name, fn, priority)
        }
        removeFilter(name, fn) {
            this._filters[name] && (this._filters[name] = this._filters[name].filter(filter => filter.fn !== fn)), this.pswp && this.pswp.removeFilter(name, fn)
        }
        applyFilters(name, ...args) {
            return this._filters[name] && this._filters[name].forEach(filter => {
                args[0] = filter.fn.apply(this, args)
            }), args[0]
        }
        on(name, fn) {
            this._listeners[name] || (this._listeners[name] = []), this._listeners[name].push(fn), this.pswp && this.pswp.on(name, fn)
        }
        off(name, fn) {
            this._listeners[name] && (this._listeners[name] = this._listeners[name].filter(listener => fn !== listener)), this.pswp && this.pswp.off(name, fn)
        }
        dispatch(name, details) {
            if (this.pswp) return this.pswp.dispatch(name, details);
            const event = new PhotoSwipeEvent(name, details);
            return this._listeners ? (this._listeners[name] && this._listeners[name].forEach(listener => {
                listener.call(this, event)
            }), event) : event
        }
    } {
        constructor() {
            super(), this.contentTypes = {
                image: ImageContent,
                html: Content
            }
        }
        getNumItems() {
            let numItems;
            const {
                dataSource: dataSource
            } = this.options;
            dataSource ? dataSource.length ? numItems = dataSource.length : dataSource.gallery && (dataSource.items || (dataSource.items = this._getGalleryDOMElements(dataSource.gallery)), dataSource.items && (numItems = dataSource.items.length)) : numItems = 0;
            const event = this.dispatch("numItems", {
                dataSource: dataSource,
                numItems: numItems
            });
            return this.applyFilters("numItems", event.numItems, dataSource)
        }
        addContentType(type, ContentClass) {
            this.contentTypes[type] = ContentClass
        }
        getContentClass(slideData) {
            return slideData.type ? this.contentTypes[slideData.type] : slideData.src ? this.contentTypes.image : slideData.html ? this.contentTypes.html : void 0
        }
        createContentFromData(slideData) {
            return new (this.getContentClass(slideData))(slideData, this)
        }
        getItemData(index) {
            const {
                dataSource: dataSource
            } = this.options;
            let dataSourceItem;
            Array.isArray(dataSource) ? dataSourceItem = dataSource[index] : dataSource && dataSource.gallery && (dataSource.items || (dataSource.items = this._getGalleryDOMElements(dataSource.gallery)), dataSourceItem = dataSource.items[index]);
            let itemData = dataSourceItem;
            itemData instanceof Element && (itemData = this._domElementToItemData(itemData));
            const event = this.dispatch("itemData", {
                itemData: itemData || {},
                index: index
            });
            return this.applyFilters("itemData", event.itemData, index)
        }
        _getGalleryDOMElements(galleryElement) {
            return this.options.children || this.options.childSelector ? getElementsFromOption(this.options.children, this.options.childSelector, galleryElement) || [] : [galleryElement]
        }
        _domElementToItemData(element) {
            const itemData = {
                element: element
            },
                linkEl = "A" === element.tagName ? element : element.querySelector("a");
            if (linkEl) {
                itemData.src = linkEl.dataset.pswpSrc || linkEl.href, itemData.srcset = linkEl.dataset.pswpSrcset, itemData.w = parseInt(linkEl.dataset.pswpWidth, 10), itemData.h = parseInt(linkEl.dataset.pswpHeight, 10), linkEl.dataset.pswpType && (itemData.type = linkEl.dataset.pswpType);
                const thumbnailEl = element.querySelector("img");
                thumbnailEl && (itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src, itemData.alt = thumbnailEl.getAttribute("alt")), (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) && (itemData.thumbCropped = !0)
            }
            return this.applyFilters("domItemData", itemData, element, linkEl), itemData
        }
    } {
        constructor(options) {
            super(), this.options = options || {}, this._uid = 0
        }
        init() {
            this.onThumbnailsClick = this.onThumbnailsClick.bind(this), getElementsFromOption(this.options.gallery, this.options.gallerySelector).forEach(galleryElement => {
                galleryElement.addEventListener("click", this.onThumbnailsClick, !1)
            })
        }
        onThumbnailsClick(e) {
            if (function (e) {
                if (2 === e.which || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) return !0
            }(e) || window.pswp || !1 === window.navigator.onLine) return;
            let initialPoint = {
                x: e.clientX,
                y: e.clientY
            };
            initialPoint.x || initialPoint.y || (initialPoint = null);
            const clickedIndex = this.getClickedIndex(e),
                dataSource = {
                    gallery: e.currentTarget
                };
            clickedIndex >= 0 && (e.preventDefault(), this.loadAndOpen(clickedIndex, dataSource, initialPoint))
        }
        getClickedIndex(e) {
            if (this.options.getClickedIndexFn) return this.options.getClickedIndexFn.call(this, e);
            const clickedTarget = e.target,
                clickedChildIndex = getElementsFromOption(this.options.children, this.options.childSelector, e.currentTarget).findIndex(child => child === clickedTarget || child.contains(clickedTarget));
            return -1 !== clickedChildIndex ? clickedChildIndex : this.options.children || this.options.childSelector ? -1 : 0
        }
        loadAndOpen(index, dataSource, initialPoint) {
            return !window.pswp && (this.options.index = index, this.options.initialPointerPos = initialPoint, this.shouldOpen = !0, this.preload(index, dataSource), !0)
        }
        preload(index, dataSource) {
            const {
                options: options
            } = this;
            dataSource && (options.dataSource = dataSource);
            const promiseArray = [dynamicImportModule(options.pswpModule)];
            "function" == typeof options.openPromise && promiseArray.push(options.openPromise()), !1 !== options.preloadFirstSlide && index >= 0 && (this._preloadedContent = function (index, instance) {
                const itemData = instance.getItemData(index);
                if (!instance.dispatch("lazyLoadSlide", {
                    index: index,
                    itemData: itemData
                }).defaultPrevented) return lazyLoadData(itemData, instance, index)
            }(index, this));
            const uid = ++this._uid;
            Promise.all(promiseArray).then(iterableModules => {
                if (this.shouldOpen) {
                    const mainModule = iterableModules[0];
                    this._openPhotoswipe(mainModule, uid)
                }
            })
        }
        _openPhotoswipe(module, uid) {
            if (uid !== this._uid && this.shouldOpen) return;
            if (this.shouldOpen = !1, window.pswp) return;
            const pswp = "object" == typeof module ? new module.default(null, this.options) : new module(null, this.options);
            this.pswp = pswp, window.pswp = pswp, Object.keys(this._listeners).forEach(name => {
                this._listeners[name].forEach(fn => {
                    pswp.on(name, fn)
                })
            }), Object.keys(this._filters).forEach(name => {
                this._filters[name].forEach(filter => {
                    pswp.addFilter(name, filter.fn, filter.priority)
                })
            }), pswp.contentTypes = {
                ...this.contentTypes
            }, this._preloadedContent && (pswp.contentLoader.addToCache(this._preloadedContent), this._preloadedContent = null), pswp.on("destroy", () => {
                this.pswp = null, window.pswp = null
            }), pswp.init()
        }
        destroy() {
            this.pswp && this.pswp.close(), this.shouldOpen = !1, this._listeners = null, getElementsFromOption(this.options.gallery, this.options.gallerySelector).forEach(galleryElement => {
                galleryElement.removeEventListener("click", this.onThumbnailsClick, !1)
            })
        }
    }({
        gallery: ".trust__install-list",
        children: ".trust__install-screen-link",
        pswpModule: class extends class extends class {
            constructor() {
                this._listeners = {}, this._filters = {}
            }
            addFilter(name, fn, priority = 100) {
                this._filters[name] || (this._filters[name] = []), this._filters[name].push({
                    fn: fn,
                    priority: priority
                }), this._filters[name].sort((f1, f2) => f1.priority - f2.priority), this.pswp && this.pswp.addFilter(name, fn, priority)
            }
            removeFilter(name, fn) {
                this._filters[name] && (this._filters[name] = this._filters[name].filter(filter => filter.fn !== fn)), this.pswp && this.pswp.removeFilter(name, fn)
            }
            applyFilters(name, ...args) {
                return this._filters[name] && this._filters[name].forEach(filter => {
                    args[0] = filter.fn.apply(this, args)
                }), args[0]
            }
            on(name, fn) {
                this._listeners[name] || (this._listeners[name] = []), this._listeners[name].push(fn), this.pswp && this.pswp.on(name, fn)
            }
            off(name, fn) {
                this._listeners[name] && (this._listeners[name] = this._listeners[name].filter(listener => fn !== listener)), this.pswp && this.pswp.off(name, fn)
            }
            dispatch(name, details) {
                if (this.pswp) return this.pswp.dispatch(name, details);
                const event = new photoswipe_esm_PhotoSwipeEvent(name, details);
                return this._listeners ? (this._listeners[name] && this._listeners[name].forEach(listener => {
                    listener.call(this, event)
                }), event) : event
            }
        } {
            constructor() {
                super(), this.contentTypes = {
                    image: photoswipe_esm_ImageContent,
                    html: photoswipe_esm_Content
                }
            }
            getNumItems() {
                let numItems;
                const {
                    dataSource: dataSource
                } = this.options;
                dataSource ? dataSource.length ? numItems = dataSource.length : dataSource.gallery && (dataSource.items || (dataSource.items = this._getGalleryDOMElements(dataSource.gallery)), dataSource.items && (numItems = dataSource.items.length)) : numItems = 0;
                const event = this.dispatch("numItems", {
                    dataSource: dataSource,
                    numItems: numItems
                });
                return this.applyFilters("numItems", event.numItems, dataSource)
            }
            addContentType(type, ContentClass) {
                this.contentTypes[type] = ContentClass
            }
            getContentClass(slideData) {
                return slideData.type ? this.contentTypes[slideData.type] : slideData.src ? this.contentTypes.image : slideData.html ? this.contentTypes.html : void 0
            }
            createContentFromData(slideData) {
                return new (this.getContentClass(slideData))(slideData, this)
            }
            getItemData(index) {
                const {
                    dataSource: dataSource
                } = this.options;
                let dataSourceItem;
                Array.isArray(dataSource) ? dataSourceItem = dataSource[index] : dataSource && dataSource.gallery && (dataSource.items || (dataSource.items = this._getGalleryDOMElements(dataSource.gallery)), dataSourceItem = dataSource.items[index]);
                let itemData = dataSourceItem;
                itemData instanceof Element && (itemData = this._domElementToItemData(itemData));
                const event = this.dispatch("itemData", {
                    itemData: itemData || {},
                    index: index
                });
                return this.applyFilters("itemData", event.itemData, index)
            }
            _getGalleryDOMElements(galleryElement) {
                return this.options.children || this.options.childSelector ? function (option, legacySelector, parent = document) {
                    let elements = [];
                    if (option instanceof Element) elements = [option];
                    else if (option instanceof NodeList || Array.isArray(option)) elements = Array.from(option);
                    else {
                        const selector = "string" == typeof option ? option : legacySelector;
                        selector && (elements = Array.from(parent.querySelectorAll(selector)))
                    }
                    return elements
                }(this.options.children, this.options.childSelector, galleryElement) || [] : [galleryElement]
            }
            _domElementToItemData(element) {
                const itemData = {
                    element: element
                },
                    linkEl = "A" === element.tagName ? element : element.querySelector("a");
                if (linkEl) {
                    itemData.src = linkEl.dataset.pswpSrc || linkEl.href, itemData.srcset = linkEl.dataset.pswpSrcset, itemData.w = parseInt(linkEl.dataset.pswpWidth, 10), itemData.h = parseInt(linkEl.dataset.pswpHeight, 10), linkEl.dataset.pswpType && (itemData.type = linkEl.dataset.pswpType);
                    const thumbnailEl = element.querySelector("img");
                    thumbnailEl && (itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src, itemData.alt = thumbnailEl.getAttribute("alt")), (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) && (itemData.thumbCropped = !0)
                }
                return this.applyFilters("domItemData", itemData, element, linkEl), itemData
            }
        } {
            constructor(items, options) {
                super(), this.items = items, this._prepareOptions(options), this.offset = {}, this._prevViewportSize = {}, this.viewportSize = {}, this.bgOpacity = 1, this.events = new DOMEvents, this.animations = new photoswipe_esm_Animations, this.mainScroll = new MainScroll(this), this.gestures = new Gestures(this), this.opener = new Opener(this), this.keyboard = new photoswipe_esm_Keyboard(this), this.contentLoader = new ContentLoader(this)
            }
            init() {
                if (this.isOpen || this.isDestroying) return;
                this.isOpen = !0, this.getNumItems() < 3 && (this.options.loop = !1), this.dispatch("init"), this._createMainStructure();
                let rootClasses = "pswp--open";
                return this.gestures.supportsTouch && (rootClasses += " pswp--touch"), this.options.allowMouseDrag || (rootClasses += " pswp--no-mouse-drag"), this.options.mainClass && (rootClasses += " " + this.options.mainClass), this.template.className += " " + rootClasses, this.currIndex = this.options.index || 0, this.potentialIndex = this.currIndex, this.dispatch("firstUpdate"), this.scrollWheel = new ScrollWheel(this), (Number.isNaN(this.currIndex) || this.currIndex < 0 || this.currIndex >= this.getNumItems()) && (this.currIndex = 0), this.gestures.supportsTouch || this.mouseDetected(), this.updateSize(), this.offset.y = window.pageYOffset, this._initialItemData = this.getItemData(this.currIndex), this.dispatch("gettingData", this.currIndex, this._initialItemData, !0), this._initialThumbBounds = this.getThumbBounds(), this.dispatch("initialLayout"), this.on("initialZoomInEnd", () => {
                    this.setContent(this.mainScroll.itemHolders[0], this.currIndex - 1), this.setContent(this.mainScroll.itemHolders[2], this.currIndex + 1), this.mainScroll.itemHolders[0].el.style.display = "block", this.mainScroll.itemHolders[2].el.style.display = "block", this.appendHeavy(), this.contentLoader.updateLazy(), this.events.add(window, "resize", this._handlePageResize.bind(this)), this.events.add(window, "scroll", this._updatePageScrollOffset.bind(this)), this.dispatch("bindEvents")
                }), this.on("loadComplete", e => {
                    e.slide.heavyAppended && e.slide.removePlaceholder()
                }), this.on("loadError", e => {
                    e.slide.heavyAppended && (e.slide.removePlaceholder(), e.slide.displayError())
                }), this.setContent(this.mainScroll.itemHolders[1], this.currIndex), this.dispatch("change"), this.opener.open(), this.dispatch("afterInit"), !0
            }
            getLoopedIndex(index) {
                const numSlides = this.getNumItems();
                return this.options.loop && (index > numSlides - 1 && (index -= numSlides), index < 0 && (index += numSlides)), index = clamp(index, 0, numSlides - 1)
            }
            getIndexDiff(index) {
                if (this.options.loop) {
                    const lastItemIndex = this.getNumItems() - 1;
                    if (0 === this.currIndex && index === lastItemIndex) return -1;
                    if (this.currIndex === lastItemIndex && 0 === index) return 1
                }
                return index - this.currIndex
            }
            appendHeavy() {
                this.mainScroll.itemHolders.forEach(itemHolder => {
                    itemHolder.slide && itemHolder.slide.appendHeavy()
                })
            }
            goTo(index) {
                index = this.getLoopedIndex(index);
                this.mainScroll.moveIndexBy(index - this.potentialIndex) && this.dispatch("afterGoto")
            }
            next() {
                this.goTo(this.potentialIndex + 1)
            }
            prev() {
                this.goTo(this.potentialIndex - 1)
            }
            zoomTo(...args) {
                this.currSlide.zoomTo(...args)
            }
            toggleZoom() {
                this.currSlide.toggleZoom()
            }
            close() {
                this.opener.isOpen && !this.isDestroying && (this.isDestroying = !0, this.dispatch("close"), this.events.removeAll(), this.opener.close())
            }
            destroy() {
                this.isDestroying ? (this.dispatch("destroy"), this.listeners = null, this.scrollWrap.ontouchmove = null, this.scrollWrap.ontouchend = null, this.template.remove(), this.contentLoader.destroy(), this.events.removeAll()) : this.close()
            }
            setContent(holder, index) {
                if (holder.slide && holder.slide.destroy(), this.options.loop) index = this.getLoopedIndex(index);
                else if (index < 0 || index >= this.getNumItems()) return void (holder.el.innerHTML = "");
                const itemData = this.getItemData(index);
                holder.slide = new Slide(itemData, index, this), index === this.currIndex && (this.currSlide = holder.slide), holder.slide.append(holder.el)
            }
            getViewportCenterPoint() {
                return {
                    x: this.viewportSize.x / 2,
                    y: this.viewportSize.y / 2
                }
            }
            updateSize(force) {
                if (this.isDestroying) return;
                const newViewportSize = photoswipe_esm_getViewportSize(this.options, this);
                !force && pointsEqual(newViewportSize, this._prevViewportSize) || (equalizePoints(this._prevViewportSize, newViewportSize), this.dispatch("beforeResize"), equalizePoints(this.viewportSize, this._prevViewportSize), this._updatePageScrollOffset(), this.dispatch("viewportSize"), this.mainScroll.resize(this.opener.isOpen), !this.hasMouse && window.matchMedia("(any-hover: hover)").matches && this.mouseDetected(), this.dispatch("resize"))
            }
            applyBgOpacity(opacity) {
                this.bgOpacity = Math.max(opacity, 0), this.bg.style.opacity = this.bgOpacity * this.options.bgOpacity
            }
            mouseDetected() {
                this.hasMouse || (this.hasMouse = !0, this.template.classList.add("pswp--has_mouse"))
            }
            _handlePageResize() {
                this.updateSize(), /iPhone|iPad|iPod/i.test(window.navigator.userAgent) && setTimeout(() => {
                    this.updateSize()
                }, 500)
            }
            _updatePageScrollOffset() {
                this.setScrollOffset(0, window.pageYOffset)
            }
            setScrollOffset(x, y) {
                this.offset.x = x, this.offset.y = y, this.dispatch("updateScrollOffset")
            }
            _createMainStructure() {
                this.template = photoswipe_esm_createElement("pswp"), this.template.setAttribute("tabindex", -1), this.template.setAttribute("role", "dialog"), this.bg = photoswipe_esm_createElement("pswp__bg", !1, this.template), this.scrollWrap = photoswipe_esm_createElement("pswp__scroll-wrap", !1, this.template), this.container = photoswipe_esm_createElement("pswp__container", !1, this.scrollWrap), this.mainScroll.appendHolders(), this.ui = new UI(this), this.ui.init(), (this.options.appendToEl || document.body).appendChild(this.template)
            }
            getThumbBounds() {
                return function (index, itemData, instance) {
                    const event = instance.dispatch("thumbBounds", {
                        index: index,
                        itemData: itemData,
                        instance: instance
                    });
                    if (event.thumbBounds) return event.thumbBounds;
                    const {
                        element: element
                    } = itemData;
                    let thumbBounds;
                    if (element && !1 !== instance.options.thumbSelector) {
                        const thumbSelector = instance.options.thumbSelector || "img",
                            thumbnail = element.matches(thumbSelector) ? element : element.querySelector(thumbSelector);
                        thumbnail && (thumbBounds = itemData.thumbCropped ? function (el, imageWidth, imageHeight) {
                            const thumbAreaRect = el.getBoundingClientRect(),
                                hRatio = thumbAreaRect.width / imageWidth,
                                vRatio = thumbAreaRect.height / imageHeight,
                                fillZoomLevel = hRatio > vRatio ? hRatio : vRatio,
                                offsetX = (thumbAreaRect.width - imageWidth * fillZoomLevel) / 2,
                                offsetY = (thumbAreaRect.height - imageHeight * fillZoomLevel) / 2,
                                bounds = {
                                    x: thumbAreaRect.left + offsetX,
                                    y: thumbAreaRect.top + offsetY,
                                    w: imageWidth * fillZoomLevel
                                };
                            return bounds.innerRect = {
                                w: thumbAreaRect.width,
                                h: thumbAreaRect.height,
                                x: offsetX,
                                y: offsetY
                            }, bounds
                        }(thumbnail, itemData.w, itemData.h) : function (el) {
                            const thumbAreaRect = el.getBoundingClientRect();
                            return {
                                x: thumbAreaRect.left,
                                y: thumbAreaRect.top,
                                w: thumbAreaRect.width
                            }
                        }(thumbnail))
                    }
                    return instance.applyFilters("thumbBounds", thumbBounds, itemData, index)
                }(this.currIndex, this.currSlide ? this.currSlide.data : this._initialItemData, this)
            }
            _prepareOptions(options) {
                window.matchMedia("(prefers-reduced-motion), (update: slow)").matches && (options.showHideAnimationType = "none", options.zoomAnimationDuration = 0), this.options = {
                    ...photoswipe_esm_defaultOptions,
                    ...options
                }
            }
        }
    }).init();
    var enums_top = "top",
        enums_bottom = "bottom",
        enums_right = "right",
        enums_left = "left",
        basePlacements = [enums_top, enums_bottom, enums_right, enums_left],
        variationPlacements = basePlacements.reduce((function (acc, placement) {
            return acc.concat([placement + "-start", placement + "-end"])
        }), []),
        enums_placements = [].concat(basePlacements, ["auto"]).reduce((function (acc, placement) {
            return acc.concat([placement, placement + "-start", placement + "-end"])
        }), []),
        modifierPhases = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];

    function order(modifiers) {
        var map = new Map,
            visited = new Set,
            result = [];
        return modifiers.forEach((function (modifier) {
            map.set(modifier.name, modifier)
        })), modifiers.forEach((function (modifier) {
            visited.has(modifier.name) || function sort(modifier) {
                visited.add(modifier.name), [].concat(modifier.requires || [], modifier.requiresIfExists || []).forEach((function (dep) {
                    if (!visited.has(dep)) {
                        var depModifier = map.get(dep);
                        depModifier && sort(depModifier)
                    }
                })), result.push(modifier)
            }(modifier)
        })), result
    }
    var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];

    function getBasePlacement(placement) {
        return placement.split("-")[0]
    }
    var DEFAULT_OPTIONS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };

    function areValidElements() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return !args.some((function (element) {
            return !(element && "function" == typeof element.getBoundingClientRect)
        }))
    }

    function popperGenerator(generatorOptions) {
        void 0 === generatorOptions && (generatorOptions = {});
        var _generatorOptions = generatorOptions,
            _generatorOptions$def = _generatorOptions.defaultModifiers,
            defaultModifiers = void 0 === _generatorOptions$def ? [] : _generatorOptions$def,
            _generatorOptions$def2 = _generatorOptions.defaultOptions,
            defaultOptions = void 0 === _generatorOptions$def2 ? DEFAULT_OPTIONS : _generatorOptions$def2;
        return function (reference, popper, options) {
            void 0 === options && (options = defaultOptions);
            var fn, pending, state = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
                modifiersData: {},
                elements: {
                    reference: reference,
                    popper: popper
                },
                attributes: {},
                styles: {}
            },
                effectCleanupFns = [],
                isDestroyed = !1,
                instance = {
                    state: state,
                    setOptions: function (setOptionsAction) {
                        var options = "function" == typeof setOptionsAction ? setOptionsAction(state.options) : setOptionsAction;
                        cleanupModifierEffects(), state.options = Object.assign({}, defaultOptions, state.options, options), state.scrollParents = {
                            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                            popper: listScrollParents(popper)
                        };
                        var orderedModifiers = function (modifiers) {
                            var orderedModifiers = order(modifiers);
                            return modifierPhases.reduce((function (acc, phase) {
                                return acc.concat(orderedModifiers.filter((function (modifier) {
                                    return modifier.phase === phase
                                })))
                            }), [])
                        }(function (modifiers) {
                            var merged = modifiers.reduce((function (merged, current) {
                                var existing = merged[current.name];
                                return merged[current.name] = existing ? Object.assign({}, existing, current, {
                                    options: Object.assign({}, existing.options, current.options),
                                    data: Object.assign({}, existing.data, current.data)
                                }) : current, merged
                            }), {});
                            return Object.keys(merged).map((function (key) {
                                return merged[key]
                            }))
                        }([].concat(defaultModifiers, state.options.modifiers)));
                        if (state.orderedModifiers = orderedModifiers.filter((function (m) {
                            return m.enabled
                        })), function (modifiers) {
                            modifiers.forEach((function (modifier) {
                                [].concat(Object.keys(modifier), VALID_PROPERTIES).filter((function (value, index, self) {
                                    return self.indexOf(value) === index
                                })).forEach((function (key) {
                                    switch (key) {
                                        case "name":
                                            modifier.name;
                                            break;
                                        case "enabled":
                                            modifier.enabled;
                                            break;
                                        case "phase":
                                            modifierPhases.indexOf(modifier.phase);
                                            break;
                                        case "fn":
                                            modifier.fn;
                                            break;
                                        case "effect":
                                            null != modifier.effect && modifier.effect;
                                            break;
                                        case "requires":
                                            null != modifier.requires && Array.isArray(modifier.requires);
                                            break;
                                        case "requiresIfExists":
                                            Array.isArray(modifier.requiresIfExists)
                                    }
                                    modifier.requires && modifier.requires.forEach((function (requirement) {
                                        modifiers.find((function (mod) {
                                            return mod.name === requirement
                                        }))
                                    }))
                                }))
                            }))
                        }((arr = [].concat(orderedModifiers, state.options.modifiers), fn = function (_ref) {
                            return _ref.name
                        }, identifiers = new Set, arr.filter((function (item) {
                            var identifier = fn(item);
                            if (!identifiers.has(identifier)) return identifiers.add(identifier), !0
                        })))), "auto" === getBasePlacement(state.options.placement)) state.orderedModifiers.find((function (_ref2) {
                            return "flip" === _ref2.name
                        }));
                        var arr, fn, identifiers, _getComputedStyle = getComputedStyle_getComputedStyle(popper);
                        return [_getComputedStyle.marginTop, _getComputedStyle.marginRight, _getComputedStyle.marginBottom, _getComputedStyle.marginLeft].some((function (margin) {
                            return parseFloat(margin)
                        })), state.orderedModifiers.forEach((function (_ref3) {
                            var name = _ref3.name,
                                _ref3$options = _ref3.options,
                                options = void 0 === _ref3$options ? {} : _ref3$options,
                                effect = _ref3.effect;
                            if ("function" == typeof effect) {
                                var cleanupFn = effect({
                                    state: state,
                                    name: name,
                                    instance: instance,
                                    options: options
                                });
                                effectCleanupFns.push(cleanupFn || function () { })
                            }
                        })), instance.update()
                    },
                    forceUpdate: function () {
                        if (!isDestroyed) {
                            var _state$elements = state.elements,
                                reference = _state$elements.reference,
                                popper = _state$elements.popper;
                            if (areValidElements(reference, popper)) {
                                state.rects = {
                                    reference: getCompositeRect(reference, getOffsetParent(popper), "fixed" === state.options.strategy),
                                    popper: getLayoutRect(popper)
                                }, state.reset = !1, state.placement = state.options.placement, state.orderedModifiers.forEach((function (modifier) {
                                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data)
                                }));
                                for (var __debug_loops__ = 0, index = 0; index < state.orderedModifiers.length && !((__debug_loops__ += 1) > 100); index++)
                                    if (!0 !== state.reset) {
                                        var _state$orderedModifie = state.orderedModifiers[index],
                                            fn = _state$orderedModifie.fn,
                                            _state$orderedModifie2 = _state$orderedModifie.options,
                                            _options = void 0 === _state$orderedModifie2 ? {} : _state$orderedModifie2,
                                            name = _state$orderedModifie.name;
                                        "function" == typeof fn && (state = fn({
                                            state: state,
                                            options: _options,
                                            name: name,
                                            instance: instance
                                        }) || state)
                                    } else state.reset = !1, index = -1
                            }
                        }
                    },
                    update: (fn = function () {
                        return new Promise((function (resolve) {
                            instance.forceUpdate(), resolve(state)
                        }))
                    }, function () {
                        return pending || (pending = new Promise((function (resolve) {
                            Promise.resolve().then((function () {
                                pending = void 0, resolve(fn())
                            }))
                        }))), pending
                    }),
                    destroy: function () {
                        cleanupModifierEffects(), isDestroyed = !0
                    }
                };
            if (!areValidElements(reference, popper)) return instance;

            function cleanupModifierEffects() {
                effectCleanupFns.forEach((function (fn) {
                    return fn()
                })), effectCleanupFns = []
            }
            return instance.setOptions(options).then((function (state) {
                !isDestroyed && options.onFirstUpdate && options.onFirstUpdate(state)
            })), instance
        }
    }
    var passive = {
        passive: !0
    };
    var eventListeners = {
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: function () { },
        effect: function (_ref) {
            var state = _ref.state,
                instance = _ref.instance,
                options = _ref.options,
                _options$scroll = options.scroll,
                scroll = void 0 === _options$scroll || _options$scroll,
                _options$resize = options.resize,
                resize = void 0 === _options$resize || _options$resize,
                window = getWindow_getWindow(state.elements.popper),
                scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
            return scroll && scrollParents.forEach((function (scrollParent) {
                scrollParent.addEventListener("scroll", instance.update, passive)
            })), resize && window.addEventListener("resize", instance.update, passive),
                function () {
                    scroll && scrollParents.forEach((function (scrollParent) {
                        scrollParent.removeEventListener("scroll", instance.update, passive)
                    })), resize && window.removeEventListener("resize", instance.update, passive)
                }
        },
        data: {}
    };

    function getVariation(placement) {
        return placement.split("-")[1]
    }

    function getMainAxisFromPlacement(placement) {
        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y"
    }

    function computeOffsets(_ref) {
        var offsets, reference = _ref.reference,
            element = _ref.element,
            placement = _ref.placement,
            basePlacement = placement ? getBasePlacement(placement) : null,
            variation = placement ? getVariation(placement) : null,
            commonX = reference.x + reference.width / 2 - element.width / 2,
            commonY = reference.y + reference.height / 2 - element.height / 2;
        switch (basePlacement) {
            case enums_top:
                offsets = {
                    x: commonX,
                    y: reference.y - element.height
                };
                break;
            case enums_bottom:
                offsets = {
                    x: commonX,
                    y: reference.y + reference.height
                };
                break;
            case enums_right:
                offsets = {
                    x: reference.x + reference.width,
                    y: commonY
                };
                break;
            case enums_left:
                offsets = {
                    x: reference.x - element.width,
                    y: commonY
                };
                break;
            default:
                offsets = {
                    x: reference.x,
                    y: reference.y
                }
        }
        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
        if (null != mainAxis) {
            var len = "y" === mainAxis ? "height" : "width";
            switch (variation) {
                case "start":
                    offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                    break;
                case "end":
                    offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2)
            }
        }
        return offsets
    }
    var modifiers_popperOffsets = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: function (_ref) {
            var state = _ref.state,
                name = _ref.name;
            state.modifiersData[name] = computeOffsets({
                reference: state.rects.reference,
                element: state.rects.popper,
                strategy: "absolute",
                placement: state.placement
            })
        },
        data: {}
    },
        math_max = Math.max,
        math_min = Math.min,
        math_round = Math.round,
        unsetSides = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };

    function mapToStyles(_ref2) {
        var _Object$assign2, popper = _ref2.popper,
            popperRect = _ref2.popperRect,
            placement = _ref2.placement,
            variation = _ref2.variation,
            offsets = _ref2.offsets,
            position = _ref2.position,
            gpuAcceleration = _ref2.gpuAcceleration,
            adaptive = _ref2.adaptive,
            roundOffsets = _ref2.roundOffsets,
            _ref3 = !0 === roundOffsets ? function (_ref) {
                var x = _ref.x,
                    y = _ref.y,
                    dpr = window.devicePixelRatio || 1;
                return {
                    x: math_round(math_round(x * dpr) / dpr) || 0,
                    y: math_round(math_round(y * dpr) / dpr) || 0
                }
            }(offsets) : "function" == typeof roundOffsets ? roundOffsets(offsets) : offsets,
            _ref3$x = _ref3.x,
            x = void 0 === _ref3$x ? 0 : _ref3$x,
            _ref3$y = _ref3.y,
            y = void 0 === _ref3$y ? 0 : _ref3$y,
            hasX = offsets.hasOwnProperty("x"),
            hasY = offsets.hasOwnProperty("y"),
            sideX = enums_left,
            sideY = enums_top,
            win = window;
        if (adaptive) {
            var offsetParent = getOffsetParent(popper),
                heightProp = "clientHeight",
                widthProp = "clientWidth";
            offsetParent === getWindow_getWindow(popper) && "static" !== getComputedStyle_getComputedStyle(offsetParent = getDocumentElement(popper)).position && "absolute" === position && (heightProp = "scrollHeight", widthProp = "scrollWidth"), offsetParent = offsetParent, placement !== enums_top && (placement !== enums_left && placement !== enums_right || "end" !== variation) || (sideY = enums_bottom, y -= offsetParent[heightProp] - popperRect.height, y *= gpuAcceleration ? 1 : -1), placement !== enums_left && (placement !== enums_top && placement !== enums_bottom || "end" !== variation) || (sideX = enums_right, x -= offsetParent[widthProp] - popperRect.width, x *= gpuAcceleration ? 1 : -1)
        }
        var _Object$assign, commonStyles = Object.assign({
            position: position
        }, adaptive && unsetSides);
        return gpuAcceleration ? Object.assign({}, commonStyles, ((_Object$assign = {})[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign)) : Object.assign({}, commonStyles, ((_Object$assign2 = {})[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2))
    }
    var modifiers_applyStyles = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: function (_ref) {
            var state = _ref.state;
            Object.keys(state.elements).forEach((function (name) {
                var style = state.styles[name] || {},
                    attributes = state.attributes[name] || {},
                    element = state.elements[name];
                isHTMLElement(element) && getNodeName(element) && (Object.assign(element.style, style), Object.keys(attributes).forEach((function (name) {
                    var value = attributes[name];
                    !1 === value ? element.removeAttribute(name) : element.setAttribute(name, !0 === value ? "" : value)
                })))
            }))
        },
        effect: function (_ref2) {
            var state = _ref2.state,
                initialStyles = {
                    popper: {
                        position: state.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
            return Object.assign(state.elements.popper.style, initialStyles.popper), state.styles = initialStyles, state.elements.arrow && Object.assign(state.elements.arrow.style, initialStyles.arrow),
                function () {
                    Object.keys(state.elements).forEach((function (name) {
                        var element = state.elements[name],
                            attributes = state.attributes[name] || {},
                            style = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]).reduce((function (style, property) {
                                return style[property] = "", style
                            }), {});
                        isHTMLElement(element) && getNodeName(element) && (Object.assign(element.style, style), Object.keys(attributes).forEach((function (attribute) {
                            element.removeAttribute(attribute)
                        })))
                    }))
                }
        },
        requires: ["computeStyles"]
    };
    var getOppositePlacement_hash = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };

    function getOppositePlacement(placement) {
        return placement.replace(/left|right|bottom|top/g, (function (matched) {
            return getOppositePlacement_hash[matched]
        }))
    }
    var getOppositeVariationPlacement_hash = {
        start: "end",
        end: "start"
    };

    function getOppositeVariationPlacement(placement) {
        return placement.replace(/start|end/g, (function (matched) {
            return getOppositeVariationPlacement_hash[matched]
        }))
    }

    function contains(parent, child) {
        var rootNode = child.getRootNode && child.getRootNode();
        if (parent.contains(child)) return !0;
        if (rootNode && isShadowRoot(rootNode)) {
            var next = child;
            do {
                if (next && parent.isSameNode(next)) return !0;
                next = next.parentNode || next.host
            } while (next)
        }
        return !1
    }

    function rectToClientRect(rect) {
        return Object.assign({}, rect, {
            left: rect.x,
            top: rect.y,
            right: rect.x + rect.width,
            bottom: rect.y + rect.height
        })
    }

    function getClientRectFromMixedType(element, clippingParent) {
        return "viewport" === clippingParent ? rectToClientRect(function (element) {
            var win = getWindow_getWindow(element),
                html = getDocumentElement(element),
                visualViewport = win.visualViewport,
                width = html.clientWidth,
                height = html.clientHeight,
                x = 0,
                y = 0;
            return visualViewport && (width = visualViewport.width, height = visualViewport.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (x = visualViewport.offsetLeft, y = visualViewport.offsetTop)), {
                width: width,
                height: height,
                x: x + getWindowScrollBarX(element),
                y: y
            }
        }(element)) : isHTMLElement(clippingParent) ? function (element) {
            var rect = getBoundingClientRect(element);
            return rect.top = rect.top + element.clientTop, rect.left = rect.left + element.clientLeft, rect.bottom = rect.top + element.clientHeight, rect.right = rect.left + element.clientWidth, rect.width = element.clientWidth, rect.height = element.clientHeight, rect.x = rect.left, rect.y = rect.top, rect
        }(clippingParent) : rectToClientRect(function (element) {
            var _element$ownerDocumen, html = getDocumentElement(element),
                winScroll = getWindowScroll(element),
                body = null == (_element$ownerDocumen = element.ownerDocument) ? void 0 : _element$ownerDocumen.body,
                width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0),
                height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0),
                x = -winScroll.scrollLeft + getWindowScrollBarX(element),
                y = -winScroll.scrollTop;
            return "rtl" === getComputedStyle_getComputedStyle(body || html).direction && (x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width), {
                width: width,
                height: height,
                x: x,
                y: y
            }
        }(getDocumentElement(element)))
    }

    function getClippingRect(element, boundary, rootBoundary) {
        var mainClippingParents = "clippingParents" === boundary ? function (element) {
            var clippingParents = listScrollParents(getParentNode(element)),
                clipperElement = ["absolute", "fixed"].indexOf(getComputedStyle_getComputedStyle(element).position) >= 0 && isHTMLElement(element) ? getOffsetParent(element) : element;
            return isElement(clipperElement) ? clippingParents.filter((function (clippingParent) {
                return isElement(clippingParent) && contains(clippingParent, clipperElement) && "body" !== getNodeName(clippingParent)
            })) : []
        }(element) : [].concat(boundary),
            clippingParents = [].concat(mainClippingParents, [rootBoundary]),
            firstClippingParent = clippingParents[0],
            clippingRect = clippingParents.reduce((function (accRect, clippingParent) {
                var rect = getClientRectFromMixedType(element, clippingParent);
                return accRect.top = math_max(rect.top, accRect.top), accRect.right = math_min(rect.right, accRect.right), accRect.bottom = math_min(rect.bottom, accRect.bottom), accRect.left = math_max(rect.left, accRect.left), accRect
            }), getClientRectFromMixedType(element, firstClippingParent));
        return clippingRect.width = clippingRect.right - clippingRect.left, clippingRect.height = clippingRect.bottom - clippingRect.top, clippingRect.x = clippingRect.left, clippingRect.y = clippingRect.top, clippingRect
    }

    function mergePaddingObject(paddingObject) {
        return Object.assign({}, {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, paddingObject)
    }

    function expandToHashMap(value, keys) {
        return keys.reduce((function (hashMap, key) {
            return hashMap[key] = value, hashMap
        }), {})
    }

    function detectOverflow(state, options) {
        void 0 === options && (options = {});
        var _options = options,
            _options$placement = _options.placement,
            placement = void 0 === _options$placement ? state.placement : _options$placement,
            _options$boundary = _options.boundary,
            boundary = void 0 === _options$boundary ? "clippingParents" : _options$boundary,
            _options$rootBoundary = _options.rootBoundary,
            rootBoundary = void 0 === _options$rootBoundary ? "viewport" : _options$rootBoundary,
            _options$elementConte = _options.elementContext,
            elementContext = void 0 === _options$elementConte ? "popper" : _options$elementConte,
            _options$altBoundary = _options.altBoundary,
            altBoundary = void 0 !== _options$altBoundary && _options$altBoundary,
            _options$padding = _options.padding,
            padding = void 0 === _options$padding ? 0 : _options$padding,
            paddingObject = mergePaddingObject("number" != typeof padding ? padding : expandToHashMap(padding, basePlacements)),
            altContext = "popper" === elementContext ? "reference" : "popper",
            popperRect = state.rects.popper,
            element = state.elements[altBoundary ? altContext : elementContext],
            clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary),
            referenceClientRect = getBoundingClientRect(state.elements.reference),
            popperOffsets = computeOffsets({
                reference: referenceClientRect,
                element: popperRect,
                strategy: "absolute",
                placement: placement
            }),
            popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets)),
            elementClientRect = "popper" === elementContext ? popperClientRect : referenceClientRect,
            overflowOffsets = {
                top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
                bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
                left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
                right: elementClientRect.right - clippingClientRect.right + paddingObject.right
            },
            offsetData = state.modifiersData.offset;
        if ("popper" === elementContext && offsetData) {
            var offset = offsetData[placement];
            Object.keys(overflowOffsets).forEach((function (key) {
                var multiply = [enums_right, enums_bottom].indexOf(key) >= 0 ? 1 : -1,
                    axis = [enums_top, enums_bottom].indexOf(key) >= 0 ? "y" : "x";
                overflowOffsets[key] += offset[axis] * multiply
            }))
        }
        return overflowOffsets
    }

    function within(min, value, max) {
        return math_max(min, math_min(value, max))
    }

    function getSideOffsets(overflow, rect, preventedOffsets) {
        return void 0 === preventedOffsets && (preventedOffsets = {
            x: 0,
            y: 0
        }), {
            top: overflow.top - rect.height - preventedOffsets.y,
            right: overflow.right - rect.width + preventedOffsets.x,
            bottom: overflow.bottom - rect.height + preventedOffsets.y,
            left: overflow.left - rect.width - preventedOffsets.x
        }
    }

    function isAnySideFullyClipped(overflow) {
        return [enums_top, enums_right, enums_bottom, enums_left].some((function (side) {
            return overflow[side] >= 0
        }))
    }
    var popper_createPopper = popperGenerator({
        defaultModifiers: [eventListeners, modifiers_popperOffsets, {
            name: "computeStyles",
            enabled: !0,
            phase: "beforeWrite",
            fn: function (_ref4) {
                var state = _ref4.state,
                    options = _ref4.options,
                    _options$gpuAccelerat = options.gpuAcceleration,
                    gpuAcceleration = void 0 === _options$gpuAccelerat || _options$gpuAccelerat,
                    _options$adaptive = options.adaptive,
                    adaptive = void 0 === _options$adaptive || _options$adaptive,
                    _options$roundOffsets = options.roundOffsets,
                    roundOffsets = void 0 === _options$roundOffsets || _options$roundOffsets,
                    transitionProperty = getComputedStyle_getComputedStyle(state.elements.popper).transitionProperty || "";
                adaptive && ["transform", "top", "right", "bottom", "left"].some((function (property) {
                    return transitionProperty.indexOf(property) >= 0
                }));
                var commonStyles = {
                    placement: getBasePlacement(state.placement),
                    variation: getVariation(state.placement),
                    popper: state.elements.popper,
                    popperRect: state.rects.popper,
                    gpuAcceleration: gpuAcceleration
                };
                null != state.modifiersData.popperOffsets && (state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
                    offsets: state.modifiersData.popperOffsets,
                    position: state.options.strategy,
                    adaptive: adaptive,
                    roundOffsets: roundOffsets
                })))), null != state.modifiersData.arrow && (state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
                    offsets: state.modifiersData.arrow,
                    position: "absolute",
                    adaptive: !1,
                    roundOffsets: roundOffsets
                })))), state.attributes.popper = Object.assign({}, state.attributes.popper, {
                    "data-popper-placement": state.placement
                })
            },
            data: {}
        }, modifiers_applyStyles, {
                name: "offset",
                enabled: !0,
                phase: "main",
                requires: ["popperOffsets"],
                fn: function (_ref2) {
                    var state = _ref2.state,
                        options = _ref2.options,
                        name = _ref2.name,
                        _options$offset = options.offset,
                        offset = void 0 === _options$offset ? [0, 0] : _options$offset,
                        data = enums_placements.reduce((function (acc, placement) {
                            return acc[placement] = function (placement, rects, offset) {
                                var basePlacement = getBasePlacement(placement),
                                    invertDistance = [enums_left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1,
                                    _ref = "function" == typeof offset ? offset(Object.assign({}, rects, {
                                        placement: placement
                                    })) : offset,
                                    skidding = _ref[0],
                                    distance = _ref[1];
                                return skidding = skidding || 0, distance = (distance || 0) * invertDistance, [enums_left, enums_right].indexOf(basePlacement) >= 0 ? {
                                    x: distance,
                                    y: skidding
                                } : {
                                    x: skidding,
                                    y: distance
                                }
                            }(placement, state.rects, offset), acc
                        }), {}),
                        _data$state$placement = data[state.placement],
                        x = _data$state$placement.x,
                        y = _data$state$placement.y;
                    null != state.modifiersData.popperOffsets && (state.modifiersData.popperOffsets.x += x, state.modifiersData.popperOffsets.y += y), state.modifiersData[name] = data
                }
            }, {
                name: "flip",
                enabled: !0,
                phase: "main",
                fn: function (_ref) {
                    var state = _ref.state,
                        options = _ref.options,
                        name = _ref.name;
                    if (!state.modifiersData[name]._skip) {
                        for (var _options$mainAxis = options.mainAxis, checkMainAxis = void 0 === _options$mainAxis || _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = void 0 === _options$altAxis || _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = void 0 === _options$flipVariatio || _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements, preferredPlacement = state.options.placement, basePlacement = getBasePlacement(preferredPlacement), fallbackPlacements = specifiedFallbackPlacements || (basePlacement === preferredPlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : function (placement) {
                            if ("auto" === getBasePlacement(placement)) return [];
                            var oppositePlacement = getOppositePlacement(placement);
                            return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)]
                        }(preferredPlacement)), placements = [preferredPlacement].concat(fallbackPlacements).reduce((function (acc, placement) {
                            return acc.concat("auto" === getBasePlacement(placement) ? function (state, options) {
                                void 0 === options && (options = {});
                                var _options = options,
                                    placement = _options.placement,
                                    boundary = _options.boundary,
                                    rootBoundary = _options.rootBoundary,
                                    padding = _options.padding,
                                    flipVariations = _options.flipVariations,
                                    _options$allowedAutoP = _options.allowedAutoPlacements,
                                    allowedAutoPlacements = void 0 === _options$allowedAutoP ? enums_placements : _options$allowedAutoP,
                                    variation = getVariation(placement),
                                    placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter((function (placement) {
                                        return getVariation(placement) === variation
                                    })) : basePlacements,
                                    allowedPlacements = placements.filter((function (placement) {
                                        return allowedAutoPlacements.indexOf(placement) >= 0
                                    }));
                                0 === allowedPlacements.length && (allowedPlacements = placements);
                                var overflows = allowedPlacements.reduce((function (acc, placement) {
                                    return acc[placement] = detectOverflow(state, {
                                        placement: placement,
                                        boundary: boundary,
                                        rootBoundary: rootBoundary,
                                        padding: padding
                                    })[getBasePlacement(placement)], acc
                                }), {});
                                return Object.keys(overflows).sort((function (a, b) {
                                    return overflows[a] - overflows[b]
                                }))
                            }(state, {
                                placement: placement,
                                boundary: boundary,
                                rootBoundary: rootBoundary,
                                padding: padding,
                                flipVariations: flipVariations,
                                allowedAutoPlacements: allowedAutoPlacements
                            }) : placement)
                        }), []), referenceRect = state.rects.reference, popperRect = state.rects.popper, checksMap = new Map, makeFallbackChecks = !0, firstFittingPlacement = placements[0], i = 0; i < placements.length; i++) {
                            var placement = placements[i],
                                _basePlacement = getBasePlacement(placement),
                                isStartVariation = "start" === getVariation(placement),
                                isVertical = [enums_top, enums_bottom].indexOf(_basePlacement) >= 0,
                                len = isVertical ? "width" : "height",
                                overflow = detectOverflow(state, {
                                    placement: placement,
                                    boundary: boundary,
                                    rootBoundary: rootBoundary,
                                    altBoundary: altBoundary,
                                    padding: padding
                                }),
                                mainVariationSide = isVertical ? isStartVariation ? enums_right : enums_left : isStartVariation ? enums_bottom : enums_top;
                            referenceRect[len] > popperRect[len] && (mainVariationSide = getOppositePlacement(mainVariationSide));
                            var altVariationSide = getOppositePlacement(mainVariationSide),
                                checks = [];
                            if (checkMainAxis && checks.push(overflow[_basePlacement] <= 0), checkAltAxis && checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0), checks.every((function (check) {
                                return check
                            }))) {
                                firstFittingPlacement = placement, makeFallbackChecks = !1;
                                break
                            }
                            checksMap.set(placement, checks)
                        }
                        if (makeFallbackChecks)
                            for (var _loop = function (_i) {
                                var fittingPlacement = placements.find((function (placement) {
                                    var checks = checksMap.get(placement);
                                    if (checks) return checks.slice(0, _i).every((function (check) {
                                        return check
                                    }))
                                }));
                                if (fittingPlacement) return firstFittingPlacement = fittingPlacement, "break"
                            }, _i = flipVariations ? 3 : 1; _i > 0; _i--) {
                                if ("break" === _loop(_i)) break
                            }
                        state.placement !== firstFittingPlacement && (state.modifiersData[name]._skip = !0, state.placement = firstFittingPlacement, state.reset = !0)
                    }
                },
                requiresIfExists: ["offset"],
                data: {
                    _skip: !1
                }
            }, {
                name: "preventOverflow",
                enabled: !0,
                phase: "main",
                fn: function (_ref) {
                    var state = _ref.state,
                        options = _ref.options,
                        name = _ref.name,
                        _options$mainAxis = options.mainAxis,
                        checkMainAxis = void 0 === _options$mainAxis || _options$mainAxis,
                        _options$altAxis = options.altAxis,
                        checkAltAxis = void 0 !== _options$altAxis && _options$altAxis,
                        boundary = options.boundary,
                        rootBoundary = options.rootBoundary,
                        altBoundary = options.altBoundary,
                        padding = options.padding,
                        _options$tether = options.tether,
                        tether = void 0 === _options$tether || _options$tether,
                        _options$tetherOffset = options.tetherOffset,
                        tetherOffset = void 0 === _options$tetherOffset ? 0 : _options$tetherOffset,
                        overflow = detectOverflow(state, {
                            boundary: boundary,
                            rootBoundary: rootBoundary,
                            padding: padding,
                            altBoundary: altBoundary
                        }),
                        basePlacement = getBasePlacement(state.placement),
                        variation = getVariation(state.placement),
                        isBasePlacement = !variation,
                        mainAxis = getMainAxisFromPlacement(basePlacement),
                        altAxis = "x" === mainAxis ? "y" : "x",
                        popperOffsets = state.modifiersData.popperOffsets,
                        referenceRect = state.rects.reference,
                        popperRect = state.rects.popper,
                        tetherOffsetValue = "function" == typeof tetherOffset ? tetherOffset(Object.assign({}, state.rects, {
                            placement: state.placement
                        })) : tetherOffset,
                        data = {
                            x: 0,
                            y: 0
                        };
                    if (popperOffsets) {
                        if (checkMainAxis || checkAltAxis) {
                            var mainSide = "y" === mainAxis ? enums_top : enums_left,
                                altSide = "y" === mainAxis ? enums_bottom : enums_right,
                                len = "y" === mainAxis ? "height" : "width",
                                offset = popperOffsets[mainAxis],
                                min = popperOffsets[mainAxis] + overflow[mainSide],
                                max = popperOffsets[mainAxis] - overflow[altSide],
                                additive = tether ? -popperRect[len] / 2 : 0,
                                minLen = "start" === variation ? referenceRect[len] : popperRect[len],
                                maxLen = "start" === variation ? -popperRect[len] : -referenceRect[len],
                                arrowElement = state.elements.arrow,
                                arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                                    width: 0,
                                    height: 0
                                },
                                arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : {
                                    top: 0,
                                    right: 0,
                                    bottom: 0,
                                    left: 0
                                },
                                arrowPaddingMin = arrowPaddingObject[mainSide],
                                arrowPaddingMax = arrowPaddingObject[altSide],
                                arrowLen = within(0, referenceRect[len], arrowRect[len]),
                                minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue,
                                maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue,
                                arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow),
                                clientOffset = arrowOffsetParent ? "y" === mainAxis ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0,
                                offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0,
                                tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset,
                                tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
                            if (checkMainAxis) {
                                var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);
                                popperOffsets[mainAxis] = preventedOffset, data[mainAxis] = preventedOffset - offset
                            }
                            if (checkAltAxis) {
                                var _mainSide = "x" === mainAxis ? enums_top : enums_left,
                                    _altSide = "x" === mainAxis ? enums_bottom : enums_right,
                                    _offset = popperOffsets[altAxis],
                                    _min = _offset + overflow[_mainSide],
                                    _max = _offset - overflow[_altSide],
                                    _preventedOffset = within(tether ? math_min(_min, tetherMin) : _min, _offset, tether ? math_max(_max, tetherMax) : _max);
                                popperOffsets[altAxis] = _preventedOffset, data[altAxis] = _preventedOffset - _offset
                            }
                        }
                        state.modifiersData[name] = data
                    }
                },
                requiresIfExists: ["offset"]
            }, {
                name: "arrow",
                enabled: !0,
                phase: "main",
                fn: function (_ref) {
                    var _state$modifiersData$, state = _ref.state,
                        name = _ref.name,
                        options = _ref.options,
                        arrowElement = state.elements.arrow,
                        popperOffsets = state.modifiersData.popperOffsets,
                        basePlacement = getBasePlacement(state.placement),
                        axis = getMainAxisFromPlacement(basePlacement),
                        len = [enums_left, enums_right].indexOf(basePlacement) >= 0 ? "height" : "width";
                    if (arrowElement && popperOffsets) {
                        var paddingObject = function (padding, state) {
                            return mergePaddingObject("number" != typeof (padding = "function" == typeof padding ? padding(Object.assign({}, state.rects, {
                                placement: state.placement
                            })) : padding) ? padding : expandToHashMap(padding, basePlacements))
                        }(options.padding, state),
                            arrowRect = getLayoutRect(arrowElement),
                            minProp = "y" === axis ? enums_top : enums_left,
                            maxProp = "y" === axis ? enums_bottom : enums_right,
                            endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len],
                            startDiff = popperOffsets[axis] - state.rects.reference[axis],
                            arrowOffsetParent = getOffsetParent(arrowElement),
                            clientSize = arrowOffsetParent ? "y" === axis ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0,
                            centerToReference = endDiff / 2 - startDiff / 2,
                            min = paddingObject[minProp],
                            max = clientSize - arrowRect[len] - paddingObject[maxProp],
                            center = clientSize / 2 - arrowRect[len] / 2 + centerToReference,
                            offset = within(min, center, max),
                            axisProp = axis;
                        state.modifiersData[name] = ((_state$modifiersData$ = {})[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$)
                    }
                },
                effect: function (_ref2) {
                    var state = _ref2.state,
                        _options$element = _ref2.options.element,
                        arrowElement = void 0 === _options$element ? "[data-popper-arrow]" : _options$element;
                    null != arrowElement && ("string" != typeof arrowElement || (arrowElement = state.elements.popper.querySelector(arrowElement))) && (isHTMLElement(arrowElement), contains(state.elements.popper, arrowElement) && (state.elements.arrow = arrowElement))
                },
                requires: ["popperOffsets"],
                requiresIfExists: ["preventOverflow"]
            }, {
                name: "hide",
                enabled: !0,
                phase: "main",
                requiresIfExists: ["preventOverflow"],
                fn: function (_ref) {
                    var state = _ref.state,
                        name = _ref.name,
                        referenceRect = state.rects.reference,
                        popperRect = state.rects.popper,
                        preventedOffsets = state.modifiersData.preventOverflow,
                        referenceOverflow = detectOverflow(state, {
                            elementContext: "reference"
                        }),
                        popperAltOverflow = detectOverflow(state, {
                            altBoundary: !0
                        }),
                        referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect),
                        popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets),
                        isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets),
                        hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
                    state.modifiersData[name] = {
                        referenceClippingOffsets: referenceClippingOffsets,
                        popperEscapeOffsets: popperEscapeOffsets,
                        isReferenceHidden: isReferenceHidden,
                        hasPopperEscaped: hasPopperEscaped
                    }, state.attributes.popper = Object.assign({}, state.attributes.popper, {
                        "data-popper-reference-hidden": isReferenceHidden,
                        "data-popper-escaped": hasPopperEscaped
                    })
                }
            }]
    }),
        TOUCH_OPTIONS = {
            passive: !0,
            capture: !0
        },
        TIPPY_DEFAULT_APPEND_TO = function () {
            return document.body
        };

    function getValueAtIndexOrReturn(value, index, defaultValue) {
        if (Array.isArray(value)) {
            var v = value[index];
            return null == v ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v
        }
        return value
    }

    function isType(value, type) {
        var str = {}.toString.call(value);
        return 0 === str.indexOf("[object") && str.indexOf(type + "]") > -1
    }

    function invokeWithArgsOrReturn(value, args) {
        return "function" == typeof value ? value.apply(void 0, args) : value
    }

    function tippy_esm_debounce(fn, ms) {
        return 0 === ms ? fn : function (arg) {
            clearTimeout(timeout), timeout = setTimeout((function () {
                fn(arg)
            }), ms)
        };
        var timeout
    }

    function removeProperties(obj, keys) {
        var clone = Object.assign({}, obj);
        return keys.forEach((function (key) {
            delete clone[key]
        })), clone
    }

    function normalizeToArray(value) {
        return [].concat(value)
    }

    function pushIfUnique(arr, value) {
        -1 === arr.indexOf(value) && arr.push(value)
    }

    function tippy_esm_getBasePlacement(placement) {
        return placement.split("-")[0]
    }

    function arrayFrom(value) {
        return [].slice.call(value)
    }

    function removeUndefinedProps(obj) {
        return Object.keys(obj).reduce((function (acc, key) {
            return void 0 !== obj[key] && (acc[key] = obj[key]), acc
        }), {})
    }

    function div() {
        return document.createElement("div")
    }

    function tippy_esm_isElement(value) {
        return ["Element", "Fragment"].some((function (type) {
            return isType(value, type)
        }))
    }

    function isMouseEvent(value) {
        return isType(value, "MouseEvent")
    }

    function isReferenceElement(value) {
        return !(!value || !value._tippy || value._tippy.reference !== value)
    }

    function getArrayOfElements(value) {
        return tippy_esm_isElement(value) ? [value] : function (value) {
            return isType(value, "NodeList")
        }(value) ? arrayFrom(value) : Array.isArray(value) ? value : arrayFrom(document.querySelectorAll(value))
    }

    function setTransitionDuration(els, value) {
        els.forEach((function (el) {
            el && (el.style.transitionDuration = value + "ms")
        }))
    }

    function setVisibilityState(els, state) {
        els.forEach((function (el) {
            el && el.setAttribute("data-state", state)
        }))
    }

    function getOwnerDocument(elementOrElements) {
        var _element$ownerDocumen, element = normalizeToArray(elementOrElements)[0];
        return null != element && null != (_element$ownerDocumen = element.ownerDocument) && _element$ownerDocumen.body ? element.ownerDocument : document
    }

    function updateTransitionEndListener(box, action, listener) {
        var method = action + "EventListener";
        ["transitionend", "webkitTransitionEnd"].forEach((function (event) {
            box[method](event, listener)
        }))
    }

    function actualContains(parent, child) {
        for (var target = child; target;) {
            var _target$getRootNode;
            if (parent.contains(target)) return !0;
            target = null == target.getRootNode || null == (_target$getRootNode = target.getRootNode()) ? void 0 : _target$getRootNode.host
        }
        return !1
    }
    var currentInput = {
        isTouch: !1
    },
        lastMouseMoveTime = 0;

    function onDocumentTouchStart() {
        currentInput.isTouch || (currentInput.isTouch = !0, window.performance && document.addEventListener("mousemove", onDocumentMouseMove))
    }

    function onDocumentMouseMove() {
        var now = performance.now();
        now - lastMouseMoveTime < 20 && (currentInput.isTouch = !1, document.removeEventListener("mousemove", onDocumentMouseMove)), lastMouseMoveTime = now
    }

    function onWindowBlur() {
        var activeElement = document.activeElement;
        if (isReferenceElement(activeElement)) {
            var instance = activeElement._tippy;
            activeElement.blur && !instance.state.isVisible && activeElement.blur()
        }
    }
    var visitedMessages, isIE11 = !!("undefined" != typeof window && "undefined" != typeof document) && !!window.msCrypto;

    function createMemoryLeakWarning(method) {
        return [method + "() was called on a" + ("destroy" === method ? "n already-" : " ") + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ")
    }

    function clean(value) {
        return value.replace(/[ \t]{2,}/g, " ").replace(/^[ \t]*/gm, "").trim()
    }

    function getDevMessage(message) {
        return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c👷‍ This is a development-only message. It will be removed in production.\n  ")
    }

    function getFormattedMessage(message) {
        return [getDevMessage(message), "color: #00C584; font-size: 1.3em; font-weight: bold;", "line-height: 1.5", "color: #a6a095;"]
    }

    function warnWhen(condition, message) {
        var _console;
        condition && !visitedMessages.has(message) && (visitedMessages.add(message), (_console = console).warn.apply(_console, getFormattedMessage(message)))
    }

    function errorWhen(condition, message) {
        var _console2;
        condition && !visitedMessages.has(message) && (visitedMessages.add(message), (_console2 = console).error.apply(_console2, getFormattedMessage(message)))
    }
    visitedMessages = new Set;
    var pluginProps = {
        animateFill: !1,
        followCursor: !1,
        inlinePositioning: !1,
        sticky: !1
    },
        defaultProps = Object.assign({
            appendTo: TIPPY_DEFAULT_APPEND_TO,
            aria: {
                content: "auto",
                expanded: "auto"
            },
            delay: 0,
            duration: [300, 250],
            getReferenceClientRect: null,
            hideOnClick: !0,
            ignoreAttributes: !1,
            interactive: !1,
            interactiveBorder: 2,
            interactiveDebounce: 0,
            moveTransition: "",
            offset: [0, 10],
            onAfterUpdate: function () { },
            onBeforeUpdate: function () { },
            onCreate: function () { },
            onDestroy: function () { },
            onHidden: function () { },
            onHide: function () { },
            onMount: function () { },
            onShow: function () { },
            onShown: function () { },
            onTrigger: function () { },
            onUntrigger: function () { },
            onClickOutside: function () { },
            placement: "top",
            plugins: [],
            popperOptions: {},
            render: null,
            showOnCreate: !1,
            touch: !0,
            trigger: "mouseenter focus",
            triggerTarget: null
        }, pluginProps, {
            allowHTML: !1,
            animation: "fade",
            arrow: !0,
            content: "",
            inertia: !1,
            maxWidth: 350,
            role: "tooltip",
            theme: "",
            zIndex: 9999
        }),
        defaultKeys = Object.keys(defaultProps);

    function getExtendedPassedProps(passedProps) {
        var pluginProps = (passedProps.plugins || []).reduce((function (acc, plugin) {
            var _name, name = plugin.name,
                defaultValue = plugin.defaultValue;
            name && (acc[name] = void 0 !== passedProps[name] ? passedProps[name] : null != (_name = defaultProps[name]) ? _name : defaultValue);
            return acc
        }), {});
        return Object.assign({}, passedProps, pluginProps)
    }

    function evaluateProps(reference, props) {
        var out = Object.assign({}, props, {
            content: invokeWithArgsOrReturn(props.content, [reference])
        }, props.ignoreAttributes ? {} : function (reference, plugins) {
            return (plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
                plugins: plugins
            }))) : defaultKeys).reduce((function (acc, key) {
                var valueAsString = (reference.getAttribute("data-tippy-" + key) || "").trim();
                if (!valueAsString) return acc;
                if ("content" === key) acc[key] = valueAsString;
                else try {
                    acc[key] = JSON.parse(valueAsString)
                } catch (e) {
                    acc[key] = valueAsString
                }
                return acc
            }), {})
        }(reference, props.plugins));
        return out.aria = Object.assign({}, defaultProps.aria, out.aria), out.aria = {
            expanded: "auto" === out.aria.expanded ? props.interactive : out.aria.expanded,
            content: "auto" === out.aria.content ? props.interactive ? null : "describedby" : out.aria.content
        }, out
    }

    function validateProps(partialProps, plugins) {
        void 0 === partialProps && (partialProps = {}), void 0 === plugins && (plugins = []), Object.keys(partialProps).forEach((function (prop) {
            var obj, key, nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps)),
                didPassUnknownProp = (obj = nonPluginProps, key = prop, !{}.hasOwnProperty.call(obj, key));
            didPassUnknownProp && (didPassUnknownProp = 0 === plugins.filter((function (plugin) {
                return plugin.name === prop
            })).length), warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "))
        }))
    }

    function dangerouslySetInnerHTML(element, html) {
        element.innerHTML = html
    }

    function createArrowElement(value) {
        var arrow = div();
        return !0 === value ? arrow.className = "tippy-arrow" : (arrow.className = "tippy-svg-arrow", tippy_esm_isElement(value) ? arrow.appendChild(value) : dangerouslySetInnerHTML(arrow, value)), arrow
    }

    function tippy_esm_setContent(content, props) {
        tippy_esm_isElement(props.content) ? (dangerouslySetInnerHTML(content, ""), content.appendChild(props.content)) : "function" != typeof props.content && (props.allowHTML ? dangerouslySetInnerHTML(content, props.content) : content.textContent = props.content)
    }

    function getChildren(popper) {
        var box = popper.firstElementChild,
            boxChildren = arrayFrom(box.children);
        return {
            box: box,
            content: boxChildren.find((function (node) {
                return node.classList.contains("tippy-content")
            })),
            arrow: boxChildren.find((function (node) {
                return node.classList.contains("tippy-arrow") || node.classList.contains("tippy-svg-arrow")
            })),
            backdrop: boxChildren.find((function (node) {
                return node.classList.contains("tippy-backdrop")
            }))
        }
    }

    function tippy_esm_render(instance) {
        var popper = div(),
            box = div();
        box.className = "tippy-box", box.setAttribute("data-state", "hidden"), box.setAttribute("tabindex", "-1");
        var content = div();

        function onUpdate(prevProps, nextProps) {
            var _getChildren = getChildren(popper),
                box = _getChildren.box,
                content = _getChildren.content,
                arrow = _getChildren.arrow;
            nextProps.theme ? box.setAttribute("data-theme", nextProps.theme) : box.removeAttribute("data-theme"), "string" == typeof nextProps.animation ? box.setAttribute("data-animation", nextProps.animation) : box.removeAttribute("data-animation"), nextProps.inertia ? box.setAttribute("data-inertia", "") : box.removeAttribute("data-inertia"), box.style.maxWidth = "number" == typeof nextProps.maxWidth ? nextProps.maxWidth + "px" : nextProps.maxWidth, nextProps.role ? box.setAttribute("role", nextProps.role) : box.removeAttribute("role"), prevProps.content === nextProps.content && prevProps.allowHTML === nextProps.allowHTML || tippy_esm_setContent(content, instance.props), nextProps.arrow ? arrow ? prevProps.arrow !== nextProps.arrow && (box.removeChild(arrow), box.appendChild(createArrowElement(nextProps.arrow))) : box.appendChild(createArrowElement(nextProps.arrow)) : arrow && box.removeChild(arrow)
        }
        return content.className = "tippy-content", content.setAttribute("data-state", "hidden"), tippy_esm_setContent(content, instance.props), popper.appendChild(box), box.appendChild(content), onUpdate(instance.props, instance.props), {
            popper: popper,
            onUpdate: onUpdate
        }
    }
    tippy_esm_render.$$tippy = !0;
    var idCounter = 1,
        mouseMoveListeners = [],
        mountedInstances = [];

    function createTippy(reference, passedProps) {
        var showTimeout, hideTimeout, scheduleHideAnimationFrame, lastTriggerEvent, currentTransitionEndListener, onFirstUpdate, currentTarget, arr, props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))),
            isVisibleFromClick = !1,
            didHideDueToDocumentMouseDown = !1,
            didTouchMove = !1,
            ignoreOnFirstUpdate = !1,
            listeners = [],
            debouncedOnMouseMove = tippy_esm_debounce(onMouseMove, props.interactiveDebounce),
            id = idCounter++,
            plugins = (arr = props.plugins).filter((function (item, index) {
                return arr.indexOf(item) === index
            })),
            instance = {
                id: id,
                reference: reference,
                popper: div(),
                popperInstance: null,
                props: props,
                state: {
                    isEnabled: !0,
                    isVisible: !1,
                    isDestroyed: !1,
                    isMounted: !1,
                    isShown: !1
                },
                plugins: plugins,
                clearDelayTimeouts: function () {
                    clearTimeout(showTimeout), clearTimeout(hideTimeout), cancelAnimationFrame(scheduleHideAnimationFrame)
                },
                setProps: function (partialProps) {
                    warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
                    if (instance.state.isDestroyed) return;
                    invokeHook("onBeforeUpdate", [instance, partialProps]), removeListeners();
                    var prevProps = instance.props,
                        nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
                            ignoreAttributes: !0
                        }));
                    instance.props = nextProps, addListeners(), prevProps.interactiveDebounce !== nextProps.interactiveDebounce && (cleanupInteractiveMouseListeners(), debouncedOnMouseMove = tippy_esm_debounce(onMouseMove, nextProps.interactiveDebounce));
                    prevProps.triggerTarget && !nextProps.triggerTarget ? normalizeToArray(prevProps.triggerTarget).forEach((function (node) {
                        node.removeAttribute("aria-expanded")
                    })) : nextProps.triggerTarget && reference.removeAttribute("aria-expanded");
                    handleAriaExpandedAttribute(), handleStyles(), onUpdate && onUpdate(prevProps, nextProps);
                    instance.popperInstance && (createPopperInstance(), getNestedPopperTree().forEach((function (nestedPopper) {
                        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate)
                    })));
                    invokeHook("onAfterUpdate", [instance, partialProps])
                },
                setContent: function (content) {
                    instance.setProps({
                        content: content
                    })
                },
                show: function () {
                    warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
                    var isAlreadyVisible = instance.state.isVisible,
                        isDestroyed = instance.state.isDestroyed,
                        isDisabled = !instance.state.isEnabled,
                        isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch,
                        duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
                    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) return;
                    if (getCurrentTarget().hasAttribute("disabled")) return;
                    if (invokeHook("onShow", [instance], !1), !1 === instance.props.onShow(instance)) return;
                    instance.state.isVisible = !0, getIsDefaultRenderFn() && (popper.style.visibility = "visible");
                    handleStyles(), addDocumentPress(), instance.state.isMounted || (popper.style.transition = "none");
                    if (getIsDefaultRenderFn()) {
                        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
                            box = _getDefaultTemplateCh2.box,
                            content = _getDefaultTemplateCh2.content;
                        setTransitionDuration([box, content], 0)
                    }
                    onFirstUpdate = function () {
                        var _instance$popperInsta2;
                        if (instance.state.isVisible && !ignoreOnFirstUpdate) {
                            if (ignoreOnFirstUpdate = !0, popper.offsetHeight, popper.style.transition = instance.props.moveTransition, getIsDefaultRenderFn() && instance.props.animation) {
                                var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                                    _box = _getDefaultTemplateCh3.box,
                                    _content = _getDefaultTemplateCh3.content;
                                setTransitionDuration([_box, _content], duration), setVisibilityState([_box, _content], "visible")
                            }
                            handleAriaContentAttribute(), handleAriaExpandedAttribute(), pushIfUnique(mountedInstances, instance), null == (_instance$popperInsta2 = instance.popperInstance) || _instance$popperInsta2.forceUpdate(), invokeHook("onMount", [instance]), instance.props.animation && getIsDefaultRenderFn() && function (duration, callback) {
                                onTransitionEnd(duration, callback)
                            }(duration, (function () {
                                instance.state.isShown = !0, invokeHook("onShown", [instance])
                            }))
                        }
                    },
                        function () {
                            var parentNode, appendTo = instance.props.appendTo,
                                node = getCurrentTarget();
                            parentNode = instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || "parent" === appendTo ? node.parentNode : invokeWithArgsOrReturn(appendTo, [node]);
                            parentNode.contains(popper) || parentNode.appendChild(popper);
                            instance.state.isMounted = !0, createPopperInstance(), warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "))
                        }()
                },
                hide: function () {
                    warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
                    var isAlreadyHidden = !instance.state.isVisible,
                        isDestroyed = instance.state.isDestroyed,
                        isDisabled = !instance.state.isEnabled,
                        duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
                    if (isAlreadyHidden || isDestroyed || isDisabled) return;
                    if (invokeHook("onHide", [instance], !1), !1 === instance.props.onHide(instance)) return;
                    instance.state.isVisible = !1, instance.state.isShown = !1, ignoreOnFirstUpdate = !1, isVisibleFromClick = !1, getIsDefaultRenderFn() && (popper.style.visibility = "hidden");
                    if (cleanupInteractiveMouseListeners(), removeDocumentPress(), handleStyles(!0), getIsDefaultRenderFn()) {
                        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
                            box = _getDefaultTemplateCh4.box,
                            content = _getDefaultTemplateCh4.content;
                        instance.props.animation && (setTransitionDuration([box, content], duration), setVisibilityState([box, content], "hidden"))
                    }
                    handleAriaContentAttribute(), handleAriaExpandedAttribute(), instance.props.animation ? getIsDefaultRenderFn() && function (duration, callback) {
                        onTransitionEnd(duration, (function () {
                            !instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper) && callback()
                        }))
                    }(duration, instance.unmount) : instance.unmount()
                },
                hideWithInteractivity: function (event) {
                    warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
                    getDocument().addEventListener("mousemove", debouncedOnMouseMove), pushIfUnique(mouseMoveListeners, debouncedOnMouseMove), debouncedOnMouseMove(event)
                },
                enable: function () {
                    instance.state.isEnabled = !0
                },
                disable: function () {
                    instance.hide(), instance.state.isEnabled = !1
                },
                unmount: function () {
                    warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
                    instance.state.isVisible && instance.hide();
                    if (!instance.state.isMounted) return;
                    destroyPopperInstance(), getNestedPopperTree().forEach((function (nestedPopper) {
                        nestedPopper._tippy.unmount()
                    })), popper.parentNode && popper.parentNode.removeChild(popper);
                    mountedInstances = mountedInstances.filter((function (i) {
                        return i !== instance
                    })), instance.state.isMounted = !1, invokeHook("onHidden", [instance])
                },
                destroy: function () {
                    warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
                    if (instance.state.isDestroyed) return;
                    instance.clearDelayTimeouts(), instance.unmount(), removeListeners(), delete reference._tippy, instance.state.isDestroyed = !0, invokeHook("onDestroy", [instance])
                }
            };
        if (!props.render) return errorWhen(!0, "render() function has not been supplied."), instance;
        var _props$render = props.render(instance),
            popper = _props$render.popper,
            onUpdate = _props$render.onUpdate;
        popper.setAttribute("data-tippy-root", ""), popper.id = "tippy-" + instance.id, instance.popper = popper, reference._tippy = instance, popper._tippy = instance;
        var pluginsHooks = plugins.map((function (plugin) {
            return plugin.fn(instance)
        })),
            hasAriaExpanded = reference.hasAttribute("aria-expanded");
        return addListeners(), handleAriaExpandedAttribute(), handleStyles(), invokeHook("onCreate", [instance]), props.showOnCreate && scheduleShow(), popper.addEventListener("mouseenter", (function () {
            instance.props.interactive && instance.state.isVisible && instance.clearDelayTimeouts()
        })), popper.addEventListener("mouseleave", (function () {
            instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0 && getDocument().addEventListener("mousemove", debouncedOnMouseMove)
        })), instance;

        function getNormalizedTouchSettings() {
            var touch = instance.props.touch;
            return Array.isArray(touch) ? touch : [touch, 0]
        }

        function getIsCustomTouchBehavior() {
            return "hold" === getNormalizedTouchSettings()[0]
        }

        function getIsDefaultRenderFn() {
            var _instance$props$rende;
            return !(null == (_instance$props$rende = instance.props.render) || !_instance$props$rende.$$tippy)
        }

        function getCurrentTarget() {
            return currentTarget || reference
        }

        function getDocument() {
            var parent = getCurrentTarget().parentNode;
            return parent ? getOwnerDocument(parent) : document
        }

        function getDefaultTemplateChildren() {
            return getChildren(popper)
        }

        function getDelay(isShow) {
            return instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && "focus" === lastTriggerEvent.type ? 0 : getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay)
        }

        function handleStyles(fromHide) {
            void 0 === fromHide && (fromHide = !1), popper.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none", popper.style.zIndex = "" + instance.props.zIndex
        }

        function invokeHook(hook, args, shouldInvokePropsHook) {
            var _instance$props;
            (void 0 === shouldInvokePropsHook && (shouldInvokePropsHook = !0), pluginsHooks.forEach((function (pluginHooks) {
                pluginHooks[hook] && pluginHooks[hook].apply(pluginHooks, args)
            })), shouldInvokePropsHook) && (_instance$props = instance.props)[hook].apply(_instance$props, args)
        }

        function handleAriaContentAttribute() {
            var aria = instance.props.aria;
            if (aria.content) {
                var attr = "aria-" + aria.content,
                    id = popper.id;
                normalizeToArray(instance.props.triggerTarget || reference).forEach((function (node) {
                    var currentValue = node.getAttribute(attr);
                    if (instance.state.isVisible) node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
                    else {
                        var nextValue = currentValue && currentValue.replace(id, "").trim();
                        nextValue ? node.setAttribute(attr, nextValue) : node.removeAttribute(attr)
                    }
                }))
            }
        }

        function handleAriaExpandedAttribute() {
            !hasAriaExpanded && instance.props.aria.expanded && normalizeToArray(instance.props.triggerTarget || reference).forEach((function (node) {
                instance.props.interactive ? node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false") : node.removeAttribute("aria-expanded")
            }))
        }

        function cleanupInteractiveMouseListeners() {
            getDocument().removeEventListener("mousemove", debouncedOnMouseMove), mouseMoveListeners = mouseMoveListeners.filter((function (listener) {
                return listener !== debouncedOnMouseMove
            }))
        }

        function onDocumentPress(event) {
            if (!currentInput.isTouch || !didTouchMove && "mousedown" !== event.type) {
                var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
                if (!instance.props.interactive || !actualContains(popper, actualTarget)) {
                    if (normalizeToArray(instance.props.triggerTarget || reference).some((function (el) {
                        return actualContains(el, actualTarget)
                    }))) {
                        if (currentInput.isTouch) return;
                        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) return
                    } else invokeHook("onClickOutside", [instance, event]);
                    !0 === instance.props.hideOnClick && (instance.clearDelayTimeouts(), instance.hide(), didHideDueToDocumentMouseDown = !0, setTimeout((function () {
                        didHideDueToDocumentMouseDown = !1
                    })), instance.state.isMounted || removeDocumentPress())
                }
            }
        }

        function onTouchMove() {
            didTouchMove = !0
        }

        function onTouchStart() {
            didTouchMove = !1
        }

        function addDocumentPress() {
            var doc = getDocument();
            doc.addEventListener("mousedown", onDocumentPress, !0), doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS), doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS), doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS)
        }

        function removeDocumentPress() {
            var doc = getDocument();
            doc.removeEventListener("mousedown", onDocumentPress, !0), doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS), doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS), doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS)
        }

        function onTransitionEnd(duration, callback) {
            var box = getDefaultTemplateChildren().box;

            function listener(event) {
                event.target === box && (updateTransitionEndListener(box, "remove", listener), callback())
            }
            if (0 === duration) return callback();
            updateTransitionEndListener(box, "remove", currentTransitionEndListener), updateTransitionEndListener(box, "add", listener), currentTransitionEndListener = listener
        }

        function on(eventType, handler, options) {
            void 0 === options && (options = !1), normalizeToArray(instance.props.triggerTarget || reference).forEach((function (node) {
                node.addEventListener(eventType, handler, options), listeners.push({
                    node: node,
                    eventType: eventType,
                    handler: handler,
                    options: options
                })
            }))
        }

        function addListeners() {
            var value;
            getIsCustomTouchBehavior() && (on("touchstart", onTrigger, {
                passive: !0
            }), on("touchend", onMouseLeave, {
                passive: !0
            })), (value = instance.props.trigger, value.split(/\s+/).filter(Boolean)).forEach((function (eventType) {
                if ("manual" !== eventType) switch (on(eventType, onTrigger), eventType) {
                    case "mouseenter":
                        on("mouseleave", onMouseLeave);
                        break;
                    case "focus":
                        on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
                        break;
                    case "focusin":
                        on("focusout", onBlurOrFocusOut)
                }
            }))
        }

        function removeListeners() {
            listeners.forEach((function (_ref) {
                var node = _ref.node,
                    eventType = _ref.eventType,
                    handler = _ref.handler,
                    options = _ref.options;
                node.removeEventListener(eventType, handler, options)
            })), listeners = []
        }

        function onTrigger(event) {
            var _lastTriggerEvent, shouldScheduleClickHide = !1;
            if (instance.state.isEnabled && !isEventListenerStopped(event) && !didHideDueToDocumentMouseDown) {
                var wasFocused = "focus" === (null == (_lastTriggerEvent = lastTriggerEvent) ? void 0 : _lastTriggerEvent.type);
                lastTriggerEvent = event, currentTarget = event.currentTarget, handleAriaExpandedAttribute(), !instance.state.isVisible && isMouseEvent(event) && mouseMoveListeners.forEach((function (listener) {
                    return listener(event)
                })), "click" === event.type && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && !1 !== instance.props.hideOnClick && instance.state.isVisible ? shouldScheduleClickHide = !0 : scheduleShow(event), "click" === event.type && (isVisibleFromClick = !shouldScheduleClickHide), shouldScheduleClickHide && !wasFocused && scheduleHide(event)
            }
        }

        function onMouseMove(event) {
            var target = event.target,
                isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);
            "mousemove" === event.type && isCursorOverReferenceOrPopper || function (popperTreeData, event) {
                var clientX = event.clientX,
                    clientY = event.clientY;
                return popperTreeData.every((function (_ref) {
                    var popperRect = _ref.popperRect,
                        popperState = _ref.popperState,
                        interactiveBorder = _ref.props.interactiveBorder,
                        basePlacement = tippy_esm_getBasePlacement(popperState.placement),
                        offsetData = popperState.modifiersData.offset;
                    if (!offsetData) return !0;
                    var topDistance = "bottom" === basePlacement ? offsetData.top.y : 0,
                        bottomDistance = "top" === basePlacement ? offsetData.bottom.y : 0,
                        leftDistance = "right" === basePlacement ? offsetData.left.x : 0,
                        rightDistance = "left" === basePlacement ? offsetData.right.x : 0,
                        exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder,
                        exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder,
                        exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder,
                        exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
                    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight
                }))
            }(getNestedPopperTree().concat(popper).map((function (popper) {
                var _instance$popperInsta, state = null == (_instance$popperInsta = popper._tippy.popperInstance) ? void 0 : _instance$popperInsta.state;
                return state ? {
                    popperRect: popper.getBoundingClientRect(),
                    popperState: state,
                    props: props
                } : null
            })).filter(Boolean), event) && (cleanupInteractiveMouseListeners(), scheduleHide(event))
        }

        function onMouseLeave(event) {
            isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick || (instance.props.interactive ? instance.hideWithInteractivity(event) : scheduleHide(event))
        }

        function onBlurOrFocusOut(event) {
            instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget() || instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget) || scheduleHide(event)
        }

        function isEventListenerStopped(event) {
            return !!currentInput.isTouch && getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0
        }

        function createPopperInstance() {
            destroyPopperInstance();
            var _instance$props2 = instance.props,
                popperOptions = _instance$props2.popperOptions,
                placement = _instance$props2.placement,
                offset = _instance$props2.offset,
                getReferenceClientRect = _instance$props2.getReferenceClientRect,
                moveTransition = _instance$props2.moveTransition,
                arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null,
                computedReference = getReferenceClientRect ? {
                    getBoundingClientRect: getReferenceClientRect,
                    contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
                } : reference,
                modifiers = [{
                    name: "offset",
                    options: {
                        offset: offset
                    }
                }, {
                    name: "preventOverflow",
                    options: {
                        padding: {
                            top: 2,
                            bottom: 2,
                            left: 5,
                            right: 5
                        }
                    }
                }, {
                    name: "flip",
                    options: {
                        padding: 5
                    }
                }, {
                    name: "computeStyles",
                    options: {
                        adaptive: !moveTransition
                    }
                }, {
                    name: "$$tippy",
                    enabled: !0,
                    phase: "beforeWrite",
                    requires: ["computeStyles"],
                    fn: function (_ref2) {
                        var state = _ref2.state;
                        if (getIsDefaultRenderFn()) {
                            var box = getDefaultTemplateChildren().box;
                            ["placement", "reference-hidden", "escaped"].forEach((function (attr) {
                                "placement" === attr ? box.setAttribute("data-placement", state.placement) : state.attributes.popper["data-popper-" + attr] ? box.setAttribute("data-" + attr, "") : box.removeAttribute("data-" + attr)
                            })), state.attributes.popper = {}
                        }
                    }
                }];
            getIsDefaultRenderFn() && arrow && modifiers.push({
                name: "arrow",
                options: {
                    element: arrow,
                    padding: 3
                }
            }), modifiers.push.apply(modifiers, (null == popperOptions ? void 0 : popperOptions.modifiers) || []), instance.popperInstance = popper_createPopper(computedReference, popper, Object.assign({}, popperOptions, {
                placement: placement,
                onFirstUpdate: onFirstUpdate,
                modifiers: modifiers
            }))
        }

        function destroyPopperInstance() {
            instance.popperInstance && (instance.popperInstance.destroy(), instance.popperInstance = null)
        }

        function getNestedPopperTree() {
            return arrayFrom(popper.querySelectorAll("[data-tippy-root]"))
        }

        function scheduleShow(event) {
            instance.clearDelayTimeouts(), event && invokeHook("onTrigger", [instance, event]), addDocumentPress();
            var delay = getDelay(!0),
                _getNormalizedTouchSe = getNormalizedTouchSettings(),
                touchValue = _getNormalizedTouchSe[0],
                touchDelay = _getNormalizedTouchSe[1];
            currentInput.isTouch && "hold" === touchValue && touchDelay && (delay = touchDelay), delay ? showTimeout = setTimeout((function () {
                instance.show()
            }), delay) : instance.show()
        }

        function scheduleHide(event) {
            if (instance.clearDelayTimeouts(), invokeHook("onUntrigger", [instance, event]), instance.state.isVisible) {
                if (!(instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick)) {
                    var delay = getDelay(!1);
                    delay ? hideTimeout = setTimeout((function () {
                        instance.state.isVisible && instance.hide()
                    }), delay) : scheduleHideAnimationFrame = requestAnimationFrame((function () {
                        instance.hide()
                    }))
                }
            } else removeDocumentPress()
        }
    }

    function tippy(targets, optionalProps) {
        void 0 === optionalProps && (optionalProps = {});
        var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
        ! function (targets) {
            var didPassFalsyValue = !targets,
                didPassPlainObject = "[object Object]" === Object.prototype.toString.call(targets) && !targets.addEventListener;
            errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "))
        }(targets), validateProps(optionalProps, plugins), document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS), window.addEventListener("blur", onWindowBlur);
        var passedProps = Object.assign({}, optionalProps, {
            plugins: plugins
        }),
            elements = getArrayOfElements(targets),
            isSingleContentElement = tippy_esm_isElement(passedProps.content),
            isMoreThanOneReferenceElement = elements.length > 1;
        warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
        var instances = elements.reduce((function (acc, reference) {
            var instance = reference && createTippy(reference, passedProps);
            return instance && acc.push(instance), acc
        }), []);
        return tippy_esm_isElement(targets) ? instances[0] : instances
    }
    tippy.defaultProps = defaultProps, tippy.setDefaultProps = function (partialProps) {
        validateProps(partialProps, []), Object.keys(partialProps).forEach((function (key) {
            defaultProps[key] = partialProps[key]
        }))
    }, tippy.currentInput = currentInput;
    Object.assign({}, modifiers_applyStyles, {
        effect: function (_ref) {
            var state = _ref.state,
                initialStyles = {
                    popper: {
                        position: state.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
            Object.assign(state.elements.popper.style, initialStyles.popper), state.styles = initialStyles, state.elements.arrow && Object.assign(state.elements.arrow.style, initialStyles.arrow)
        }
    });
    tippy.setDefaultProps({
        render: tippy_esm_render
    });
    var tippy_esm = tippy,
        clipboard = __webpack_require__(2);
    new (__webpack_require__.n(clipboard).a)(".copy-link"), document.querySelectorAll(".copy-link").forEach((function (link) {
        tippy_esm(link, {
            content: "Coppied to clipboard!",
            trigger: "click",
            placement: "bottom"
        }), link.addEventListener("click", (function (e) {
            e.preventDefault()
        }))
    })), aos_default.a.init({
        duration: 1e3,
        easing: "ease",
        once: !0,
        disable: "phone"
    })
}]);